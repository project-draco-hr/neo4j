{
  monitor.queuedMessage(message);
  final URI to=URI.create(message.getHeader(Message.TO));
  ExecutorService senderExecutor=senderExecutors.get(to);
  if (senderExecutor == null) {
    senderExecutor=Executors.newSingleThreadExecutor(new NamedThreadFactory("Cluster Sender " + to.toASCIIString(),monitor));
    senderExecutors.put(to,senderExecutor);
  }
  senderExecutor.submit(new Runnable(){
    @Override public void run(){
      Channel channel=getChannel(to);
      try {
        if (channel == null) {
          channel=openChannel(to);
          openedChannel(to,channel);
          failedInstances.remove(to);
        }
      }
 catch (      Exception e) {
        if (!failedInstances.contains(to)) {
          msgLog.warn(e.getMessage());
          failedInstances.add(to);
        }
        return;
      }
      try {
        message.setHeader(Message.FROM,me.toASCIIString());
        msgLog.debug("Sending to " + to + ": "+ message);
        ChannelFuture future=channel.write(message);
        future.addListener(new ChannelFutureListener(){
          @Override public void operationComplete(          ChannelFuture future) throws Exception {
            monitor.sentMessage(message);
            if (!future.isSuccess()) {
              msgLog.debug("Unable to write " + message + " to "+ future.getChannel(),future.getCause());
              closedChannel(future.getChannel());
              send(message);
            }
          }
        }
);
      }
 catch (      Exception e) {
        if (Exceptions.contains(e,ClosedChannelException.class)) {
          msgLog.warn("Could not send message, because the connection has been closed.");
        }
 else {
          msgLog.warn("Could not send message",e);
        }
        channel.close();
      }
    }
  }
);
}
