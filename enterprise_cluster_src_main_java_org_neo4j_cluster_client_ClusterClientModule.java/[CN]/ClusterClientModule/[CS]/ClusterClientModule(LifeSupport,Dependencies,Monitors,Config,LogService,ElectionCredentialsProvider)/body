{
  final LogProvider logging=AsyncLogging.provider(life,logService.getInternalLogProvider());
  InternalLoggerFactory.setDefaultFactory(new NettyLoggerFactory(logging));
  TimeoutStrategy timeoutStrategy=new MessageTimeoutStrategy(new FixedTimeoutStrategy(config.get(ClusterSettings.default_timeout))).timeout(HeartbeatMessage.sendHeartbeat,config.get(ClusterSettings.heartbeat_interval)).timeout(HeartbeatMessage.timed_out,config.get(ClusterSettings.heartbeat_timeout)).timeout(AtomicBroadcastMessage.broadcastTimeout,config.get(ClusterSettings.broadcast_timeout)).timeout(LearnerMessage.learnTimedout,config.get(ClusterSettings.learn_timeout)).timeout(ProposerMessage.phase1Timeout,config.get(ClusterSettings.phase1_timeout)).timeout(ProposerMessage.phase2Timeout,config.get(ClusterSettings.phase2_timeout)).timeout(ClusterMessage.joiningTimeout,config.get(ClusterSettings.join_timeout)).timeout(ClusterMessage.configurationTimeout,config.get(ClusterSettings.configuration_timeout)).timeout(ClusterMessage.leaveTimedout,config.get(ClusterSettings.leave_timeout)).timeout(ElectionMessage.electionTimeout,config.get(ClusterSettings.election_timeout));
  MultiPaxosServerFactory protocolServerFactory=new MultiPaxosServerFactory(new ClusterConfiguration(config.get(ClusterSettings.cluster_name),logging),logging,monitors.newMonitor(StateMachines.Monitor.class));
  NetworkReceiver receiver=dependencies.satisfyDependency(new NetworkReceiver(monitors.newMonitor(NetworkReceiver.Monitor.class),new NetworkReceiver.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.get(ClusterSettings.cluster_server);
    }
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public String name(){
      return config.get(ClusterSettings.instance_name);
    }
  }
,logging));
  final ObjectInputStreamFactory objectInputStreamFactory=new ObjectStreamFactory();
  final ObjectOutputStreamFactory objectOutputStreamFactory=new ObjectStreamFactory();
  receiver.addNetworkChannelsListener(new NetworkReceiver.NetworkChannelsListener(){
    volatile private StateTransitionLogger logger=null;
    @Override public void listeningAt(    URI me){
      server.listeningAt(me);
      if (logger == null) {
        logger=new StateTransitionLogger(logging,new AtomicBroadcastSerializer(objectInputStreamFactory,objectOutputStreamFactory));
        server.addStateTransitionListener(logger);
      }
    }
    @Override public void channelOpened(    URI to){
      logging.getLog(NetworkReceiver.class).info(to + " connected to me at " + server.boundAt());
    }
    @Override public void channelClosed(    URI to){
      logging.getLog(NetworkReceiver.class).info(to + " disconnected from me at " + server.boundAt());
    }
  }
);
  NetworkSender sender=dependencies.satisfyDependency(new NetworkSender(monitors.newMonitor(NetworkSender.Monitor.class),new NetworkSender.Configuration(){
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public int port(){
      return config.get(ClusterSettings.cluster_server).getPort();
    }
  }
,receiver,logging));
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine",monitors.newMonitor(NamedThreadFactory.Monitor.class)));
    }
  }
);
  AcceptorInstanceStore acceptorInstanceStore=new InMemoryAcceptorInstanceStore();
  server=protocolServerFactory.newProtocolServer(config.get(ClusterSettings.server_id),timeoutStrategy,receiver,sender,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor,objectInputStreamFactory,objectOutputStreamFactory);
  life.add(sender);
  life.add(stateMachineExecutor);
  life.add(receiver);
  life.add(new TimeoutTrigger(server,monitors));
  life.add(new ClusterJoin(new ClusterJoin.Configuration(){
    @Override public List<HostnamePort> getInitialHosts(){
      return config.get(ClusterSettings.initial_hosts);
    }
    @Override public String getClusterName(){
      return config.get(ClusterSettings.cluster_name);
    }
    @Override public boolean isAllowedToCreateCluster(){
      return config.get(ClusterSettings.allow_init_cluster);
    }
    @Override public long getClusterJoinTimeout(){
      return config.get(clusterJoinTimeout);
    }
  }
,server,logService));
  clusterClient=dependencies.satisfyDependency(new ClusterClient(life,server));
}
