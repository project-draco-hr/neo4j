{
  this.life=new LifeSupport();
  if (parentLife != null) {
    parentLife.add(this.life);
  }
  final LogProvider internalLogProvider=logService.getInternalLogProvider();
  InternalLoggerFactory.setDefaultFactory(new NettyLoggerFactory(internalLogProvider));
  timeoutStrategy=new MessageTimeoutStrategy(new FixedTimeoutStrategy(config.get(ClusterSettings.default_timeout))).timeout(HeartbeatMessage.sendHeartbeat,config.get(ClusterSettings.heartbeat_interval)).timeout(HeartbeatMessage.timed_out,config.get(ClusterSettings.heartbeat_timeout)).timeout(AtomicBroadcastMessage.broadcastTimeout,config.get(ClusterSettings.broadcast_timeout)).timeout(LearnerMessage.learnTimedout,config.get(ClusterSettings.learn_timeout)).timeout(ProposerMessage.phase1Timeout,config.get(ClusterSettings.phase1_timeout)).timeout(ProposerMessage.phase2Timeout,config.get(ClusterSettings.phase2_timeout)).timeout(ClusterMessage.joiningTimeout,config.get(ClusterSettings.join_timeout)).timeout(ClusterMessage.configurationTimeout,config.get(ClusterSettings.configuration_timeout)).timeout(ClusterMessage.leaveTimedout,config.get(ClusterSettings.leave_timeout)).timeout(ElectionMessage.electionTimeout,config.get(ClusterSettings.election_timeout));
  MultiPaxosServerFactory protocolServerFactory=new MultiPaxosServerFactory(new ClusterConfiguration(config.get(ClusterSettings.cluster_name),internalLogProvider),logService,monitors.newMonitor(StateMachines.Monitor.class));
  receiver=dependencies.satisfyDependency(new NetworkReceiver(monitors.newMonitor(NetworkReceiver.Monitor.class),new NetworkReceiver.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.get(ClusterSettings.cluster_server);
    }
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public String name(){
      return config.get(ClusterSettings.instance_name);
    }
  }
,internalLogProvider));
  final ObjectInputStreamFactory objectInputStreamFactory=new ObjectStreamFactory();
  final ObjectOutputStreamFactory objectOutputStreamFactory=new ObjectStreamFactory();
  receiver.addNetworkChannelsListener(new NetworkReceiver.NetworkChannelsListener(){
    volatile private StateTransitionLogger logger=null;
    @Override public void listeningAt(    URI me){
      server.listeningAt(me);
      if (logger == null) {
        logger=new StateTransitionLogger(internalLogProvider,new AtomicBroadcastSerializer(objectInputStreamFactory,objectOutputStreamFactory));
        server.addStateTransitionListener(logger);
      }
    }
    @Override public void channelOpened(    URI to){
      internalLogProvider.getLog(NetworkReceiver.class).info(to + " connected to me at " + server.boundAt());
    }
    @Override public void channelClosed(    URI to){
      internalLogProvider.getLog(NetworkReceiver.class).info(to + " disconnected from me at " + server.boundAt());
    }
  }
);
  NetworkSender sender=dependencies.satisfyDependency(new NetworkSender(monitors.newMonitor(NetworkSender.Monitor.class),new NetworkSender.Configuration(){
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public int port(){
      return config.get(ClusterSettings.cluster_server).getPort();
    }
  }
,receiver,internalLogProvider));
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine",monitors.newMonitor(NamedThreadFactory.Monitor.class)));
    }
  }
);
  acceptorInstanceStore=new InMemoryAcceptorInstanceStore();
  server=protocolServerFactory.newProtocolServer(config.get(ClusterSettings.server_id),timeoutStrategy,receiver,sender,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor,objectInputStreamFactory,objectOutputStreamFactory);
  this.life.add(sender);
  this.life.add(stateMachineExecutor);
  this.life.add(receiver);
  this.life.add(new TimeoutTrigger(server,monitors));
  this.life.add(new ClusterJoin(new ClusterJoin.Configuration(){
    @Override public List<HostnamePort> getInitialHosts(){
      return config.get(ClusterSettings.initial_hosts);
    }
    @Override public String getClusterName(){
      return config.get(ClusterSettings.cluster_name);
    }
    @Override public boolean isAllowedToCreateCluster(){
      return config.get(ClusterSettings.allow_init_cluster);
    }
    @Override public long getClusterJoinTimeout(){
      return config.get(clusterJoinTimeout);
    }
  }
,server,logService));
  clusterClient=dependencies.satisfyDependency(new ClusterClient(this.life,server));
}
