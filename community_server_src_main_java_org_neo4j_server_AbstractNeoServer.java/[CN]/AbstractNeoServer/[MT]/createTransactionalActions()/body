{
  final int timeout=configurator.configuration().getInt(TRANSACTION_TIMEOUT,DEFAULT_TRANSACTION_TIMEOUT);
  final RealClock clock=new RealClock();
  transactionRegistry=new TransactionHandleRegistry(clock,logging.getMessagesLog(TransactionRegistry.class));
  resolveDependency(JobScheduler.class).scheduleRecurring(new Runnable(){
    @Override public void run(){
      long maxAge=clock.currentTimeInMilliseconds() - (1000 * timeout);
      transactionRegistry.rollbackSuspendedTransactionsIdleSince(maxAge);
    }
  }
,round(timeout / 2.0),SECONDS);
  return new TransactionFacade(new TransitionalPeriodTransactionMessContainer(database.getGraph()),new ExecutionEngine(database.getGraph()),transactionRegistry,logging.getMessagesLog(TransactionFacade.class));
}
