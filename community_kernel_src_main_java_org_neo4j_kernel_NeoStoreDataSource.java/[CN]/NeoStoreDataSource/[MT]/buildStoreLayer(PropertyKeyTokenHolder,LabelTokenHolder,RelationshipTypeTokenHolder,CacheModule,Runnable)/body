{
  life.add(new LifecycleAdapter(){
    @Override public void start() throws IOException {
      storeLayerModule.neoStores().makeStoreOk();
      propertyKeyTokenHolder.setInitialTokens(storeLayerModule.neoStores().getPropertyKeyTokenStore().getTokens(Integer.MAX_VALUE));
      relationshipTypeTokens.setInitialTokens(storeLayerModule.neoStores().getRelationshipTypeTokenStore().getTokens(Integer.MAX_VALUE));
      labelTokens.setInitialTokens(storeLayerModule.neoStores().getLabelTokenStore().getTokens(Integer.MAX_VALUE));
      storeLayerModule.neoStores().rebuildCountStoreIfNeeded();
    }
  }
);
  final StoreFactory storeFactory=new StoreFactory(storeDir,config,idGeneratorFactory,pageCache,fs,logProvider);
  final NeoStores neoStores=storeFactory.openAllNeoStores(true);
  final DefaultSchemaIndexProviderMap providerMap;
  final IndexingService indexingService;
  final IntegrityValidator integrityValidator;
  final IndexUpdatesValidator indexUpdatesValidator;
  final LabelScanStore labelScanStore;
  final SchemaCache schemaCache;
  final CacheAccessBackDoor cacheAccess;
  final StoreReadLayer storeLayer;
  try {
    providerMap=new DefaultSchemaIndexProviderMap(indexProvider);
    indexingService=IndexingService.create(new IndexSamplingConfig(config),scheduler,providerMap,new NeoStoreIndexStoreView(lockService,neoStores),tokenNameLookup,toList(new SchemaStorage(neoStores.getSchemaStore()).allIndexRules()),logProvider,indexingServiceMonitor,schemaStateChangeCallback);
    integrityValidator=new IntegrityValidator(neoStores,indexingService);
    indexUpdatesValidator=dependencies.satisfyDependency(new OnlineIndexUpdatesValidator(neoStores,kernelHealth,new PropertyLoader(neoStores),indexingService,IndexUpdateMode.ONLINE));
    labelScanStore=dependencyResolver.resolveDependency(LabelScanStoreProvider.class,LabelScanStoreProvider.HIGHEST_PRIORITIZED).getLabelScanStore();
    life.add(indexingService);
    life.add(labelScanStore);
    schemaCache=new SchemaCache(constraintSemantics,Collections.<SchemaRule>emptyList());
    cacheAccess=new BridgingCacheAccess(schemaCache,schemaStateChangeCallback,propertyKeyTokenHolder,relationshipTypeTokens,labelTokens);
    ProcedureCache procedureCache=cacheModule.procedureCache();
    SchemaStorage schemaStorage=new SchemaStorage(neoStores.getSchemaStore());
    DiskLayer diskLayer=new DiskLayer(propertyKeyTokenHolder,labelTokens,relationshipTypeTokens,schemaStorage,neoStores,indexingService,storeStatementFactory(neoStores));
    storeLayer=new CacheLayer(diskLayer,schemaCache,procedureCache);
  }
 catch (  Throwable failure) {
    neoStores.close();
    throw failure;
  }
  return new StoreLayerModule(){
    @Override public StoreReadLayer storeLayer(){
      return storeLayer;
    }
    @Override public NeoStores neoStores(){
      return neoStores;
    }
    @Override public MetaDataStore metaDataStore(){
      return neoStores.getMetaDataStore();
    }
    @Override public IndexingService indexingService(){
      return indexingService;
    }
    @Override public IndexUpdatesValidator indexUpdatesValidator(){
      return indexUpdatesValidator;
    }
    @Override public LabelScanStore labelScanStore(){
      return labelScanStore;
    }
    @Override public IntegrityValidator integrityValidator(){
      return integrityValidator;
    }
    @Override public SchemaIndexProviderMap schemaIndexProviderMap(){
      return providerMap;
    }
    @Override public CacheAccessBackDoor cacheAccess(){
      return cacheAccess;
    }
    @Override public void loadSchemaCache(){
      List<SchemaRule> schemaRules=toList(neoStores.getSchemaStore().loadAllSchemaRules());
      schemaCache.load(schemaRules);
    }
  }
;
}
