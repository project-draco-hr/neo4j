{
  dependencies=new Dependencies();
  life=new LifeSupport();
  indexProvider=dependencyResolver.resolveDependency(SchemaIndexProvider.class,SchemaIndexProvider.HIGHEST_PRIORITIZED_OR_NONE);
  dependencies.satisfyDependency(lockService);
  LoggingLogFileMonitor loggingLogMonitor=new LoggingLogFileMonitor(msgLog);
  monitors.addMonitorListener(loggingLogMonitor);
  monitors.addMonitorListener(new RecoveryVisitor.Monitor(){
    @Override public void transactionRecovered(    long txId){
      recoveredCount.incrementAndGet();
    }
  }
);
  life.add(new Lifecycle.Delegate(Lifecycles.multiple(indexProviders.values())));
  upgradeStore(storeDir,storeMigrationProcess,indexProvider);
  try {
    LegacyIndexApplierLookup legacyIndexApplierLookup=dependencies.satisfyDependency(new LegacyIndexApplierLookup.Direct(legacyIndexProviderLookup));
    final NeoStoreModule neoStoreModule=buildNeoStore(storeFactory,labelTokens,relationshipTypeTokens,propertyKeyTokenHolder);
    this.neoStoreModule=neoStoreModule;
    CacheModule cacheModule=buildCaches(labelTokens,relationshipTypeTokens,propertyKeyTokenHolder);
    IndexingModule indexingModule=buildIndexing(config,scheduler,indexProvider,lockService,tokenNameLookup,logProvider,indexingServiceMonitor,neoStoreModule.neoStores(),cacheModule.updateableSchemaState());
    StoreLayerModule storeLayerModule=buildStoreLayer(neoStoreModule.neoStores(),propertyKeyTokenHolder,labelTokens,relationshipTypeTokens,indexingModule.indexingService(),cacheModule.schemaCache(),cacheModule.procedureCache());
    TransactionLogModule transactionLogModule=buildTransactionLogs(storeDir,config,logProvider,scheduler,indexingModule.labelScanStore(),fs,neoStoreModule.neoStores(),cacheModule.cacheAccess(),indexingModule.indexingService(),indexProviders.values(),legacyIndexApplierLookup);
    buildRecovery(fs,cacheModule.cacheAccess(),indexingModule.indexingService(),indexingModule.labelScanStore(),neoStoreModule.neoStores(),monitors.newMonitor(RecoveryVisitor.Monitor.class),monitors.newMonitor(Recovery.Monitor.class),transactionLogModule.logFiles(),transactionLogModule.storeFlusher(),startupStatistics,legacyIndexApplierLookup);
    KernelModule kernelModule=buildKernel(indexingModule.integrityValidator(),transactionLogModule.transactionAppender(),neoStoreModule.neoStores(),transactionLogModule.storeApplier(),indexingModule.indexingService(),indexingModule.indexUpdatesValidator(),storeLayerModule.storeLayer(),cacheModule.updateableSchemaState(),indexingModule.labelScanStore(),indexingModule.schemaIndexProviderMap(),cacheModule.procedureCache());
    this.cacheModule=cacheModule;
    this.indexingModule=indexingModule;
    this.storeLayerModule=storeLayerModule;
    this.transactionLogModule=transactionLogModule;
    this.kernelModule=kernelModule;
    dependencies.satisfyDependency(this);
    satisfyDependencies(neoStoreModule,cacheModule,indexingModule,storeLayerModule,transactionLogModule,kernelModule);
  }
 catch (  Throwable e) {
    msgLog.warn("Exception occurred while setting up store modules. Attempting to close things down.",e,true);
    try {
      neoStoreModule.neoStores().close();
    }
 catch (    Exception closeException) {
      msgLog.error("Couldn't close neostore after startup failure");
    }
    throw Exceptions.launderedException(e);
  }
  try {
    life.start();
  }
 catch (  Throwable e) {
    msgLog.warn("Exception occurred while starting the datasource. Attempting to close things down.",e,true);
    try {
      neoStoreModule.neoStores().close();
    }
 catch (    Exception closeException) {
      msgLog.error("Couldn't close neostore after startup failure");
    }
    throw Exceptions.launderedException(e);
  }
  kernelHealth.healed();
}
