{
  LogicalTransactionStore transactionStore=mock(LogicalTransactionStore.class);
  long lastAppliedTransactionId=5L;
  IOCursor<CommittedTransactionRepresentation> endlessCursor=new EndlessCursor(lastAppliedTransactionId + 1);
  when(transactionStore.getTransactions(anyLong())).thenReturn(endlessCursor);
  final long targetTransactionId=8L;
  final TransactionIdStore transactionIdStore=new DeadSimpleTransactionIdStore(targetTransactionId,0,0,0);
  ResponsePacker packer=new ResponsePacker(transactionStore,transactionIdStore,Suppliers.singleton(new StoreId()));
  Response<Object> response=packer.packTransactionStreamResponse(requestContextStartingAt(5L),null);
  final AtomicLong nextExpectedVisit=new AtomicLong(lastAppliedTransactionId);
  response.accept(new Response.Handler(){
    @Override public void obligation(    long txId) throws IOException {
      fail("Should not be called");
    }
    @Override public Visitor<CommittedTransactionRepresentation,Exception> transactions(){
      return new Visitor<CommittedTransactionRepresentation,Exception>(){
        @Override public boolean visit(        CommittedTransactionRepresentation element){
          long txId=element.getCommitEntry().getTxId();
          assertThat(txId,lessThanOrEqualTo(targetTransactionId));
          assertEquals(nextExpectedVisit.incrementAndGet(),txId);
          transactionIdStore.setLastCommittedAndClosedTransactionId(transactionIdStore.getLastCommittedTransactionId() + 1,0,0,0);
          return true;
        }
      }
;
    }
  }
);
}
