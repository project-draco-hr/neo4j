{
  TransactionImpl tx=txThreadMap.get();
  if (tx == null) {
    throw logAndReturn("TM error tx commit",new IllegalStateException("Not in transaction"));
  }
  boolean hasAnyLocks=false;
  boolean successful=false;
  try {
    assertTmOk();
    hasAnyLocks=tx.hasAnyLocks();
    if (tx.getStatus() != Status.STATUS_ACTIVE && tx.getStatus() != Status.STATUS_MARKED_ROLLBACK) {
      throw logAndReturn("TM error tx commit",new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus())));
    }
    tx.doBeforeCompletion();
    if (tx.getStatus() == Status.STATUS_ACTIVE) {
      comittedTxCount.incrementAndGet();
      commit(tx);
    }
 else     if (tx.getStatus() == Status.STATUS_MARKED_ROLLBACK) {
      rolledBackTxCount.incrementAndGet();
      rollbackCommit(tx);
    }
 else {
      throw logAndReturn("TM error tx commit",new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus())));
    }
    successful=true;
  }
  finally {
    monitor.txCommitted(new XidImpl(tx.getGlobalId(),new byte[0]));
    txThreadMap.remove();
    if (hasAnyLocks) {
      if (successful) {
        tx.finish(true);
      }
 else {
        try {
          tx.finish(false);
        }
 catch (        RuntimeException e) {
          log.error("Failed to commit transaction, and was then subsequently unable to " + "finish the failed tx.",e);
        }
      }
    }
  }
}
