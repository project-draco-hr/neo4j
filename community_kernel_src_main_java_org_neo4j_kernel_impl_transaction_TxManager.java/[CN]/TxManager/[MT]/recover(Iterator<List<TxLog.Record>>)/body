{
  msgLog.logMessage("TM non resolved transactions found in " + txLog.getName(),true);
  try {
    List<NonCompletedTransaction> commitList=new ArrayList<NonCompletedTransaction>();
    List<Xid> rollbackList=new LinkedList<Xid>();
    Map<Resource,XAResource> resourceMap=new HashMap<Resource,XAResource>();
    buildRecoveryInfo(commitList,rollbackList,resourceMap,danglingRecordList);
    Iterator<Resource> resourceItr=resourceMap.keySet().iterator();
    List<Xid> recoveredXidsList=new LinkedList<Xid>();
    while (resourceItr.hasNext()) {
      XAResource xaRes=resourceMap.get(resourceItr.next());
      Xid xids[]=xaRes.recover(XAResource.TMNOFLAGS);
      for (int i=0; i < xids.length; i++) {
        if (XidImpl.isThisTm(xids[i].getGlobalTransactionId())) {
          if (rollbackList.contains(xids[i])) {
            log.fine("Found pre commit " + xids[i] + " rolling back ... ");
            msgLog.logMessage("TM: Found pre commit " + xids[i] + " rolling back ... ",true);
            rollbackList.remove(xids[i]);
            xaRes.rollback(xids[i]);
          }
 else {
            recoveredXidsList.add(xids[i]);
          }
        }
 else {
          log.warning("Unknown xid: " + xids[i]);
        }
      }
    }
    Collections.sort(commitList,new Comparator<NonCompletedTransaction>(){
      public int compare(      NonCompletedTransaction r1,      NonCompletedTransaction r2){
        return r1.getSequenceNumber() - r2.getSequenceNumber();
      }
    }
);
    Iterator<NonCompletedTransaction> commitItr=commitList.iterator();
    while (commitItr.hasNext()) {
      NonCompletedTransaction nct=commitItr.next();
      int seq=nct.getSequenceNumber();
      Xid xids[]=nct.getXids();
      log.fine("Marked as commit tx-seq[" + seq + "] branch length: "+ xids.length);
      for (      Xid xid : xids) {
        if (!recoveredXidsList.contains(xid)) {
          log.fine("Tx-seq[" + seq + "]["+ xid+ "] not found in recovered xid list, "+ "assuming already committed");
          continue;
        }
        recoveredXidsList.remove(xid);
        Resource resource=new Resource(xid.getBranchQualifier());
        if (!resourceMap.containsKey(resource)) {
          throw new TransactionFailureException("Couldn't find XAResource for " + xid);
        }
        log.fine("Commiting tx seq[" + seq + "]["+ xid+ "] ... ");
        msgLog.logMessage("TM: Committing tx " + xid,true);
        resourceMap.get(resource).commit(xid,false);
      }
    }
    Iterator<Xid> rollbackItr=recoveredXidsList.iterator();
    while (rollbackItr.hasNext()) {
      Xid xid=rollbackItr.next();
      Resource resource=new Resource(xid.getBranchQualifier());
      if (!resourceMap.containsKey(resource)) {
        throw new TransactionFailureException("Couldn't find XAResource for " + xid);
      }
      log.fine("Rollback " + xid + " ... ");
      msgLog.logMessage("TM: no match found for " + xid + " removing",true);
      resourceMap.get(resource).rollback(xid);
    }
    if (rollbackList.size() > 0) {
      log.fine("TxLog contained unresolved " + "xids that needed rollback. They couldn't be matched to " + "any of the XAResources recover list. "+ "Assuming " + rollbackList.size() + " transactions already rolled back.");
      msgLog.logMessage("TM: no match found for in total " + rollbackList.size() + " transaction that should have been rolled back",true);
    }
    for (    XAResource participant : MapUtil.reverse(resourceMap).keySet()) {
      xaResourceToDataSource(participant).rotateLogicalLog();
    }
  }
 catch (  IOException e) {
    throw new TransactionFailureException("Recovery failed.",e);
  }
catch (  XAException e) {
    throw new TransactionFailureException("Recovery failed.",e);
  }
}
