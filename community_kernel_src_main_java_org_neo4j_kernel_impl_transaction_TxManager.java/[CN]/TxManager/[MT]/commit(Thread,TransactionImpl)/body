{
  Throwable commitFailureCause=null;
  int xaErrorCode=-1;
synchronized (this) {
    if (tx.getResourceCount() == 0) {
      tx.setStatus(Status.STATUS_COMMITTED);
    }
 else {
      try {
        tx.doCommit();
      }
 catch (      CommitNotificationFailedException e) {
        log.warn("Commit notification failed: " + e);
      }
catch (      XAException e) {
switch (e.errorCode) {
case XAException.XA_RBINTEGRITY:
case XAException.XA_HEURCOM:
          xaErrorCode=e.errorCode;
        commitFailureCause=e;
      log.error("Commit failed, status=" + getTxStatusAsString(tx.getStatus()) + ", errorCode="+ xaErrorCode,e);
    break;
default :
  setTmNotOk(e);
throw logAndReturn("TM error tx commit",new TransactionFailureException("commit threw exception",e));
}
}
catch (Throwable t) {
setTmNotOk(t);
throw logAndReturn("Commit failed for " + tx,new TransactionFailureException("commit threw exception but status is committed?",t));
}
}
if (tx.getStatus() != Status.STATUS_COMMITTED) {
try {
tx.doRollback();
}
 catch (Throwable e) {
setTmNotOk(e);
String commitError=commitFailureCause != null ? "error in commit: " + commitFailureCause : "error code in commit: " + xaErrorCode;
String rollbackErrorCode="Unknown error code";
if (e instanceof XAException) {
rollbackErrorCode=Integer.toString(((XAException)e).errorCode);
}
throw logAndReturn("Unable to rollback transaction " + tx + ". "+ "Some resources may be commited others not. "+ "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->",Exceptions.withCause(new HeuristicMixedException("Unable to rollback " + tx + " ---> "+ commitError+ " ---> error code for rollback: "+ rollbackErrorCode),e));
}
tx.doAfterCompletion();
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
setTmNotOk(e);
throw logAndReturn("Error writing transaction log for " + tx,Exceptions.withCause(new SystemException("TM encountered a problem, while committing transaction  " + tx + ", error writing transaction log"),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
if (commitFailureCause == null) {
throw logAndReturn("TM error tx commit",new HeuristicRollbackException("Failed to commit, transaction  " + tx + " rolled back ---> "+ "error code was: "+ xaErrorCode));
}
 else {
throw logAndReturn("TM error tx commit",Exceptions.withCause(new HeuristicRollbackException("Failed to commit transaction " + tx + ", transaction rolled back ---> "+ commitFailureCause),commitFailureCause));
}
}
}
tx.doAfterCompletion();
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
setTmNotOk(e);
throw logAndReturn("Error writing transaction log for " + tx,Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log for " + tx),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
}
