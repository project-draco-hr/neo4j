{
  if (!tmOk) {
    throw new SystemException("TM has encountered some problem, " + "please perform neccesary action (tx recovery/restart)");
  }
  Thread thread=Thread.currentThread();
  TransactionImpl tx=txThreadMap.get(thread);
  if (tx == null) {
    throw new IllegalStateException("Not in transaction");
  }
  boolean hasAnyLocks=false;
  try {
    hasAnyLocks=finishHook.hasAnyLocks(tx);
    if (tx.getStatus() == Status.STATUS_ACTIVE || tx.getStatus() == Status.STATUS_MARKED_ROLLBACK || tx.getStatus() == Status.STATUS_PREPARING) {
      tx.setStatus(Status.STATUS_MARKED_ROLLBACK);
      tx.doBeforeCompletion();
      try {
        rolledBackTxCount.incrementAndGet();
        tx.doRollback();
      }
 catch (      XAException e) {
        log.log(Level.SEVERE,"Unable to rollback marked or active transaction. " + "Some resources may be commited others not. " + "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->",e);
        setTmNotOk();
        throw Exceptions.withCause(new SystemException("Unable to rollback " + " ---> error code for rollback: " + e.errorCode),e);
      }
      tx.doAfterCompletion();
      txThreadMap.remove(thread);
      try {
        if (tx.isGlobalStartRecordWritten()) {
          getTxLog().txDone(tx.getGlobalId());
        }
      }
 catch (      IOException e) {
        log.log(Level.SEVERE,"Error writing transaction log",e);
        setTmNotOk();
        throw Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log"),e);
      }
      tx.setStatus(Status.STATUS_NO_TRANSACTION);
    }
 else {
      throw new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus()));
    }
  }
  finally {
    if (hasAnyLocks) {
      finishHook.finishTransaction(tx.getEventIdentifier());
    }
  }
}
