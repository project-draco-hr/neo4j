{
  TransactionImpl tx=txThreadMap.get();
  if (tx == null) {
    throw logAndReturn("TM error tx commit",new IllegalStateException("Not in transaction"));
  }
  try {
    assertTmOk("tx rollback");
    if (tx.getStatus() == Status.STATUS_ACTIVE || tx.getStatus() == Status.STATUS_MARKED_ROLLBACK || tx.getStatus() == Status.STATUS_PREPARING) {
      tx.setStatus(Status.STATUS_MARKED_ROLLBACK);
      tx.doBeforeCompletion();
      try {
        rolledBackTxCount.incrementAndGet();
        tx.doRollback();
      }
 catch (      XAException e) {
        setTmNotOk(e);
        throw logAndReturn("Unable to rollback marked or active transaction " + tx + ". "+ "Some resources may be commited others not. "+ "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->",Exceptions.withCause(new SystemException("Unable to rollback " + tx + " ---> error code for rollback: "+ e.errorCode),e));
      }
      tx.doAfterCompletion();
      try {
        if (tx.isGlobalStartRecordWritten()) {
          getTxLog().txDone(tx.getGlobalId());
        }
      }
 catch (      IOException e) {
        setTmNotOk(e);
        throw logAndReturn("Error writing transaction log for " + tx,Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log"),e));
      }
      tx.setStatus(Status.STATUS_NO_TRANSACTION);
    }
 else {
      throw new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus()));
    }
  }
  finally {
    tx.doAfterCompletion();
    txThreadMap.remove();
    tx.finish(false);
  }
}
