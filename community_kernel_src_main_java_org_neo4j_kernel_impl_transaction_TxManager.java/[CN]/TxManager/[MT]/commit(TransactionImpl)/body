{
  Throwable commitFailureCause=null;
  int xaErrorCode=-1;
  if (tx.getResourceCount() == 0) {
    tx.setStatus(Status.STATUS_COMMITTED);
  }
 else {
    try {
      tx.doCommit();
    }
 catch (    XAException e) {
switch (e.errorCode) {
case XAException.XA_RBINTEGRITY:
case XAException.XA_RBOTHER:
case XAException.XA_HEURCOM:
        xaErrorCode=e.errorCode;
      commitFailureCause=e;
    log.error("Commit failed, status=" + getTxStatusAsString(tx.getStatus()) + ", errorCode="+ xaErrorCode,e);
  break;
default :
setTmNotOk(e);
throw logAndReturn("TM error tx commit",new TransactionFailureException("commit threw exception",e));
}
}
catch (Throwable t) {
setTmNotOk(t);
throw logAndReturn("Commit failed for " + tx,new TransactionFailureException("commit threw exception but status is committed?",t));
}
}
if (tx.getStatus() != Status.STATUS_COMMITTED) {
try {
tx.doRollback();
}
 catch (Throwable e) {
setTmNotOk(e);
String commitError;
if (commitFailureCause != null) {
commitError="error in commit: " + commitFailureCause;
}
 else {
commitError="error code in commit: " + xaErrorCode;
}
String rollbackErrorCode="Unknown error code";
if (e instanceof XAException) {
rollbackErrorCode=Integer.toString(((XAException)e).errorCode);
}
throw logAndReturn("Unable to rollback transaction " + tx + ". "+ "Some resources may be commited others not. "+ "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->",Exceptions.withCause(new HeuristicMixedException("Unable to rollback " + tx + " ---> "+ commitError+ " ---> error code for rollback: "+ rollbackErrorCode),e));
}
tx.doAfterCompletion();
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
setTmNotOk(e);
throw logAndReturn("Error writing transaction log for " + tx,Exceptions.withCause(new SystemException("TM encountered a problem, while committing transaction  " + tx + ", error writing transaction log"),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
if (commitFailureCause == null) {
throw logAndReturn("TM error tx commit",new HeuristicRollbackException("Failed to commit, transaction  " + tx + " rolled back ---> "+ "error code was: "+ xaErrorCode));
}
 else {
Throwable commitFailureMessage=commitFailureCause;
while (commitFailureMessage.getMessage() == null) commitFailureMessage=commitFailureMessage.getCause();
if (commitFailureMessage == null) {
commitFailureMessage=commitFailureCause;
}
throw logAndReturn("TM error tx commit",Exceptions.withCause(new HeuristicRollbackException("Failed to commit transaction " + tx + ", transaction rolled back ---> "+ commitFailureMessage.getMessage()),commitFailureCause));
}
}
tx.doAfterCompletion();
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
setTmNotOk(e);
throw logAndReturn("Error writing transaction log for " + tx,Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log for " + tx),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
}
