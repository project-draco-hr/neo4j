{
  Throwable commitFailureCause=null;
  int xaErrorCode=-1;
synchronized (this) {
    if (tx.getResourceCount() == 0) {
      tx.setStatus(Status.STATUS_COMMITTED);
    }
 else {
      try {
        tx.doCommit();
      }
 catch (      XAException e) {
switch (e.errorCode) {
case XAException.XA_RBINTEGRITY:
case XAException.XA_HEURCOM:
          xaErrorCode=e.errorCode;
        commitFailureCause=e;
      log.logMessage("Commit failed, status=" + getTxStatusAsString(tx.getStatus()) + ", errorCode="+ xaErrorCode,e);
    break;
default :
  setTmNotOk(e);
throw logAndReturn("TM error tx commit",new TransactionFailureException("commit threw exception",e));
}
}
catch (Throwable t) {
log.logMessage("Commit failed",t);
setTmNotOk(t);
throw logAndReturn("TM error tx commit",new TransactionFailureException("commit threw exception but status is committed?",t));
}
}
if (tx.getStatus() != Status.STATUS_COMMITTED) {
try {
tx.doRollback();
}
 catch (Throwable e) {
log.logMessage("Unable to rollback transaction. " + "Some resources may be commited others not. " + "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->",e);
setTmNotOk(e);
String commitError;
if (commitFailureCause != null) {
commitError="error in commit: " + commitFailureCause;
}
 else {
commitError="error code in commit: " + xaErrorCode;
}
String rollbackErrorCode="Unknown error code";
if (e instanceof XAException) {
rollbackErrorCode=Integer.toString(((XAException)e).errorCode);
}
throw logAndReturn("TM error tx commit",Exceptions.withCause(new HeuristicMixedException("Unable " + "to rollback ---> " + commitError + " ---> error code for rollback: "+ rollbackErrorCode),e));
}
tx.doAfterCompletion();
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
log.logMessage("Error writing transaction log",e);
setTmNotOk(e);
throw logAndReturn("TM error tx commit",Exceptions.withCause(new SystemException("TM encountered " + "a problem, " + " error writing transaction log"),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
if (commitFailureCause == null) {
throw logAndReturn("TM error tx commit",new HeuristicRollbackException("Failed to commit, transaction rolled back ---> " + "error code was: " + xaErrorCode));
}
 else {
throw logAndReturn("TM error tx commit",Exceptions.withCause(new HeuristicRollbackException("Failed to commit, transaction rolled back ---> " + commitFailureCause),commitFailureCause));
}
}
}
tx.doAfterCompletion();
monitor.txCommitted(new XidImpl(tx.getGlobalId(),new byte[0]));
try {
if (tx.isGlobalStartRecordWritten()) {
getTxLog().txDone(tx.getGlobalId());
}
}
 catch (IOException e) {
log.logMessage("Error writing transaction log",e);
setTmNotOk(e);
throw logAndReturn("TM error tx commit",Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log"),e));
}
tx.setStatus(Status.STATUS_NO_TRANSACTION);
}
