{
  Pair<Step<?>,Float> bottleNeck=execution.stepsOrderedBy(Keys.avg_processing_time,false).iterator().next();
  Step<?> bottleNeckStep=bottleNeck.first();
  long doneBatches=batches(bottleNeckStep);
  int usedPermits=0;
  if (bottleNeck.other() > 1.0f && batchesPassedSinceLastChange(bottleNeckStep,doneBatches) >= config.movingAverageSize()) {
    int optimalProcessorIncrement=min(max(1,(int)bottleNeck.other().floatValue() - 1),permits);
    for (int i=0; i < optimalProcessorIncrement; i++) {
      int before=bottleNeckStep.processors(0);
      if (bottleNeckStep.processors(1) > before) {
        lastChangedProcessors.put(bottleNeckStep,doneBatches);
        usedPermits++;
      }
    }
  }
  return usedPermits;
}
