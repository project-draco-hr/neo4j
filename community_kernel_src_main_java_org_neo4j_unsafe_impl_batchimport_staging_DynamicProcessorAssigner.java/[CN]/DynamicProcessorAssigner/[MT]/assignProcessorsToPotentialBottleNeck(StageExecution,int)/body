{
  Pair<Step<?>,Float> bottleNeck=execution.stepsOrderedBy(Keys.avg_processing_time,false).iterator().next();
  Step<?> bottleNeckStep=bottleNeck.first();
  long doneBatches=batches(bottleNeckStep);
  int usedPermits=0;
  if (bottleNeck.other() > 1.0f && batchesPassedSinceLastChange(bottleNeckStep,doneBatches) >= config.movingAverageSize()) {
    int optimalProcessorIncrement=min(max(1,(int)bottleNeck.other().floatValue() - 1),permits);
    int before=bottleNeckStep.processors(0);
    int after=bottleNeckStep.processors(max(optimalProcessorIncrement,permits / 10));
    if (after > before) {
      lastChangedProcessors.put(bottleNeckStep,doneBatches);
      usedPermits-=(after - before);
    }
  }
  return usedPermits;
}
