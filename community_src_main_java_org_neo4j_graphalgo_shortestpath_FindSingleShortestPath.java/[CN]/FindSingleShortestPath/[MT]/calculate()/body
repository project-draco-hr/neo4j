{
  if (doneCalculation) {
    return true;
  }
  if (startNode.equals(endNode)) {
    matchNode=startNode;
    doneCalculation=true;
    return true;
  }
  boolean hasRecalculatedDepth=false;
  initializeDirectionData();
  while (firstDirection.iterator.hasNext() || secondDirection.iterator.hasNext()) {
    if (tryMatch(firstDirection,secondDirection)) {
      return true;
    }
    if (tryMatch(secondDirection,firstDirection)) {
      return true;
    }
    firstDirection.checkNextDepth();
    secondDirection.checkNextDepth();
    if (!hasRecalculatedDepth && firstDirection.currentDepth == 1 && this.maxDepth % 2 == 1) {
      boolean firstHasMore=firstDirection.nodeList.size() > secondDirection.nodeList.size();
      if (firstHasMore == firstDirection.depth > secondDirection.depth) {
        int tempDepth=firstDirection.depth;
        firstDirection.depth=secondDirection.depth;
        secondDirection.depth=tempDepth;
      }
      hasRecalculatedDepth=true;
    }
  }
  doneCalculation=true;
  return false;
}
