{
  String[] INPUT={"These strings need to be longer than 57 bytes, because that is the line wrapping length of BASE64.","This next line is also long. The number of strings in this array is the number of threads to use.","Each thread will get a different string as input to encode, and ensure the result is always the same.","Should the result of an encoding differ even once, the thread will yield a negative overall result.","If any of the threads yields a negative result, the test will fail, since that should not happen.","All threads are allowed to run together for a predetermined amount of time, to try to get contention.","This predetermined time is the minimum runtime of the test, since the timer starts after all threads.","The idea to use the input data as documentation for the test was just a cute thing I came up with.","Since my imagination for coming up with test data is usually poor, I figured I'd do something useful.","Hopefully this isn't just nonsensical drivel, and maybe, just maybe someone might actually read it."};
  long executionTime=SECONDS.toMillis(5);
  final AtomicBoolean running=new AtomicBoolean(true);
  Function<String,Boolean> function=new Function<String,Boolean>(){
    @Override public Boolean apply(    String input){
      String first=ArrayEncoder.encode(new String[]{input});
      do {
        if (!first.equals(ArrayEncoder.encode(new String[]{input}))) {
          return false;
        }
      }
 while (running.get());
      return true;
    }
  }
;
  List<Future<Boolean>> futures=new ArrayList<>();
  for (  String input : INPUT) {
    futures.add(threads.execute(function,input));
  }
  Thread.sleep(executionTime);
  running.set(false);
  for (  Future<Boolean> future : futures) {
    assertTrue("Each attempt at encoding should yield the same result.",future.get());
  }
}
