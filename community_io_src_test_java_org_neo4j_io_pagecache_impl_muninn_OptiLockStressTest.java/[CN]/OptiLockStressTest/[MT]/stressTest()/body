{
  int[][] data=new int[10][10];
  AtomicBoolean stop=new AtomicBoolean();
  AtomicInteger writerId=new AtomicInteger();
abstract class Worker implements Runnable {
    @Override public void run(){
      try {
        doWork();
      }
  finally {
        stop.set(true);
      }
    }
    protected abstract void doWork();
  }
  Worker reader=new Worker(){
    @Override protected void doWork(){
      while (!stop.get()) {
        ThreadLocalRandom rng=ThreadLocalRandom.current();
        int[] record=data[rng.nextInt(data.length)];
        long stamp=lock.tryOptimisticReadLock();
        int value=record[0];
        boolean consistent=true;
        for (        int i : record) {
          consistent&=i == value;
        }
        if (lock.validateReadLock(stamp) && !consistent) {
          throw new AssertionError("inconsistent read");
        }
      }
    }
  }
;
  Worker writer=new Worker(){
    private volatile long unused;
    @Override protected void doWork(){
      int id=writerId.getAndIncrement();
      int counter=1;
      ThreadLocalRandom rng=ThreadLocalRandom.current();
      int smallSpin=rng.nextInt(5,50);
      int bigSpin=rng.nextInt(100,1000);
      while (!stop.get()) {
        lock.writeLock();
        int[] record=data[id];
        for (int i=0; i < record.length; i++) {
          record[i]=counter;
          for (int j=0; j < smallSpin; j++) {
            unused=rng.nextLong();
          }
        }
        lock.unlockWrite();
        for (int j=0; j < bigSpin; j++) {
          unused=rng.nextLong();
        }
      }
    }
  }
;
  Worker exclusive=new Worker(){
    private volatile long unused;
    @Override protected void doWork(){
      ThreadLocalRandom rng=ThreadLocalRandom.current();
      int spin=rng.nextInt(20,2000);
      while (!stop.get()) {
        while (!lock.tryExclusiveLock()) {
        }
        long sumA=0;
        long sumB=0;
        for (        int[] ints : data) {
          for (          int i : ints) {
            sumA+=i;
          }
        }
        for (int i=0; i < spin; i++) {
          unused=rng.nextLong();
        }
        for (        int[] record : data) {
          for (int i=0; i < record.length; i++) {
            sumB+=record[i];
            record[i]=0;
          }
        }
        lock.unlockExclusive();
        if (sumA != sumB) {
          throw new AssertionError("Inconsistent exclusive lock");
        }
      }
    }
  }
;
  List<Future<?>> readers=new ArrayList<>();
  List<Future<?>> writers=new ArrayList<>();
  Future<?> exclusiveFuture=executor.submit(exclusive);
  for (int i=0; i < 20; i++) {
    readers.add(executor.submit(reader));
  }
  for (int i=0; i < data.length; i++) {
    writers.add(executor.submit(writer));
  }
  long deadline=System.currentTimeMillis() + 1000;
  while (!stop.get() && System.currentTimeMillis() < deadline) {
    Thread.sleep(20);
  }
  stop.set(true);
  exclusiveFuture.get();
  for (  Future<?> future : writers) {
    future.get();
  }
  for (  Future<?> future : readers) {
    future.get();
  }
}
