{
  Node node=this.getCurrentNode(session);
  Object[] relationshipTypes=parseRelationshipTypes(parser);
  if (relationshipTypes.length == 0) {
    out.println("No matching relationship types");
    return null;
  }
  StopEvaluator stopEvaluator=parseStopEvaluator(parser);
  ReturnableEvaluator returnableEvaluator=parseReturnableEvaluator(parser);
  Order order=parseOrder(parser);
  String nodeKeyFilter=parser.options().get("f");
  String nodeValueFilter=parser.options().get("g");
  boolean caseSensitiveFilters=parser.options().containsKey("s");
  boolean exactFilterMatch=parser.options().containsKey("x");
  Pattern nodeKeyPattern=newPattern(nodeKeyFilter,caseSensitiveFilters);
  Pattern nodeValuePattern=newPattern(nodeValueFilter,caseSensitiveFilters);
  String commandToRun=parser.options().get("c");
  String[] commandsToRun=commandToRun != null ? commandToRun.split(Pattern.quote("&&")) : new String[0];
  for (  Node traversedNode : node.traverse(order,stopEvaluator,returnableEvaluator,relationshipTypes)) {
    boolean hit=false;
    if (nodeKeyFilter == null && nodeValueFilter == null) {
      hit=true;
    }
 else {
      for (      String key : traversedNode.getPropertyKeys()) {
        hit=matches(nodeKeyPattern,key,caseSensitiveFilters,exactFilterMatch);
        Object value=traversedNode.getProperty(key);
        hit=hit && matches(nodeValuePattern,value.toString(),caseSensitiveFilters,exactFilterMatch);
        if (hit) {
          break;
        }
      }
    }
    if (hit) {
      out.println(getDisplayNameForNode(traversedNode));
      Map<String,Object> data=new HashMap<String,Object>();
      data.put("n",traversedNode.getId());
      for (      String command : commandsToRun) {
        String line=templateString(command,"\\$",data);
        getServer().interpretLine(line,session,out);
        out.println();
      }
    }
  }
  return null;
}
