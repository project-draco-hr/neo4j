{
  VerifyingConsumer consumer=new VerifyingConsumer(30);
  final AtomicLong txOpened=new AtomicLong();
  final AtomicLong txClosed=new AtomicLong();
  Supplier<Long> chunkThreshold=new Supplier<Long>(){
    @Override public Long get(){
      return txOpened.get();
    }
  }
;
  Predicate<Long> safeThreshold=new Predicate<Long>(){
    @Override public boolean test(    Long value){
      return txClosed.get() >= value;
    }
  }
;
  DelayedBuffer<Long> buffer=new DelayedBuffer<>(chunkThreshold,safeThreshold,100,consumer);
  txOpened.incrementAndGet();
  buffer.offer(1);
  txOpened.incrementAndGet();
  buffer.offer(4);
  buffer.maintenance();
  assertEquals(0,consumer.chunksAccepted());
  buffer.offer(5);
  txOpened.incrementAndGet();
  txOpened.incrementAndGet();
  buffer.offer(7);
  buffer.maintenance();
  assertEquals(0,consumer.chunksAccepted());
  txOpened.incrementAndGet();
  buffer.offer(2);
  buffer.offer(8);
  buffer.maintenance();
  assertEquals(0,consumer.chunksAccepted());
  buffer.offer(6);
  txOpened.incrementAndGet();
  buffer.offer(9);
  buffer.offer(3);
  txOpened.incrementAndGet();
  buffer.offer(11);
  buffer.offer(12);
  txClosed.set(4);
  buffer.maintenance();
  consumer.assertHaveOnlySeen(1,4,5,7);
  buffer.offer(10);
  buffer.offer(13);
  txClosed.set(6);
  buffer.maintenance();
  consumer.assertHaveOnlySeen(1,2,4,5,7,8);
  buffer.offer(14);
  txClosed.set(7);
  buffer.maintenance();
  consumer.assertHaveOnlySeen(1,2,3,4,5,6,7,8,9,10,11,12,13,14);
}
