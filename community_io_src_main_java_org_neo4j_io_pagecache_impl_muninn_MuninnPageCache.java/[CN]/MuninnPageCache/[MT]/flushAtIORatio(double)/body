{
  Thread thread=Thread.currentThread();
  long sleepPaymentThreshold=TimeUnit.MILLISECONDS.toNanos(backgroundFlushSleepDebtThreshold);
  boolean seenDirtyPages=false;
  boolean flushedPages=false;
  double sleepFactor=(1 - ratio) / ratio;
  try (MajorFlushEvent event=tracer.beginCacheFlush()){
    for (    MuninnPage page : pages) {
      if (page == null || thread.isInterrupted()) {
        thread.interrupt();
        return 0;
      }
      boolean thisPageIsDirty=false;
      if (page.isWriteLocked() || !(thisPageIsDirty=page.isDirty()) || !page.decrementUsage()) {
        seenDirtyPages|=thisPageIsDirty;
        continue;
      }
      long stamp=page.tryReadLock();
      if (stamp != 0) {
        try {
          if (!page.isDirty()) {
            continue;
          }
          long startNanos=System.nanoTime();
          page.flush(event.flushEventOpportunity());
          long elapsedNanos=System.nanoTime() - startNanos;
          sleepDebtNanos+=elapsedNanos * sleepFactor;
          flushedPages=true;
        }
 catch (        Throwable ignore) {
        }
 finally {
          page.unlockRead(stamp);
        }
      }
      if (sleepDebtNanos > sleepPaymentThreshold) {
        LockSupport.parkNanos(sleepDebtNanos);
        sleepDebtNanos=0;
      }
      checkBackgroundFlushPause();
    }
  }
   return seenDirtyPages ? flushedPages ? backgroundFlushMediumBreak : backgroundFlushBusyBreak : backgroundFlushLongBreak;
}
