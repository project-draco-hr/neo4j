{
  Thread thread=Thread.currentThread();
  long sleepDebtNanos=0;
  long sleepPaymentThreshold=TimeUnit.MILLISECONDS.toNanos(10);
  boolean flushedAnything=false;
  try (MajorFlushEvent event=tracer.beginCacheFlush()){
    for (    MuninnPage page : pages) {
      if (page == null || thread.isInterrupted()) {
        thread.interrupt();
        return true;
      }
      long stamp=page.tryReadLock();
      if (stamp != 0) {
        try {
          if (!page.isDirty()) {
            continue;
          }
          long startNanos=System.nanoTime();
          page.flush(event.flushEventOpportunity());
          long elapsedNanos=System.nanoTime() - startNanos;
          sleepDebtNanos+=(elapsedNanos / ratio) - elapsedNanos;
          flushedAnything=true;
        }
 catch (        Throwable ignore) {
        }
 finally {
          page.unlockRead(stamp);
        }
      }
      if (sleepDebtNanos > sleepPaymentThreshold) {
        LockSupport.parkNanos(sleepDebtNanos);
        sleepDebtNanos=0;
      }
    }
  }
   return flushedAnything;
}
