{
  FreePageWaiter waiters=freePageWaiters.getAndSet(null);
  waiters=reverse(waiters);
  Thread currentThread=Thread.currentThread();
  while ((pageCountToEvict > 0 || waiters != null) && !currentThread.isInterrupted()) {
    if (clockArm == pages.length) {
      clockArm=0;
    }
    MuninnPage page=pages[clockArm];
    if (page == null) {
      currentThread.interrupt();
      return 0;
    }
    if (page.isLoaded() && page.decrementUsage()) {
      long stamp=page.tryWriteLock();
      if (stamp != 0) {
        PageSwapper swapper=page.getSwapper();
        long filePageId=page.getFilePageId();
        boolean pageEvicted=false;
        pageCountToEvict--;
        try {
          page.evict();
          evictorException=null;
          pageEvicted=true;
        }
 catch (        IOException ioException) {
          evictorException=ioException;
        }
catch (        OutOfMemoryError ignore) {
          evictorException=oomException;
        }
catch (        Throwable throwable) {
          evictorException=new IOException("Eviction thread encountered a problem",throwable);
        }
 finally {
          page.unlockWrite(stamp);
        }
        if (pageEvicted) {
          if (swapper != null) {
            swapper.evicted(filePageId);
            monitor.evicted(filePageId,swapper);
          }
          if (waiters != null) {
            waiters.unpark(page);
            waiters=waiters.next;
          }
 else {
            MuninnPage next;
            do {
              next=freelist.get();
              page.nextFree=next;
            }
 while (!freelist.compareAndSet(next,page));
          }
        }
 else         if (waiters != null && evictorException != null) {
          waiters.unparkException(evictorException);
          waiters=waiters.next;
        }
      }
    }
    clockArm++;
  }
  while (waiters != null) {
    waiters.unparkInterrupt();
    waiters=waiters.next;
  }
  return clockArm;
}
