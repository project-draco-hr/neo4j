{
  final int pageCount=100;
  int writerThreads=8;
  ExecutorService executor=Executors.newFixedThreadPool(writerThreads);
  final CountDownLatch startLatch=new CountDownLatch(writerThreads);
  List<Future<?>> writers=new ArrayList<>();
  final PageCache cache=getPageCache(fs,maxPages,pageCachePageSize,PageCacheMonitor.NULL);
  PagedFile pagedFile=cache.map(file,filePageSize);
  try (PageCursor cursor=pagedFile.io(0,PF_EXCLUSIVE_LOCK)){
    for (int i=0; i < pageCount; i++) {
      assertTrue(cursor.next());
    }
  }
   Runnable writer=new Runnable(){
    @Override public void run(){
      try {
        PagedFile pagedFile=cache.map(file,filePageSize);
        int pageRangeMin=pageCount / 2;
        int pageRangeMax=pageRangeMin + 5;
        ThreadLocalRandom rng=ThreadLocalRandom.current();
        int[] offsets=new int[filePageSize];
        for (int i=0; i < offsets.length; i++) {
          offsets[i]=i;
        }
        startLatch.countDown();
        while (!Thread.interrupted()) {
          byte value=(byte)rng.nextInt();
          int pageId=rng.nextInt(pageRangeMin,pageRangeMax);
          for (int i=0; i < offsets.length; i++) {
            int j=rng.nextInt(i,offsets.length);
            int s=offsets[i];
            offsets[i]=offsets[j];
            offsets[j]=s;
          }
          try (PageCursor cursor=pagedFile.io(pageId,PF_EXCLUSIVE_LOCK)){
            if (cursor.next()) {
              do {
                for (int i=0; i < offsets.length; i++) {
                  cursor.setOffset(offsets[i]);
                  cursor.putByte(value);
                }
              }
 while (cursor.retry());
            }
          }
         }
        cache.unmap(file);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
;
  for (int i=0; i < writerThreads; i++) {
    writers.add(executor.submit(writer));
  }
  startLatch.await();
  for (int i=0; i < 2000; i++) {
    int countedConsistentPageReads=0;
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_LOCK)){
      while (cursor.next()) {
        boolean consistent=true;
        do {
          byte first=cursor.getByte();
          for (int j=1; j < filePageSize; j++) {
            consistent=consistent && cursor.getByte() == first;
          }
        }
 while (cursor.retry());
        assertTrue(consistent);
        countedConsistentPageReads++;
      }
    }
     assertThat(countedConsistentPageReads,is(pageCount));
  }
  executor.shutdown();
  for (  Future<?> future : writers) {
    if (future.isDone()) {
      future.get();
    }
 else {
      future.cancel(true);
    }
  }
}
