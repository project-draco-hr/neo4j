{
  int iterations=1000;
  List<WeakReference<PageCache>> refs=new LinkedList<>();
  final Queue<Throwable> caughtExceptions=new ConcurrentLinkedQueue<>();
  final Thread.UncaughtExceptionHandler exceptionHandler=new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      e.printStackTrace();
      caughtExceptions.offer(e);
    }
  }
;
  Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler=Thread.getDefaultUncaughtExceptionHandler();
  Thread.setDefaultUncaughtExceptionHandler(exceptionHandler);
  try {
    generateFileWithRecords(file("a"),recordCount,recordSize);
    int filePagesInTotal=recordCount / recordsPerFilePage;
    for (int i=0; i < iterations; i++) {
      createAndDirtyAndShutDownPageCache(refs,filePagesInTotal);
      assertTrue(caughtExceptions.isEmpty());
    }
  }
  finally {
    Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
  }
  int maxChecks=200;
  LinkedList<SoftReference<byte[]>> heapPollution=new LinkedList<>();
  boolean passed;
  do {
    passed=causeGcAndCheckReferences(refs,heapPollution);
  }
 while (!passed && maxChecks-- > 0);
  if (!passed) {
    List<PageCache> nonNullPageCaches=new LinkedList<>();
    for (    WeakReference<PageCache> ref : refs) {
      PageCache pageCache=ref.get();
      if (pageCache != null) {
        nonNullPageCaches.add(pageCache);
      }
    }
    if (!nonNullPageCaches.isEmpty()) {
      fail("PageCaches should not be held live after close: " + nonNullPageCaches);
    }
  }
}
