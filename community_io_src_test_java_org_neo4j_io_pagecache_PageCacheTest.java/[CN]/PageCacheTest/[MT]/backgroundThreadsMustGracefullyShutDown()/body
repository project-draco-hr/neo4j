{
  int iterations=1000;
  List<WeakReference<PageCache>> refs=new LinkedList<>();
  final Queue<Throwable> caughtExceptions=new ConcurrentLinkedQueue<>();
  final Thread.UncaughtExceptionHandler exceptionHandler=new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      e.printStackTrace();
      caughtExceptions.offer(e);
    }
  }
;
  Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler=Thread.getDefaultUncaughtExceptionHandler();
  Thread.setDefaultUncaughtExceptionHandler(exceptionHandler);
  try {
    generateFileWithRecords(file("a"),recordCount,recordSize);
    int filePagesInTotal=recordCount / recordsPerFilePage;
    for (int i=0; i < iterations; i++) {
      PageCache cache=createPageCache(fs,maxPages,pageCachePageSize,PageCacheTracer.NULL);
      PagedFile pagedFile=cache.map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_LOCK)){
        for (int j=0; j < filePagesInTotal; j++) {
          assertTrue(cursor.next());
        }
      }
       pagedFile.close();
      cache.close();
      refs.add(new WeakReference<>(cache));
      assertTrue(caughtExceptions.isEmpty());
    }
  }
  finally {
    Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
  }
  int maxChecks=100;
  boolean passed;
  do {
    System.gc();
    Thread.sleep(100);
    passed=true;
    for (    WeakReference<PageCache> ref : refs) {
      if (ref.get() != null) {
        passed=false;
      }
    }
  }
 while (!passed && maxChecks-- > 0);
  if (!passed) {
    List<PageCache> nonNullPageCaches=new LinkedList<>();
    for (    WeakReference<PageCache> ref : refs) {
      PageCache pageCache=ref.get();
      if (pageCache != null) {
        nonNullPageCaches.add(pageCache);
      }
    }
    if (!nonNullPageCaches.isEmpty()) {
      fail("PageCaches should not be held live after close: " + nonNullPageCaches);
    }
  }
}
