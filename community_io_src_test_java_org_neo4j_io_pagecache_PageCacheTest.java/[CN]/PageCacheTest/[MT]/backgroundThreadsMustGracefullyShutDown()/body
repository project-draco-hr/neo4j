{
  int iterations=1000;
  List<WeakReference<PageCache>> refs=new LinkedList<>();
  final Queue<Throwable> caughtExceptions=new ConcurrentLinkedQueue<>();
  final Thread.UncaughtExceptionHandler exceptionHandler=new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      e.printStackTrace();
      caughtExceptions.offer(e);
    }
  }
;
  Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler=Thread.getDefaultUncaughtExceptionHandler();
  Thread.setDefaultUncaughtExceptionHandler(exceptionHandler);
  try {
    generateFileWithRecords(file("a"),recordCount,recordSize);
    int filePagesInTotal=recordCount / recordsPerFilePage;
    for (int i=0; i < iterations; i++) {
      createAndDirtyAndShutDownPageCache(refs,filePagesInTotal);
      assertTrue(caughtExceptions.isEmpty());
    }
  }
  finally {
    Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
  }
  int maxChecks=200;
  byte[] randomHeapPollution;
  boolean passed;
  do {
    System.gc();
    Thread.sleep(100);
    passed=true;
    randomHeapPollution=new byte[(int)ByteUnit.mebiBytes(2)];
    for (    WeakReference<PageCache> ref : refs) {
      if (ref.get() != null) {
        passed=false;
      }
    }
  }
 while (!passed && maxChecks-- > 0);
  if (!passed) {
    List<PageCache> nonNullPageCaches=new LinkedList<>();
    for (    WeakReference<PageCache> ref : refs) {
      PageCache pageCache=ref.get();
      if (pageCache != null) {
        nonNullPageCaches.add(pageCache);
      }
    }
    if (!nonNullPageCaches.isEmpty()) {
      fail("PageCaches should not be held live after close: " + nonNullPageCaches);
    }
  }
}
