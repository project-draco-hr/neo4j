{
  final byte a='a';
  final byte b='b';
  final File fileA=new File("a");
  final File fileB=new File("b");
  fs.create(fileA).close();
  fs.create(fileB).close();
  getPageCache(fs,maxPages,pageCachePageSize,PageCacheMonitor.NULL);
  final PagedFile pagedFileA=pageCache.map(fileA,filePageSize);
  final PagedFile pagedFileB=pageCache.map(fileB,filePageSize);
  try (PageCursor cursor=pagedFileA.io(0,PF_EXCLUSIVE_LOCK)){
    for (int i=0; i < maxPages; i++) {
      assertTrue(cursor.next());
      for (int j=0; j < filePageSize; j++) {
        cursor.putByte(a);
      }
    }
  }
   Runnable fillPagedFileB=new Runnable(){
    @Override public void run(){
      try (PageCursor cursor=pagedFileB.io(0,PF_EXCLUSIVE_LOCK)){
        for (int i=0; i < maxPages * 30; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSize; j++) {
            cursor.putByte(b);
          }
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
;
  try (PageCursor cursor=pagedFileA.io(0,PF_SHARED_LOCK)){
    assertTrue(cursor.next(0));
    assertTrue(cursor.next());
    assertTrue(cursor.next(0));
    for (int i=0; i < filePageSize; i++) {
      assertThat(cursor.getByte(),is(a));
    }
    fork(fillPagedFileB).join();
    if (cursor.retry()) {
      int expected=a * filePageSize;
      int actual;
      do {
        actual=0;
        for (int i=0; i < filePageSize; i++) {
          actual+=cursor.getByte();
        }
      }
 while (cursor.retry());
      assertThat(actual,is(expected));
    }
  }
   pageCache.unmap(fileA);
  pageCache.unmap(fileB);
}
