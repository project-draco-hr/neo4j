{
  final NodeStore nodeStore=stores.createNodeStore();
  final RelationshipStore relationshipStore=stores.createRelationshipStore();
  final RelationshipGroupStore relationshipGroupStore=stores.createRelationshipGroupStore();
  final LegacyNodeStoreReader nodeReader=legacyStore.getNodeStoreReader();
  final LegacyRelationshipStoreReader relReader=legacyStore.getRelStoreReader();
  nodeStore.setHighId(nodeReader.getMaxId());
  relationshipStore.setHighId(relReader.getMaxId());
  final ArrayBlockingQueue<RelChainBuilder> chainsToWrite=new ArrayBlockingQueue<>(1024);
  final AtomicReference<Throwable> writerException=new AtomicReference<>();
  Thread writerThread=new RelationshipWriter(chainsToWrite,relationshipGroupStore.getDenseNodeThreshold(),nodeStore,relationshipStore,relationshipGroupStore,nodeReader,writerException);
  writerThread.start();
  try {
    final int maxSimultaneousNodes=(int)(120 * (Runtime.getRuntime().totalMemory() / (1024 * 1024)));
    final AtomicBoolean morePassesRequired=new AtomicBoolean(false);
    final AtomicLong firstRelationshipRequiringANewPass=new AtomicLong(0l);
    final PrimitiveLongObjectMap<RelChainBuilder> relChains=Primitive.longObjectMap();
    long numberOfPasses=1;
    do {
      percentComplete=0;
      if (morePassesRequired.get()) {
        if (numberOfPasses == 1) {
          System.out.println("\nNote: Was not able to do single-pass upgrade due to highly " + "dispersed relationships across the store. Will need to perform multi-pass upgrade.\n" + "Note: Dotted line shows progress for each pass, the X in the dotted line shows total progress.\n");
        }
 else {
          System.out.println(" [MultiPass Upgrade] Finished pass #" + (numberOfPasses - 1));
        }
        numberOfPasses++;
      }
      relReader.accept(firstRelationshipRequiringANewPass.get(),new Visitor<ReusableRelationship,RuntimeException>(){
        private final boolean isMultiPass=morePassesRequired.getAndSet(false);
        @Override public boolean visit(        ReusableRelationship rel){
          reportProgress(rel.id());
          if (rel.inUse()) {
            if (appendToRelChain(rel.getFirstNode(),rel.getFirstPrevRel(),rel.getFirstNextRel(),rel)) {
              return true;
            }
            if (appendToRelChain(rel.getSecondNode(),rel.getSecondPrevRel(),rel.getSecondNextRel(),rel)) {
              return true;
            }
          }
          return false;
        }
        private boolean appendToRelChain(        long nodeId,        long prevRel,        long nextRel,        ReusableRelationship rel){
          RelChainBuilder chain=relChains.get(nodeId);
          if (chain == null) {
            if (morePassesRequired.get() || (isMultiPass && nodeStore.inUse(nodeId))) {
              return false;
            }
            if (relChains.size() >= maxSimultaneousNodes) {
              morePassesRequired.set(true);
              firstRelationshipRequiringANewPass.set(rel.id());
              System.out.print("X");
              return false;
            }
            chain=new RelChainBuilder(nodeId);
            relChains.put(nodeId,chain);
          }
          chain.append(rel.createRecord(),prevRel,nextRel);
          if (chain.isComplete()) {
            assertNoWriterException(writerException);
            try {
              RelChainBuilder remove=relChains.remove(nodeId);
              chainsToWrite.put(remove);
            }
 catch (            InterruptedException e) {
              Thread.interrupted();
              throw new RuntimeException("Interrupted while reading relationships.",e);
            }
          }
          return false;
        }
      }
);
    }
 while (morePassesRequired.get());
    try {
      chainsToWrite.put(new RelChainBuilder(-1));
      writerThread.join();
      assertNoWriterException(writerException);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Interrupted.",e);
    }
    nodeReader.accept(new LegacyNodeStoreReader.Visitor(){
      @Override public void visit(      NodeRecord record){
        if (record.inUse() && record.getNextRel() == Record.NO_NEXT_RELATIONSHIP.intValue()) {
          nodeStore.forceUpdateRecord(record);
        }
      }
    }
);
  }
  finally {
    nodeReader.close();
    relReader.close();
  }
}
