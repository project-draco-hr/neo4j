{
  resetFileSystem();
  instantiateNeoStore(10);
  final long nodeId=neoStore.getNodeStore().nextId();
  TransactionRecordState writeTransaction=newWriteTransaction().first();
  writeTransaction.nodeCreate(nodeId);
  int typeA=(int)neoStore.getRelationshipTypeTokenStore().nextId();
  writeTransaction.createRelationshipTypeToken("A",typeA);
  createRelationships(writeTransaction,nodeId,typeA,INCOMING,20);
  try (LockGroup locks=new LockGroup()){
    commitProcess().commit(transactionRepresentationOf(writeTransaction),locks);
  }
   writeTransaction=newWriteTransaction().first();
  int typeB=1;
  writeTransaction.createRelationshipTypeToken("B",typeB);
  long[] relationshipsOfTypeB=createRelationships(writeTransaction,nodeId,typeB,OUTGOING,5);
  for (  long relationshipToDelete : relationshipsOfTypeB) {
    deleteRelationship(writeTransaction,relationshipToDelete);
  }
  PhysicalTransactionRepresentation tx=transactionRepresentationOf(writeTransaction);
  try (LockGroup locks=new LockGroup()){
    commitProcess().commit(tx,locks);
  }
   final AtomicBoolean foundRelationshipGroupInUse=new AtomicBoolean();
  tx.accept(new NeoCommandHandler.HandlerVisitor(new NeoCommandHandler.Adapter(){
    @Override public boolean visitRelationshipGroupCommand(    RelationshipGroupCommand command) throws IOException {
      if (command.getRecord().inUse()) {
        if (!foundRelationshipGroupInUse.get()) {
          foundRelationshipGroupInUse.set(true);
        }
 else {
          fail();
        }
      }
      return true;
    }
  }
));
  assertTrue("Did not create relationship group command",foundRelationshipGroupInUse.get());
}
