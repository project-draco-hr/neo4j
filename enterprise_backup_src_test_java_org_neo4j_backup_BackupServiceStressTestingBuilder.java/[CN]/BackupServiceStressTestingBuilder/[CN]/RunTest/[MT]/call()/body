{
  final GraphDatabaseAPI db=(GraphDatabaseAPI)new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(storeDir.getAbsolutePath()).setConfig(OnlineBackupSettings.online_backup_server,backupHostname + ":" + backupPort).setConfig(GraphDatabaseSettings.keep_logical_logs,"true").newGraphDatabase();
  try {
    createIndex(db);
    createSomeData(db);
    rotateLogAndCheckPoint(db);
    final AtomicBoolean keepGoing=new AtomicBoolean(true);
    Dependencies dependencies=new Dependencies(db.getDependencyResolver());
    dependencies.satisfyDependencies(new Config(),NullLogProvider.getInstance(),new Monitors());
    OnlineBackupKernelExtension backup;
    try {
      backup=(OnlineBackupKernelExtension)new OnlineBackupExtensionFactory().newKernelExtension(DependenciesProxy.dependencies(dependencies,OnlineBackupExtensionFactory.Dependencies.class));
      backup.init();
      backup.start();
    }
 catch (    Throwable t) {
      throw new RuntimeException(t);
    }
    ExecutorService executor=Executors.newFixedThreadPool(2);
    executor.execute(new Runnable(){
      @Override public void run(){
        while (keepGoing.get() && until.getAsBoolean()) {
          createSomeData(db);
        }
      }
    }
);
    final AtomicInteger inconsistentDbs=new AtomicInteger(0);
    executor.execute(new Runnable(){
      private final BackupService backupService=new BackupService(fileSystem,NullLogProvider.getInstance(),new Monitors());
      @Override public void run(){
        while (keepGoing.get() && until.getAsBoolean()) {
          cleanup(backupDir);
          BackupService.BackupOutcome backupOutcome=backupService.doFullBackup(backupHostname,backupPort,backupDir.getAbsoluteFile(),ConsistencyCheck.DEFAULT,new Config(),BackupClient.BIG_READ_TIMEOUT,false);
          if (!backupOutcome.isConsistent()) {
            keepGoing.set(false);
            int num=inconsistentDbs.incrementAndGet();
            File dir=new File(brokenDir,"" + num);
            fileSystem.mkdir(dir);
            copyRecursively(backupDir,dir);
          }
        }
      }
      private void copyRecursively(      File from,      File to){
        try {
          fileSystem.copyRecursively(from,to);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      private void cleanup(      File dir){
        try {
          fileSystem.deleteRecursively(dir);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    while (keepGoing.get() && until.getAsBoolean()) {
      Thread.sleep(500);
    }
    executor.shutdown();
    if (!executor.awaitTermination(30,TimeUnit.SECONDS)) {
      DebugUtil.dumpThreads(System.err);
      fail("Didn't manage to shut down the workers correctly, dumped threads for forensic purposes");
    }
    try {
      backup.stop();
      backup.shutdown();
    }
 catch (    Throwable t) {
      throw new RuntimeException(t);
    }
    return inconsistentDbs.get();
  }
  finally {
    db.shutdown();
  }
}
