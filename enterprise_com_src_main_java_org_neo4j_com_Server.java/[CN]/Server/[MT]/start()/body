{
  this.oldChannelThresholdMillis=config.getOldChannelThreshold();
  chunkSize=config.getChunkSize();
  assertChunkSizeIsWithinFrameSize(chunkSize,frameLength);
  String className=getClass().getSimpleName();
  targetCallExecutor=newCachedThreadPool(named(className + ":" + config.getServerAddress().getPort()));
  unfinishedTransactionExecutor=newScheduledThreadPool(2,named("Unfinished transactions"));
  silentChannelExecutor=newSingleThreadScheduledExecutor(named("Silent channel reaper"));
  silentChannelExecutor.scheduleWithFixedDelay(silentChannelFinisher(),5,5,TimeUnit.SECONDS);
  ExecutorService bossExecutor=newCachedThreadPool(daemon("Boss-" + className));
  ExecutorService workerExecutor=newCachedThreadPool(daemon("Worker-" + className));
  bootstrap=new ServerBootstrap(new NioServerSocketChannelFactory(bossExecutor,workerExecutor,config.getMaxConcurrentTransactions()));
  bootstrap.setPipelineFactory(this);
  Channel channel=null;
  socketAddress=null;
  int[] ports=config.getServerAddress().getPorts();
  ChannelException ex=null;
  for (int port=ports[0]; port <= ports[1]; port++) {
    if (config.getServerAddress().getHost() == null || config.getServerAddress().getHost().equals(INADDR_ANY)) {
      socketAddress=new InetSocketAddress(port);
    }
 else {
      socketAddress=new InetSocketAddress(config.getServerAddress().getHost(),port);
    }
    try {
      channel=bootstrap.bind(socketAddress);
      ex=null;
      break;
    }
 catch (    ChannelException e) {
      ex=e;
    }
  }
  if (ex != null) {
    msgLog.error("Failed to bind server to " + socketAddress,ex);
    bootstrap.releaseExternalResources();
    targetCallExecutor.shutdownNow();
    unfinishedTransactionExecutor.shutdownNow();
    silentChannelExecutor.shutdownNow();
    throw new IOException(ex);
  }
  channelGroup=new DefaultChannelGroup();
  channelGroup.add(channel);
  msgLog.info(className + " communication server started and bound to " + socketAddress);
}
