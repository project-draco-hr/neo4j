{
  this.oldChannelThresholdMillis=config.getOldChannelThreshold();
  chunkSize=config.getChunkSize();
  assertChunkSizeIsWithinFrameSize(chunkSize,frameLength);
  String className=getClass().getSimpleName();
  targetCallExecutor=newCachedThreadPool(named(className + ":" + config.getServerAddress().getPort()));
  unfinishedTransactionExecutor=newScheduledThreadPool(2,named("Unfinished transactions"));
  silentChannelExecutor=newSingleThreadScheduledExecutor(named("Silent channel reaper"));
  silentChannelExecutor.scheduleWithFixedDelay(silentChannelFinisher(),5,5,TimeUnit.SECONDS);
  ExecutorService bossExecutor=newCachedThreadPool(daemon("Boss-" + className));
  ExecutorService workerExecutor=newCachedThreadPool(daemon("Worker-" + className));
  bootstrap=new ServerBootstrap(new NioServerSocketChannelFactory(bossExecutor,workerExecutor,config.getMaxConcurrentTransactions()));
  bootstrap.setPipelineFactory(this);
  PortRangeSocketBinder portRangeSocketBinder=new PortRangeSocketBinder(bootstrap);
  try {
    Connection connection=portRangeSocketBinder.bindToFirstAvailablePortInRange(config.getServerAddress());
    Channel channel=connection.getChannel();
    socketAddress=connection.getSocketAddress();
    channelGroup=new DefaultChannelGroup();
    channelGroup.add(channel);
    msgLog.info(className + " communication server started and bound to " + socketAddress);
  }
 catch (  Exception ex) {
    msgLog.error("Failed to bind server to " + socketAddress,ex);
    bootstrap.releaseExternalResources();
    targetCallExecutor.shutdownNow();
    unfinishedTransactionExecutor.shutdownNow();
    silentChannelExecutor.shutdownNow();
    throw new IOException(ex);
  }
}
