{
  boolean onePhase=isOnePhase();
  boolean readOnly=true;
  if (!onePhase) {
    status=Status.STATUS_PREPARING;
    LinkedList<Xid> preparedXids=new LinkedList<Xid>();
    Iterator<ResourceElement> itr=resourceList.iterator();
    while (itr.hasNext()) {
      ResourceElement re=itr.next();
      if (!preparedXids.contains(re.getXid())) {
        preparedXids.add(re.getXid());
        int vote=re.getResource().prepare(re.getXid());
        if (vote == XAResource.XA_OK) {
          readOnly=false;
        }
 else         if (vote == XAResource.XA_RDONLY) {
          re.setStatus(RS_READONLY);
        }
 else {
          status=Status.STATUS_MARKED_ROLLBACK;
          return;
        }
      }
 else {
        re.setStatus(RS_READONLY);
      }
    }
    status=Status.STATUS_PREPARED;
  }
  if (!onePhase && readOnly) {
    status=Status.STATUS_COMMITTED;
    return;
  }
  if (!onePhase) {
    try {
      txManager.getTxLog().markAsCommitting(getGlobalId());
    }
 catch (    IOException e) {
      log.log(Level.SEVERE,"Error writing transaction log",e);
      txManager.setTmNotOk();
      throw Exceptions.withCause(new SystemException("TM encountered a problem, " + " error writing transaction log"),e);
    }
  }
  status=Status.STATUS_COMMITTING;
  Iterator<ResourceElement> itr=resourceList.iterator();
  while (itr.hasNext()) {
    ResourceElement re=itr.next();
    if (re.getStatus() != RS_READONLY) {
      re.getResource().commit(re.getXid(),onePhase);
    }
  }
  status=Status.STATUS_COMMITTED;
}
