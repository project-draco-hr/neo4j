{
  if (fileChannel == null) {
    return;
  }
  closeStorage();
  if (windowPool != null) {
    windowPool.close();
    windowPool=null;
  }
  if (isReadOnly() && !isBackupSlave()) {
    try {
      fileChannel.close();
    }
 catch (    IOException e) {
      throw new UnderlyingStorageException(e);
    }
    return;
  }
  int recordSize=-1;
  long highId=-1;
  if (idGenerator != null) {
    highId=idGenerator.getHighId();
  }
  if (this instanceof AbstractDynamicStore) {
    recordSize=((AbstractDynamicStore)this).getBlockSize();
  }
 else   if (this instanceof AbstractStore) {
    recordSize=((AbstractStore)this).getRecordSize();
  }
  closeIdGenerator();
  boolean success=false;
  IOException storedIoe=null;
  if (typeDescriptorAndVersionTruncated) {
    for (int i=0; i < 10; i++) {
      try {
        fileChannel.position(highId * recordSize);
        ByteBuffer buffer=ByteBuffer.wrap(UTF8.encode(getTypeAndVersionDescriptor()));
        fileChannel.write(buffer);
        fileChannel.truncate(fileChannel.position());
        fileChannel.force(false);
        if (fileLock != null) {
          fileLock.release();
        }
        fileChannel.close();
        fileChannel=null;
        success=true;
        break;
      }
 catch (      IOException e) {
        storedIoe=e;
        System.gc();
      }
    }
  }
 else {
    try {
      if (fileLock != null) {
        fileLock.release();
      }
      fileChannel.close();
      success=true;
    }
 catch (    IOException e) {
      logger.log(Level.WARNING,"Could not close fileChannel [" + storageFileName + "]",e);
    }
  }
  if (!success) {
    throw new UnderlyingStorageException("Unable to close store " + getStorageFileName(),storedIoe);
  }
}
