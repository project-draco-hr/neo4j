{
  String name="log";
  File file=new File(directory.directory(),name + ".1");
  final int logVersion=1;
  writeSomeData(file,new Visitor<ByteBuffer,IOException>(){
    @Override public boolean visit(    ByteBuffer buffer) throws IOException {
      writeLogHeader(buffer,logVersion,3);
      buffer.position(LOG_HEADER_SIZE);
      return true;
    }
  }
);
  LifeSupport life=new LifeSupport();
  final PhysicalLogFiles logFiles=new PhysicalLogFiles(directory.directory(),name,fs);
  Recovery.Monitor monitor=mock(Recovery.Monitor.class);
  final AtomicBoolean recoveryRequiredCalled=new AtomicBoolean();
  try {
    life.add(new Recovery(new Recovery.SPI(){
      @Override public void forceEverything(){
      }
      @Override public long getCurrentLogVersion(){
        return logVersionRepository.getCurrentLogVersion();
      }
      @Override public Visitor<LogVersionedStoreChannel,IOException> getRecoverer(){
        throw new AssertionError("Recovery should not be required");
      }
      @Override public PhysicalLogVersionedStoreChannel getLogFile(      long recoveryVersion) throws IOException {
        return PhysicalLogFile.openForVersion(logFiles,fs,recoveryVersion);
      }
      @Override public void recoveryRequired(){
        fail("Recovery should not be required");
      }
    }
,monitor));
    life.add(new PhysicalLogFile(fs,logFiles,50,transactionIdStore,logVersionRepository,mock(PhysicalLogFile.Monitor.class),new TransactionMetadataCache(10,100)));
    life.start();
    verifyZeroInteractions(monitor);
  }
  finally {
    life.shutdown();
  }
}
