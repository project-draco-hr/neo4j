{
  final PhysicalLogFiles logFiles=new PhysicalLogFiles(directory.directory(),"log",fs);
  File file=logFiles.getLogFileForVersion(logVersion);
  writeSomeData(file,new Visitor<Pair<LogEntryWriter,Consumer<LogPositionMarker>>,IOException>(){
    @Override public boolean visit(    Pair<LogEntryWriter,Consumer<LogPositionMarker>> pair) throws IOException {
      LogEntryWriter writer=pair.first();
      Consumer<LogPositionMarker> consumer=pair.other();
      LogPositionMarker marker=new LogPositionMarker();
      consumer.accept(marker);
      LogPosition lastCommittedTxPosition=marker.newPosition();
      writer.writeStartEntry(0,1,2l,3l,new byte[0]);
      lastCommittedTxStartEntry=new LogEntryStart(0,1,2l,3l,new byte[0],lastCommittedTxPosition);
      writer.writeCommitEntry(4l,5l);
      lastCommittedTxCommitEntry=new OnePhaseCommit(4l,5l);
      writer.writeCheckPointEntry(lastCommittedTxPosition);
      expectedCheckPointEntry=new CheckPoint(lastCommittedTxPosition);
      consumer.accept(marker);
      writer.writeStartEntry(0,1,6l,4l,new byte[0]);
      expectedStartEntry=new LogEntryStart(0,1,6l,4l,new byte[0],marker.newPosition());
      writer.writeCommitEntry(5l,7l);
      expectedCommitEntry=new OnePhaseCommit(5l,7l);
      return true;
    }
  }
);
  LifeSupport life=new LifeSupport();
  Recovery.Monitor monitor=mock(Recovery.Monitor.class);
  final AtomicBoolean recoveryRequired=new AtomicBoolean();
  try {
    RecoveryLabelScanWriterProvider provider=mock(RecoveryLabelScanWriterProvider.class);
    RecoveryLegacyIndexApplierLookup lookup=mock(RecoveryLegacyIndexApplierLookup.class);
    RecoveryIndexingUpdatesValidator validator=mock(RecoveryIndexingUpdatesValidator.class);
    StoreFlusher flusher=mock(StoreFlusher.class);
    final LogEntryReader<ReadableLogChannel> reader=new VersionAwareLogEntryReader<>(LogEntryVersion.CURRENT.byteCode());
    LatestCheckPointFinder finder=new LatestCheckPointFinder(logFiles,fs,reader);
    TransactionMetadataCache metadataCache=new TransactionMetadataCache(10,100);
    LogFile logFile=life.add(new PhysicalLogFile(fs,logFiles,50,transactionIdStore,logVersionRepository,mock(PhysicalLogFile.Monitor.class),metadataCache));
    LogicalTransactionStore txStore=new PhysicalLogicalTransactionStore(logFile,metadataCache);
    TransactionRepresentationStoreApplier storeApplier=mock(TransactionRepresentationStoreApplier.class);
    life.add(new Recovery(new DefaultRecoverySPI(provider,lookup,flusher,mock(NeoStores.class),logVersionRepository,finder,validator,transactionIdStore,txStore,storeApplier){
      private int nr=0;
      @Override public Visitor<CommittedTransactionRepresentation,Exception> getRecoveryVisitor(){
        recoveryRequired.set(true);
        final Visitor<CommittedTransactionRepresentation,Exception> actual=super.getRecoveryVisitor();
        return new Visitor<CommittedTransactionRepresentation,Exception>(){
          @Override public boolean visit(          CommittedTransactionRepresentation tx) throws Exception {
            actual.visit(tx);
switch (nr++) {
case 0:
              assertEquals(lastCommittedTxStartEntry,tx.getStartEntry());
            assertEquals(lastCommittedTxCommitEntry,tx.getCommitEntry());
          break;
case 1:
        assertEquals(expectedStartEntry,tx.getStartEntry());
      assertEquals(expectedCommitEntry,tx.getCommitEntry());
    break;
default :
  fail("Too many recovered transactions");
}
return false;
}
}
;
}
}
,monitor));
life.start();
InOrder order=inOrder(monitor);
order.verify(monitor,times(1)).recoveryRequired(any(LogPosition.class));
order.verify(monitor,times(1)).recoveryCompleted(2);
assertTrue(recoveryRequired.get());
}
  finally {
life.shutdown();
}
}
