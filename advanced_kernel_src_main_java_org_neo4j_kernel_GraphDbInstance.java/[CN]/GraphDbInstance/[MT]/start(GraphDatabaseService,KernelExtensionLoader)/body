{
  if (started) {
    throw new IllegalStateException("Neo4j instance already started");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir);
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  String separator=System.getProperty("file.separator");
  String store=storeDir + separator + "neostore";
  params.put("store_dir",storeDir);
  params.put("neo_store",store);
  params.put("create",String.valueOf(create));
  String logicalLog=storeDir + separator + "nioneo_logical.log";
  params.put("logical_log",logicalLog);
  byte resourceId[]=UTF8.encode("414141");
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  kernelExtensionLoader.configureKernelExtensions();
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + "lucene");
      byte luceneId[]=UTF8.encode("162373");
      registerLuceneDataSource("lucene",clazz.getName(),config.getTxModule(),storeDir + File.separator + "lucene",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + "lucene-fulltext");
      byte[] luceneId=UTF8.encode("262374");
      registerLuceneDataSource("lucene-fulltext",clazz.getName(),config.getTxModule(),storeDir + File.separator + "lucene-fulltext",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.initializeIndexProviders();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage("--- CONFIGURATION START ---");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage("Kernel version: " + Version.getKernel());
  for (  Version componentVersion : Service.load(Version.class)) {
    logger.logMessage(componentVersion.toString());
  }
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(String.format("Operating System: %s; version: %s; arch: %s; cpus: %s",os.getName(),os.getVersion(),os.getArch(),os.getAvailableProcessors()));
  logger.logMessage("VM Name: " + runtime.getVmName());
  logger.logMessage("VM Vendor: " + runtime.getVmVendor());
  logger.logMessage("VM Version: " + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage("Boot Class Path: " + runtime.getBootClassPath());
  }
  logger.logMessage("Class Path: " + runtime.getClassPath());
  logger.logMessage("Library Path: " + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage("Garbage Collector: " + gcBean.getName() + ": "+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage("VM Arguments: " + runtime.getInputArguments());
  logger.logMessage("");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage("--- CONFIGURATION END ---");
  logger.flush();
  started=true;
  return Collections.unmodifiableMap(params);
}
