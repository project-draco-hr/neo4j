{
  availabilityGuard=createAvailabilityGuard();
  availabilityGuard.addListener(new AvailabilityGuard.AvailabilityListener(){
    @Override public void available(){
      msgLog.info("Database is now ready");
    }
    @Override public void unavailable(){
      msgLog.info("Database is now unavailable");
    }
  }
);
  fileSystem=createFileSystemAbstraction();
  if (this.logging == null) {
    this.logging=createLogging();
  }
  this.monitors=createMonitors();
  storeMigrationProcess=new StoreUpgrader(new ConfigMapUpgradeConfiguration(config),fileSystem,monitors.newMonitor(StoreUpgrader.Monitor.class));
  AutoConfigurator autoConfigurator=new AutoConfigurator(fileSystem,config.get(NeoStoreXaDataSource.Configuration.store_dir),config.get(Configuration.use_memory_mapped_buffers),logging.getConsoleLog(AutoConfigurator.class));
  if (config.get(GraphDatabaseSettings.dump_configuration)) {
    System.out.println(autoConfigurator.getNiceMemoryInformation());
  }
  Map<String,String> configParams=config.getParams();
  Map<String,String> autoConfiguration=autoConfigurator.configure();
  for (  Map.Entry<String,String> autoConfig : autoConfiguration.entrySet()) {
    String key=autoConfig.getKey();
    if (!config.getParams().containsKey(key)) {
      configParams.put(key,autoConfig.getValue());
    }
  }
  config.applyChanges(configParams);
  this.msgLog=logging.getMessagesLog(getClass());
  config.setLogger(msgLog);
  this.storeLocker=life.add(new StoreLockerLifecycleAdapter(new StoreLocker(fileSystem),storeDir));
  new JvmChecker(msgLog,new JvmMetadataRepository()).checkJvmCompatibilityAndIssueWarning();
  boolean readOnly=config.get(Configuration.read_only);
  String cacheTypeName=config.get(Configuration.cache_type);
  CacheProvider cacheProvider=cacheProviders.get(cacheTypeName);
  if (cacheProvider == null) {
    throw new IllegalArgumentException("No provider for cache type '" + cacheTypeName + "'. "+ "Cache providers are loaded using java service loading where they "+ "register themselves in resource (plain-text) files found on the class path under "+ "META-INF/services/"+ CacheProvider.class.getName()+ ". This missing provider may have "+ "been caused by either such a missing registration, or by the lack of the provider class itself.");
  }
  jobScheduler=life.add(new Neo4jJobScheduler(this.toString(),logging.getMessagesLog(Neo4jJobScheduler.class)));
  kernelEventHandlers=new KernelEventHandlers(logging.getMessagesLog(KernelEventHandlers.class));
  caches=createCaches();
  diagnosticsManager=life.add(new DiagnosticsManager(logging.getMessagesLog(DiagnosticsManager.class)));
  kernelPanicEventGenerator=new KernelPanicEventGenerator(kernelEventHandlers);
  kernelHealth=new KernelHealth(kernelPanicEventGenerator,logging);
  LifecycleRelocator neoStoreDataSourceRelocator=life.add(new LifecycleRelocator());
  txHook=createTxHook();
  guard=config.get(Configuration.execution_guard_enabled) ? new Guard(msgLog) : null;
  updateableSchemaState=new KernelSchemaStateStore(newSchemaStateMap());
  txIdGenerator=life.add(createTxIdGenerator());
  lockManager=createLockManager();
  idGeneratorFactory=createIdGeneratorFactory();
  storeMigrationProcess.addParticipant(new StoreMigrator(new VisibleMigrationProgressMonitor(logging.getMessagesLog(StoreMigrator.class),System.out),new UpgradableDatabase(new StoreVersionCheck(fileSystem)),config));
  propertyKeyTokenHolder=life.add(new PropertyKeyTokenHolder(createPropertyKeyCreator()));
  labelTokenHolder=life.add(new LabelTokenHolder(createLabelIdCreator()));
  relationshipTypeTokenHolder=life.add(new RelationshipTypeTokenHolder(createRelationshipTypeCreator()));
  caches.configure(cacheProvider,config);
  Cache<NodeImpl> nodeCache=diagnosticsManager.tryAppendProvider(caches.node());
  Cache<RelationshipImpl> relCache=diagnosticsManager.tryAppendProvider(caches.relationship());
  threadToTransactionBridge=life.add(new ThreadToStatementContextBridge());
  nodeManager=guard != null ? createGuardedNodeManager(readOnly,cacheProvider,nodeCache,relCache) : createNodeManager(readOnly,cacheProvider,nodeCache,relCache);
  transactionEventHandlers=new TransactionEventHandlers(createNodeLookup(),createRelationshipLookups(),threadToTransactionBridge);
  indexStore=life.add(new IndexStore(this.storeDir,fileSystem));
  diagnosticsManager.prependProvider(config);
  extensions=life.add(createKernelData());
  life.add(kernelExtensions);
  schema=new SchemaImpl(threadToTransactionBridge);
  indexManager=new IndexManagerImpl(config,indexStore,threadToTransactionBridge,neoDataSource);
  nodeAutoIndexer=life.add(new NodeAutoIndexerImpl(config,indexManager,nodeManager));
  relAutoIndexer=life.add(new RelationshipAutoIndexerImpl(config,indexManager,nodeManager));
  indexManager.setNodeAutoIndexer(nodeAutoIndexer);
  indexManager.setRelAutoIndexer(relAutoIndexer);
  recoveryVerifier=createRecoveryVerifier();
  storeFactory=createStoreFactory();
  transactionHeaderInformation=createTransactionHeaderInformation();
  transactionMonitor=new TransactionMonitorImpl();
  createNeoDataSource();
  neoStoreDataSourceRelocator.setDelegate(neoDataSource);
  life.add(new MonitorGc(config,msgLog));
  life.add(nodeManager);
  createDatabaseAvailability();
  life.add(kernelEventHandlers);
  life.add(new ConfigurationChangedRestarter());
}
