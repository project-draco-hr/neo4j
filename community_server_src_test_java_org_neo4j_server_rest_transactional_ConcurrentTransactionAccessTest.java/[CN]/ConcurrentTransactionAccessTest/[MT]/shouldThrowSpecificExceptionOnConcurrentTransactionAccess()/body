{
  TransactionRegistry registry=new TransactionHandleRegistry(mock(Clock.class),StringLogger.DEV_NULL);
  TransitionalPeriodTransactionMessContainer kernel=mock(TransitionalPeriodTransactionMessContainer.class);
  when(kernel.newTransactionContext()).thenReturn(mock(TransitionalTxManagementTransactionContext.class));
  TransactionFacade actions=new TransactionFacade(kernel,null,registry,null);
  final TransactionHandle transactionHandle=actions.newTransactionHandle(new DisgustingUriScheme());
  final DoubleLatch latch=new DoubleLatch();
  final StatementDeserializer statements=mock(StatementDeserializer.class);
  when(statements.hasNext()).thenAnswer(new Answer<Boolean>(){
    @Override public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      latch.startAndAwaitFinish();
      return false;
    }
  }
);
  new Thread(new Runnable(){
    @Override public void run(){
      transactionHandle.execute(statements,mock(ExecutionResultSerializer.class));
    }
  }
).start();
  latch.awaitStart();
  try {
    actions.findTransactionHandle(DisgustingUriScheme.parseTxId(transactionHandle.uri()));
    fail("should have thrown exception");
  }
 catch (  InvalidConcurrentTransactionAccess neo4jError) {
  }
 finally {
    latch.finish();
  }
}
