{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
        sampler.increment(1);
      Fieldable encodedValue=documentStructure.encodeAsFieldable(update.getValueAfter());
    writer.updateDocument(documentStructure.newQueryForChangeOrRemove(nodeId),documentStructure.newDocumentRepresentingProperty(nodeId,encodedValue));
  updatedPropertyValues.add(update.getValueAfter());
break;
case CHANGED:
Fieldable encodedValueAfter=documentStructure.encodeAsFieldable(update.getValueAfter());
writer.updateDocument(documentStructure.newQueryForChangeOrRemove(nodeId),documentStructure.newDocumentRepresentingProperty(nodeId,encodedValueAfter));
updatedPropertyValues.add(update.getValueAfter());
break;
case REMOVED:
sampler.increment(-1);
writer.deleteDocuments(documentStructure.newQueryForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
searcherManager.maybeRefresh();
IndexSearcher searcher=searcherManager.acquire();
try {
DuplicateCheckingCollector collector=duplicateCheckingCollector(accessor);
for (Object propertyValue : updatedPropertyValues) {
collector.reset();
Query query=documentStructure.newQuery(propertyValue);
searcher.search(query,collector);
}
}
 catch (IOException e) {
Throwable cause=e.getCause();
if (cause instanceof IndexEntryConflictException) {
throw (IndexEntryConflictException)cause;
}
throw e;
}
 finally {
searcherManager.release(searcher);
}
}
@Override public void remove(Collection<Long> nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
