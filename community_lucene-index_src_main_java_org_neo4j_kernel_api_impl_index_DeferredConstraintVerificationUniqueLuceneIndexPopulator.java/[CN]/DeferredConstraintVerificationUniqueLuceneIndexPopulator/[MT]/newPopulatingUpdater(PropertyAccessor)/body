{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public Reservation validate(    Iterable<NodePropertyUpdate> updates) throws IOException {
      return Reservation.EMPTY;
    }
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException, IndexCapacityExceededException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
case CHANGED:
        writer.updateDocument(documentStructure.newQueryForChangeOrRemove(nodeId),documentStructure.newDocumentRepresentingProperty(nodeId,update.getValueAfter()));
      updatedPropertyValues.add(update.getValueAfter());
    break;
case REMOVED:
  writer.deleteDocuments(documentStructure.newQueryForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
searcherManager.maybeRefresh();
IndexSearcher searcher=searcherManager.acquire();
try {
DuplicateCheckingCollector collector=duplicateCheckingCollector(accessor);
for (Object propertyValue : updatedPropertyValues) {
collector.reset();
Query query=documentStructure.newQuery(propertyValue);
searcher.search(query,collector);
}
}
 catch (IOException e) {
Throwable cause=e.getCause();
if (cause instanceof IndexEntryConflictException) {
throw (IndexEntryConflictException)cause;
}
throw e;
}
 finally {
searcherManager.release(searcher);
}
}
@Override public void remove(Iterable<Long> nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
