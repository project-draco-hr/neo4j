{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public Reservation validate(    Iterable<NodePropertyUpdate> updates) throws IOException {
      return Reservation.EMPTY;
    }
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException, IndexCapacityExceededException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
        sampler.increment(1);
      writer.updateDocument(documentStructure.newTermForChangeOrRemove(nodeId),documentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
    updatedPropertyValues.add(update.getValueAfter());
  break;
case CHANGED:
writer.updateDocument(documentStructure.newTermForChangeOrRemove(nodeId),documentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
updatedPropertyValues.add(update.getValueAfter());
break;
case REMOVED:
sampler.increment(-1);
writer.deleteDocuments(documentStructure.newTermForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
searcherManager.maybeRefresh();
IndexSearcher searcher=searcherManager.acquire();
try {
DuplicateCheckingCollector collector=duplicateCheckingCollector(accessor);
for (Object propertyValue : updatedPropertyValues) {
collector.reset();
Query query=documentStructure.newSeekQuery(propertyValue);
searcher.search(query,collector);
}
}
 catch (IOException e) {
Throwable cause=e.getCause();
if (cause instanceof IndexEntryConflictException) {
throw (IndexEntryConflictException)cause;
}
throw e;
}
 finally {
searcherManager.release(searcher);
}
}
@Override public void remove(PrimitiveLongSet nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
