{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
        entryCount++;
case CHANGED:
      writer.updateDocument(documentStructure.newQueryForChangeOrRemove(nodeId),documentStructure.newDocumentRepresentingProperty(nodeId,update.getValueAfter()));
    updatedPropertyValues.add(update.getValueAfter());
  break;
case REMOVED:
entryCount--;
writer.deleteDocuments(documentStructure.newQueryForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
searcherManager.maybeRefresh();
IndexSearcher searcher=searcherManager.acquire();
try {
for (Object propertyValue : updatedPropertyValues) {
TopDocs docs=searcher.search(documentStructure.newQuery(propertyValue),2);
if (docs.totalHits > 1) {
long nodeId1=getNodeId(searcher.getIndexReader(),docs,0);
long nodeId2=getNodeId(searcher.getIndexReader(),docs,1);
throw new PreexistingIndexEntryConflictException(propertyValue,nodeId1,nodeId2);
}
}
}
  finally {
searcherManager.release(searcher);
}
}
@Override public void remove(Iterable<Long> nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
