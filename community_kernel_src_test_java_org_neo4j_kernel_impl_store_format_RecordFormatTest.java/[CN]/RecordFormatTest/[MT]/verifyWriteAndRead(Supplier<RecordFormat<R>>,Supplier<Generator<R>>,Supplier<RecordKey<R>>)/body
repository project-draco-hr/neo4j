{
  PageCache pageCache=pageCacheRule.getPageCache(fsRule.get());
  try (PagedFile dontUseStoreFile=pageCache.map(new File("store"),PAGE_SIZE,CREATE)){
    long totalUnusedBytesPrimary=0;
    long totalUnusedBytesSecondary=0;
    long totalRecordsRequiringSecondUnit=0;
    RecordFormat<R> format=formatSupplier.get();
    RecordKey<R> key=keySupplier.get();
    Generator<R> generator=generatorSupplier.get();
    int recordSize=format.getRecordSize(new IntStoreHeader(DATA_SIZE));
    RecordBoundaryCheckingPagedFile storeFile=new RecordBoundaryCheckingPagedFile(dontUseStoreFile,recordSize);
    BatchingIdSequence idSequence=new BatchingIdSequence(random.nextBoolean() ? idSureToBeOnTheNextPage(PAGE_SIZE,recordSize) : 10);
    long smallestUnusedBytesPrimary=recordSize;
    long smallestUnusedBytesSecondary=recordSize;
    long time=currentTimeMillis();
    long endTime=time + TEST_TIME;
    long i=0;
    for (; i < TEST_ITERATIONS && currentTimeMillis() < endTime; i++) {
      R written=generator.get(recordSize,format);
      try {
        try (PageCursor cursor=storeFile.io(0,PagedFile.PF_SHARED_WRITE_LOCK)){
          assertedNext(cursor);
          if (written.inUse()) {
            format.prepare(written,recordSize,idSequence);
          }
          int offset=Math.toIntExact(written.getId() * recordSize);
          cursor.setOffset(offset);
          format.write(written,cursor,recordSize,storeFile);
        }
         long recordsUsedForWriting=storeFile.nextCalls();
        long unusedBytes=storeFile.unusedBytes();
        storeFile.resetMeasurements();
        try (PageCursor cursor=storeFile.io(0,PagedFile.PF_SHARED_READ_LOCK)){
          assertedNext(cursor);
          int offset=Math.toIntExact(written.getId() * recordSize);
          cursor.setOffset(offset);
          @SuppressWarnings("unchecked") R read=(R)written.clone();
          format.read(read,cursor,NORMAL,recordSize,storeFile);
          if (written.inUse()) {
            assertEquals(written.inUse(),read.inUse());
            assertEquals(written.getId(),read.getId());
            assertEquals(written.getSecondaryId(),read.getSecondaryId());
            key.assertRecordsEquals(written,read);
          }
 else {
            assertEquals(written.inUse(),read.inUse());
          }
        }
         if (written.inUse()) {
          assertEquals(recordsUsedForWriting,storeFile.ioCalls());
          assertEquals(recordsUsedForWriting,storeFile.nextCalls());
          assertEquals(unusedBytes,storeFile.unusedBytes());
          if (recordsUsedForWriting == 1) {
            totalUnusedBytesPrimary+=unusedBytes;
            smallestUnusedBytesPrimary=Math.min(smallestUnusedBytesPrimary,unusedBytes);
          }
 else {
            totalUnusedBytesSecondary+=unusedBytes;
            smallestUnusedBytesSecondary=Math.min(smallestUnusedBytesSecondary,unusedBytes);
          }
          totalRecordsRequiringSecondUnit+=(recordsUsedForWriting > 1 ? 1 : 0);
        }
        storeFile.resetMeasurements();
        idSequence.reset();
      }
 catch (      Throwable t) {
        Exceptions.setMessage(t,t.getMessage() + " : " + written);
        throw t;
      }
    }
    time=currentTimeMillis() - time;
    if (time >= PRINT_RESULTS_THRESHOLD) {
      System.out.printf("%s%n  %.2f write-read ops/ms%n  %.2f%% required secondary unit%n" + "  %.2f%% wasted primary record space%n" + "  %.2f%% wasted secondary record space%n"+ "  %.2f%% wasted total record space%n"+ "  %dB smallest primary waste%n"+ "  %dB smallest secondary waste%n",format,((double)i / time),percent(totalRecordsRequiringSecondUnit,i),percent(totalUnusedBytesPrimary,i * recordSize),percent(totalUnusedBytesSecondary,i * recordSize),percent(totalUnusedBytesPrimary + totalUnusedBytesSecondary,i * recordSize),smallestUnusedBytesPrimary,smallestUnusedBytesPrimary);
    }
  }
 }
