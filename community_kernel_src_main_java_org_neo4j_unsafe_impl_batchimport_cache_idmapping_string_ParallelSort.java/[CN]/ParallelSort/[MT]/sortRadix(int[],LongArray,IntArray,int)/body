{
  int[][] rangeParams=new int[threads][2];
  int[] bucketRange=new int[threads];
  sortBuckets=new long[threads][2];
  long dataCacheSize=dataCache.highestSetIndex() + 1;
  int bucketSize=(int)(dataCacheSize / threads);
  int count=0, fullCount=0 + 0;
  rangeParams[0][0]=0;
  bucketRange[0]=0;
  for (int i=0, threadIndex=0; i < radixIndexCount.length && threadIndex < threads; i++) {
    if ((count + radixIndexCount[i]) > bucketSize) {
      bucketRange[threadIndex]=i - 1;
      rangeParams[threadIndex + 1][0]=fullCount;
      rangeParams[threadIndex][1]=count;
      count=0;
      threadIndex++;
    }
    if (threadIndex == threads - 1) {
      bucketRange[threadIndex]=radixIndexCount.length;
      rangeParams[threadIndex][1]=(int)dataCacheSize - fullCount;
      break;
    }
 else {
      count+=radixIndexCount[i];
      fullCount+=radixIndexCount[i];
    }
  }
  int[] bucketIndex=new int[threads];
  for (int i=0; i < threads; i++) {
    bucketIndex[i]=0;
  }
  for (long i=0; i < dataCacheSize; i++) {
    int rIndex=radixOf(dataCache.get(i));
    for (int k=0; k < threads; k++) {
      if (rIndex <= bucketRange[k]) {
        long temp=(rangeParams[k][0] + bucketIndex[k]++);
        long temp1=tracker.get(temp);
        if (temp1 != -1) {
          System.out.println("error in init of tracker");
        }
        tracker.set(temp,(int)i);
        if (bucketIndex[k] == rangeParams[k][1]) {
          sortBuckets[k][0]=bucketRange[k];
          sortBuckets[k][1]=rangeParams[k][0];
        }
        break;
      }
    }
  }
  return rangeParams;
}
