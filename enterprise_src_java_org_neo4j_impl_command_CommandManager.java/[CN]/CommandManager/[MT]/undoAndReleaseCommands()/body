{
  Thread currentThread=Thread.currentThread();
  if (commandStack.containsKey(currentThread)) {
    UndoFailedException ufe=null;
    int undoFailedCount=0;
    CommandStackElement cse=commandStack.remove(currentThread);
    Stack<Command> cStack=cse.commands;
    while (!cStack.isEmpty()) {
      Command command=cStack.pop();
      try {
        command.undo();
      }
 catch (      UndoFailedException e) {
        undoFailedCount++;
        if (ufe == null) {
          ufe=e;
        }
      }
    }
    Stack<LockElement> lStack=cse.locks;
    while (lStack != null && !lStack.isEmpty()) {
      LockElement lockElement=lStack.pop();
      try {
        if (lockElement.lockType == LockType.READ) {
          LockManager.getManager().releaseReadLock(lockElement.resource);
        }
 else         if (lockElement.lockType == LockType.WRITE) {
          LockManager.getManager().releaseWriteLock(lockElement.resource);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        log.severe("Unable to release lock[" + lockElement.lockType + "] on resource["+ lockElement.resource+ "]");
      }
    }
    if (ufe != null) {
      throw new UndoFailedException("Undo commands failed, " + "undo fail count was " + undoFailedCount,ufe);
    }
  }
}
