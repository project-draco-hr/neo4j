{
  MasterImpl master=spy(newMasterImpl(mockMasterImplSpiWith(StoreId.DEFAULT)));
  doReturn(voidResponseWithTransactionLogs()).when(master).newLockSession(any(RequestContext.class));
  cleanupRule.add(newMasterServer(master));
  DependencyResolver resolver=mock(DependencyResolver.class);
  LogicalTransactionStore txStore=mock(LogicalTransactionStore.class);
  final BatchingTransactionRepresentationStoreApplier txApplier=mock(BatchingTransactionRepresentationStoreApplier.class);
  TransactionIdStore txIdStore=mock(TransactionIdStore.class);
  TransactionAppender txAppender=mock(TransactionAppender.class);
  when(txAppender.append(any(TransactionRepresentation.class),anyLong())).thenReturn(new StubbedCommitment());
  LogFile logFile=mock(LogFile.class);
  when(resolver.resolveDependency(LogicalTransactionStore.class)).thenReturn(txStore);
  when(resolver.resolveDependency(TransactionIdStore.class)).thenReturn(txIdStore);
  when(resolver.resolveDependency(LogFile.class)).thenReturn(logFile);
  when(resolver.resolveDependency(LogRotation.class)).thenReturn(mock(LogRotation.class));
  KernelHealth kernelHealth=mock(KernelHealth.class);
  when(kernelHealth.isHealthy()).thenReturn(true);
  when(resolver.resolveDependency(KernelHealth.class)).thenReturn(kernelHealth);
  when(resolver.resolveDependency(Logging.class)).thenReturn(DevNullLoggingService.DEV_NULL);
  when(resolver.resolveDependency(IdOrderingQueue.class)).thenReturn(IdOrderingQueue.BYPASS);
  when(txStore.getAppender()).thenReturn(txAppender);
  final IndexUpdatesValidator indexUpdatesValidator=mock(IndexUpdatesValidator.class);
  when(indexUpdatesValidator.validate(any(TransactionRepresentation.class))).thenReturn(ValidatedIndexUpdates.NONE);
  ResponseUnpacker unpacker=initAndStart(new TransactionCommittingResponseUnpacker(resolver,100,new Function<DependencyResolver,IndexUpdatesValidator>(){
    @Override public IndexUpdatesValidator apply(    DependencyResolver from) throws RuntimeException {
      return indexUpdatesValidator;
    }
  }
,new Function<DependencyResolver,BatchingTransactionRepresentationStoreApplier>(){
    @Override public BatchingTransactionRepresentationStoreApplier apply(    DependencyResolver from) throws RuntimeException {
      return txApplier;
    }
  }
));
  MasterClient masterClient=cleanupRule.add(newMasterClient214(StoreId.DEFAULT,unpacker));
  masterClient.newLockSession(new RequestContext(1,2,3,4,5));
  verify(txAppender,times(TX_LOG_COUNT)).append(any(TransactionRepresentation.class),anyLong());
  verify(txApplier,times(TX_LOG_COUNT)).apply(any(TransactionRepresentation.class),any(ValidatedIndexUpdates.class),any(LockGroup.class),anyLong(),any(TransactionApplicationMode.class));
  verify(txIdStore,times(TX_LOG_COUNT)).transactionClosed(anyLong());
}
