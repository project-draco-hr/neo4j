{
  msgLog.info("Non clean shutdown detected on log [" + logFileName + "]. Recovery started ...");
  long[] header=readLogHeader(fileChannel,"Tried to do recovery on log with illegal format version");
  if (header == null) {
    msgLog.info("Unable to read header information, " + "no records in logical log.");
    msgLog.logMessage("No log version found for " + logFileName,true);
    fileChannel.close();
    boolean success=fileSystem.renameFile(logFileName,new File(logFileName.getPath() + "_unknown_timestamp_" + System.currentTimeMillis()+ ".log"));
    assert success;
    fileChannel.close();
    fileChannel=fileSystem.open(logFileName,"rw");
    return;
  }
  logVersion=header[0];
  determineLogVersionFromArchivedFiles();
  if (header[0] != logVersion) {
    ByteBuffer buff=ByteBuffer.allocate(64);
    VersionAwareLogEntryReader.writeLogHeader(buff,logVersion,header[1]);
    fileChannel.writeAll(buff,0);
  }
  long lastCommittedTx=header[1];
  previousLogLastCommittedTx=lastCommittedTx;
  positionCache.putHeader(logVersion,previousLogLastCommittedTx);
  msgLog.logMessage("[" + logFileName + "] logVersion="+ logVersion+ " with committed tx="+ lastCommittedTx,true);
  fileChannel=new BufferedFileChannel(fileChannel,bufferMonitor);
  RecoveryLogDeserializer reader=new RecoveryLogDeserializer(sharedBuffer,commandReaderFactory);
  EntryCountingLogHandler counter=new EntryCountingLogHandler(new LogApplier());
  RecoveryConsumer consumer=new RecoveryConsumer(counter);
  boolean success=true;
  consumer.startLog();
  Cursor<LogEntry,IOException> cursor=reader.cursor(fileChannel);
  try {
    while (cursor.next(consumer))     ;
  }
 catch (  IOException e) {
    success=false;
  }
 finally {
    counter.endLog(success);
  }
  long lastEntryPos=fileChannel.position();
  fileChannel=((BufferedFileChannel)fileChannel).getSource();
  fileChannel.position(lastEntryPos);
  msgLog.logMessage("[" + logFileName + "] entries found="+ counter.getEntriesFound()+ " lastEntryPos="+ lastEntryPos,true);
  sharedBuffer.clear();
  while (sharedBuffer.hasRemaining()) {
    sharedBuffer.put((byte)0);
  }
  sharedBuffer.flip();
  long endPosition=fileChannel.size();
  do {
    long bytesLeft=fileChannel.size() - fileChannel.position();
    if (bytesLeft < sharedBuffer.capacity()) {
      sharedBuffer.limit((int)bytesLeft);
    }
    fileChannel.writeAll(sharedBuffer);
    sharedBuffer.flip();
  }
 while (fileChannel.position() < endPosition);
  fileChannel.position(lastEntryPos);
  scanIsComplete=true;
  String recoveryCompletedMessage=openedLogicalLogMessage(logFileName,lastRecoveredTx,false);
  msgLog.logMessage(recoveryCompletedMessage);
  xaRm.checkXids();
  if (xidIdentMap.size() == 0) {
    msgLog.logMessage("Recovery on log [" + logFileName + "] completed.");
  }
 else {
    msgLog.logMessage("Recovery on log [" + logFileName + "] completed with "+ xidIdentMap+ " prepared transactions found.");
    for (    LogEntry.Start startEntry : xidIdentMap.values()) {
      msgLog.debug("[" + logFileName + "] 2PC xid["+ startEntry.getXid()+ "]");
    }
  }
  recoveredTxMap.clear();
}
