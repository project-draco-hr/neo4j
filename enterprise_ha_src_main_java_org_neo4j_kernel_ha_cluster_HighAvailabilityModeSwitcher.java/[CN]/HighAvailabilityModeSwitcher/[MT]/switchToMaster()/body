{
  msgLog.logMessage("I am " + config.get(ClusterSettings.server_id) + ", moving to master");
  try {
    final TransactionManager txManager=graphDb.getDependencyResolver().resolveDependency(TransactionManager.class);
    MasterImpl.SPI spi=new MasterImpl.SPI(){
      private static final int ID_GRAB_SIZE=1000;
      @Override public void acquireLock(      MasterImpl.LockGrabber grabber,      Object... entities){
        LockManager lockManager=graphDb.getLockManager();
        TransactionState state=((AbstractTransactionManager)graphDb.getTxManager()).getTransactionState();
        for (        Object entity : entities) {
          grabber.grab(lockManager,state,entity);
        }
      }
      @Override public Transaction beginTx() throws SystemException, NotSupportedException {
        txManager.begin();
        return txManager.getTransaction();
      }
      @Override public void finishTransaction(      boolean success){
        try {
          if (success) {
            txManager.commit();
          }
 else {
            txManager.rollback();
          }
        }
 catch (        Exception e) {
          throw Exceptions.launderedException(e);
        }
      }
      @Override public void suspendTransaction() throws SystemException {
        txManager.suspend();
      }
      @Override public void resumeTransaction(      Transaction transaction){
        try {
          txManager.resume(transaction);
        }
 catch (        IllegalStateException e) {
          throw new UnableToResumeTransactionException(e);
        }
catch (        Throwable e) {
          throw Exceptions.launderedException(e);
        }
      }
      @Override public GraphProperties graphProperties(){
        return graphDb.getDependencyResolver().resolveDependency(NodeManager.class).getGraphProperties();
      }
      @Override public IdAllocation allocateIds(      IdType idType){
        IdGenerator generator=graphDb.getIdGeneratorFactory().get(idType);
        return new IdAllocation(generator.nextIdBatch(ID_GRAB_SIZE),generator.getHighId(),generator.getDefragCount());
      }
      @Override public StoreId storeId(){
        return graphDb.getStoreId();
      }
      @Override public long applyPreparedTransaction(      String resource,      ReadableByteChannel preparedTransaction) throws IOException {
        XaDataSource dataSource=graphDb.getXaDataSourceManager().getXaDataSource(resource);
        return dataSource.applyPreparedTransaction(preparedTransaction);
      }
      @Override public Integer createRelationshipType(      String name){
        graphDb.getRelationshipTypeHolder().addValidRelationshipType(name,true);
        return graphDb.getRelationshipTypeHolder().getIdFor(name);
      }
      @Override public Pair<Integer,Long> getMasterIdForCommittedTx(      long txId) throws IOException {
        XaDataSource nioneoDataSource=graphDb.getXaDataSourceManager().getNeoStoreDataSource();
        return nioneoDataSource.getMasterForCommittedTx(txId);
      }
      @Override public RequestContext rotateLogsAndStreamStoreFiles(      StoreWriter writer){
        return ServerUtil.rotateLogsAndStreamStoreFiles(graphDb.getStoreDir(),graphDb.getXaDataSourceManager(),graphDb.getKernelPanicGenerator(),logging.getMessagesLog(MasterImpl.class),true,writer);
      }
      @Override public Response<Void> copyTransactions(      String dsName,      long startTxId,      long endTxId){
        return ServerUtil.getTransactions(graphDb,dsName,startTxId,endTxId);
      }
      @Override public <T>Response<T> packResponse(      RequestContext context,      T response,      Predicate<Long> filter){
        return ServerUtil.packResponse(graphDb.getStoreId(),graphDb.getXaDataSourceManager(),context,response,filter);
      }
      @Override public void pushTransaction(      String resourceName,      int eventIdentifier,      long tx,      int machineId){
        graphDb.getTxIdGenerator().committed(graphDb.getXaDataSourceManager().getXaDataSource(resourceName),eventIdentifier,tx,machineId);
      }
    }
;
    MasterImpl masterImpl=new MasterImpl(spi,logging,config);
    MasterServer masterServer=new MasterServer(masterImpl,logging,serverConfig(),new BranchDetectingTxVerifier(graphDb));
    life.add(masterImpl);
    life.add(masterServer);
    delegateHandler.setDelegate(masterImpl);
    idGeneratorFactory.switchToMaster();
    life.start();
    URI haUri=URI.create("ha://" + masterServer.getSocketAddress().getHostName() + ":"+ masterServer.getSocketAddress().getPort()+ "?serverId="+ config.get(ClusterSettings.server_id));
    clusterMemberAvailability.memberIsAvailable(MASTER,haUri);
    msgLog.logMessage("I am " + config.get(ClusterSettings.server_id) + ", successfully moved to master");
  }
 catch (  Throwable e) {
    msgLog.logMessage("Failed to switch to master",e);
    return;
  }
}
