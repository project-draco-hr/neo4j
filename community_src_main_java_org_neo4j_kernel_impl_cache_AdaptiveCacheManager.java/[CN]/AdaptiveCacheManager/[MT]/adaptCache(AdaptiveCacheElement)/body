{
  long max=Runtime.getRuntime().maxMemory();
  long total=Runtime.getRuntime().totalMemory();
  long free=Runtime.getRuntime().freeMemory();
  float ratio=(float)(max - free) / max;
  float allocationRatio=(float)total / max;
  if (allocationRatio < element.getRatio()) {
    ratio=0;
  }
  if (ratio > element.getRatio()) {
    Cache<?,?> cache=element.getCache();
    int newCacheSize=(int)(cache.maxSize() / decreaseRatio / (1 + (ratio - element.getRatio())));
    int minSize=element.minSize();
    if (newCacheSize < minSize) {
      log.fine("Cache[" + cache.getName() + "] cannot decrease under "+ minSize+ " (allocation ratio="+ allocationRatio+ " threshold status="+ ratio+ ")");
      cache.resize(minSize);
      cache.resize(minSize + 1000);
      return;
    }
    if (newCacheSize + 1200 > cache.size()) {
      if (cache.size() - 1200 >= minSize) {
        newCacheSize=cache.size() - 1200;
      }
 else {
        newCacheSize=minSize;
      }
    }
    log.fine("Cache[" + cache.getName() + "] decreasing from "+ cache.size()+ " to "+ newCacheSize+ " (allocation ratio="+ allocationRatio+ " threshold status="+ ratio+ ")");
    if (newCacheSize <= 1000) {
      cache.clear();
    }
 else {
      cache.resize(newCacheSize);
    }
    cache.resize(newCacheSize + 1000);
  }
 else {
    Cache<?,?> cache=element.getCache();
    if (cache.size() / (float)cache.maxSize() < 0.9f) {
      return;
    }
    int newCacheSize=(int)(cache.maxSize() * increaseRatio);
    log.fine("Cache[" + cache.getName() + "] increasing from "+ cache.size()+ " to "+ newCacheSize+ " (allocation ratio="+ allocationRatio+ " threshold status="+ ratio+ ")");
    cache.resize(newCacheSize);
  }
}
