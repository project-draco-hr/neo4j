{
  final org.neo4j.kernel.impl.util.Dependencies dependencies=platformModule.dependencies;
  final Config config=platformModule.config;
  final LogService logging=platformModule.logging;
  final FileSystemAbstraction fileSystem=platformModule.fileSystem;
  final File storeDir=platformModule.storeDir;
  final File clusterStateDirectory=createClusterStateDirectory(storeDir,fileSystem);
  final LifeSupport life=platformModule.life;
  final GraphDatabaseFacade graphDatabaseFacade=platformModule.graphDatabaseFacade;
  LogProvider logProvider=logging.getInternalLogProvider();
  final Supplier<DatabaseHealth> databaseHealthSupplier=dependencies.provideDependency(DatabaseHealth.class);
  CoreDiscoveryService discoveryService=discoveryServiceFactory.coreDiscoveryService(config);
  life.add(dependencies.satisfyDependency(discoveryService));
  final CoreReplicatedContentMarshal marshal=new CoreReplicatedContentMarshal();
  int maxQueueSize=config.get(CoreEdgeClusterSettings.outgoing_queue_size);
  final SenderService senderService=new SenderService(new ExpiryScheduler(platformModule.jobScheduler),new Expiration(SYSTEM_CLOCK),new RaftChannelInitializer(marshal),logProvider,platformModule.monitors,maxQueueSize);
  life.add(senderService);
  final CoreMember myself=new CoreMember(config.get(CoreEdgeClusterSettings.transaction_advertised_address),config.get(CoreEdgeClusterSettings.raft_advertised_address));
  final MessageLogger<AdvertisedSocketAddress> messageLogger;
  if (config.get(CoreEdgeClusterSettings.raft_messages_log_enable)) {
    messageLogger=new BetterMessageLogger<>(myself.getRaftAddress(),raftMessagesLog(storeDir));
  }
 else {
    messageLogger=new NullMessageLogger<>();
  }
  LoggingOutbound<AdvertisedSocketAddress> loggingOutbound=new LoggingOutbound<>(senderService,myself.getRaftAddress(),messageLogger);
  ListenSocketAddress raftListenAddress=config.get(CoreEdgeClusterSettings.raft_listen_address);
  RaftServer<CoreMember> raftServer=new RaftServer<>(marshal,raftListenAddress,logProvider);
  final DelayedRenewableTimeoutService raftTimeoutService=new DelayedRenewableTimeoutService(SYSTEM_CLOCK,logProvider);
  RaftLog underlyingLog=createRaftLog(config,life,fileSystem,clusterStateDirectory,marshal,logProvider,databaseHealthSupplier);
  MonitoredRaftLog monitoredRaftLog=new MonitoredRaftLog(underlyingLog,platformModule.monitors);
  StateMachines stateMachines=new StateMachines();
  StateMachineApplier recoverableStateMachine;
  try {
    DurableStateStorage<LastAppliedState> lastAppliedStorage=life.add(new DurableStateStorage<>(fileSystem,new File(clusterStateDirectory,"last-applied-state"),"last-applied",new LastAppliedState.Marshal(),config.get(CoreEdgeClusterSettings.last_applied_state_size),databaseHealthSupplier,logProvider));
    ExecutorService applyExecutor=Executors.newSingleThreadExecutor();
    life.add(new ExecutorServiceLifecycleAdapter(applyExecutor));
    recoverableStateMachine=new StateMachineApplier(stateMachines,monitoredRaftLog,lastAppliedStorage,applyExecutor,config.get(CoreEdgeClusterSettings.state_machine_flush_window_size),databaseHealthSupplier,logProvider);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  raft=createRaft(life,loggingOutbound,discoveryService,config,messageLogger,monitoredRaftLog,recoverableStateMachine,fileSystem,clusterStateDirectory,myself,logProvider,raftServer,raftTimeoutService,databaseHealthSupplier,platformModule.monitors);
  dependencies.satisfyDependency(raft);
  RaftReplicator<CoreMember> replicator=new RaftReplicator<>(raft,myself,new RaftOutbound(loggingOutbound));
  LocalSessionPool localSessionPool=new LocalSessionPool(myself);
  StateStorage<ReplicatedLockTokenState<CoreMember>> lockTokenState;
  try {
    lockTokenState=life.add(new DurableStateStorage<>(fileSystem,new File(clusterStateDirectory,"lock-token-state"),"lock-token",new ReplicatedLockTokenState.Marshal<>(new CoreMemberMarshal()),config.get(CoreEdgeClusterSettings.replicated_lock_token_state_size),databaseHealthSupplier,logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  ReplicatedLockTokenStateMachine<CoreMember> replicatedLockTokenStateMachine=new ReplicatedLockTokenStateMachine<>(lockTokenState);
  stateMachines.add(replicatedLockTokenStateMachine);
  StateStorage<GlobalSessionTrackerState<CoreMember>> sessionTrackerStorage;
  try {
    sessionTrackerStorage=life.add(new DurableStateStorage<>(fileSystem,new File(clusterStateDirectory,"session-tracker-state"),"session-tracker",new GlobalSessionTrackerState.Marshal<>(new CoreMemberMarshal()),config.get(CoreEdgeClusterSettings.global_session_tracker_state_size),databaseHealthSupplier,logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  commitProcessFactory=createCommitProcessFactory(replicator,localSessionPool,replicatedLockTokenStateMachine,dependencies,logging,platformModule.monitors,sessionTrackerStorage,stateMachines);
  final StateStorage<IdAllocationState> idAllocationState;
  try {
    idAllocationState=life.add(new DurableStateStorage<>(fileSystem,new File(clusterStateDirectory,"id-allocation-state"),"id-allocation",new IdAllocationState.Marshal(),config.get(CoreEdgeClusterSettings.id_alloc_state_size),databaseHealthSupplier,logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  ReplicatedIdAllocationStateMachine idAllocationStateMachine=new ReplicatedIdAllocationStateMachine(myself,idAllocationState,logProvider);
  stateMachines.add(idAllocationStateMachine);
  ReplicatedIdRangeAcquirer idRangeAcquirer=new ReplicatedIdRangeAcquirer(replicator,idAllocationStateMachine,1024,1000,myself,logProvider);
  long electionTimeout=config.get(CoreEdgeClusterSettings.leader_election_timeout);
  MembershipWaiter<CoreMember> membershipWaiter=new MembershipWaiter<>(myself,platformModule.jobScheduler,electionTimeout * 4,logProvider);
  ReplicatedIdGeneratorFactory replicatedIdGeneratorFactory=createIdGeneratorFactory(fileSystem,idRangeAcquirer,logProvider);
  this.idGeneratorFactory=dependencies.satisfyDependency(replicatedIdGeneratorFactory);
  dependencies.satisfyDependency(new IdBasedStoreEntityCounters(this.idGeneratorFactory));
  Long tokenCreationTimeout=config.get(CoreEdgeClusterSettings.token_creation_timeout);
  ReplicatedRelationshipTypeTokenHolder relationshipTypeTokenHolder=new ReplicatedRelationshipTypeTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  ReplicatedPropertyKeyTokenHolder propertyKeyTokenHolder=new ReplicatedPropertyKeyTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  ReplicatedLabelTokenHolder labelTokenHolder=new ReplicatedLabelTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  stateMachines.add(labelTokenHolder);
  stateMachines.add(relationshipTypeTokenHolder);
  stateMachines.add(propertyKeyTokenHolder);
  LifeSupport tokenLife=new LifeSupport();
  this.relationshipTypeTokenHolder=tokenLife.add(relationshipTypeTokenHolder);
  this.propertyKeyTokenHolder=tokenLife.add(propertyKeyTokenHolder);
  this.labelTokenHolder=tokenLife.add(labelTokenHolder);
  dependencies.satisfyDependency(createKernelData(fileSystem,platformModule.pageCache,storeDir,config,graphDatabaseFacade,life));
  dependencies.satisfyDependencies(createAuthManager(config,life,logging.getUserLogProvider()));
  headerInformationFactory=createHeaderInformationFactory();
  schemaWriteGuard=createSchemaWriteGuard();
  transactionStartTimeout=config.get(GraphDatabaseSettings.transaction_start_timeout);
  constraintSemantics=new EnterpriseConstraintSemantics();
  coreAPIAvailabilityGuard=new CoreAPIAvailabilityGuard(platformModule.availabilityGuard,transactionStartTimeout);
  registerRecovery(platformModule.databaseInfo,life,dependencies);
  publishEditionInfo(dependencies.resolveDependency(UsageData.class),platformModule.databaseInfo,config);
  ExpiryScheduler expiryScheduler=new ExpiryScheduler(platformModule.jobScheduler);
  Expiration expiration=new Expiration(SYSTEM_CLOCK);
  CoreToCoreClient.ChannelInitializer channelInitializer=new CoreToCoreClient.ChannelInitializer(logProvider);
  CoreToCoreClient coreToCoreClient=life.add(new CoreToCoreClient(logProvider,expiryScheduler,expiration,channelInitializer,platformModule.monitors,maxQueueSize));
  channelInitializer.setOwner(coreToCoreClient);
  long leaderLockTokenTimeout=config.get(CoreEdgeClusterSettings.leader_lock_token_timeout);
  lockManager=dependencies.satisfyDependency(createLockManager(config,logging,replicator,myself,replicatedLockTokenStateMachine,raft,leaderLockTokenTimeout));
  CatchupServer catchupServer=new CatchupServer(logProvider,new StoreIdSupplier(platformModule),platformModule.dependencies.provideDependency(TransactionIdStore.class),platformModule.dependencies.provideDependency(LogicalTransactionStore.class),new DataSourceSupplier(platformModule),new CheckpointerSupplier(platformModule.dependencies),config.get(CoreEdgeClusterSettings.transaction_listen_address),platformModule.monitors);
  long joinCatchupTimeout=config.get(CoreEdgeClusterSettings.join_catch_up_timeout);
  life.add(CoreServerStartupProcess.createLifeSupport(platformModule.dataSourceManager,replicatedIdGeneratorFactory,raft,recoverableStateMachine,raftServer,catchupServer,raftTimeoutService,membershipWaiter,joinCatchupTimeout,new RecoverTransactionLogState(dependencies,logProvider,relationshipTypeTokenHolder,propertyKeyTokenHolder,labelTokenHolder),tokenLife));
}
