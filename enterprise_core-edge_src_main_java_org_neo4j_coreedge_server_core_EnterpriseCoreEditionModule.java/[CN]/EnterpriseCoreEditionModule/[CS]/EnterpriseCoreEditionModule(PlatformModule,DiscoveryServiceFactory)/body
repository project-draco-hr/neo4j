{
  final org.neo4j.kernel.impl.util.Dependencies dependencies=platformModule.dependencies;
  final Config config=platformModule.config;
  final LogService logging=platformModule.logging;
  final FileSystemAbstraction fileSystem=platformModule.fileSystem;
  final File storeDir=platformModule.storeDir;
  final File clusterStateDirectory=createClusterStateDirectory(storeDir,fileSystem);
  final LifeSupport life=platformModule.life;
  final GraphDatabaseFacade graphDatabaseFacade=platformModule.graphDatabaseFacade;
  LogProvider logProvider=logging.getInternalLogProvider();
  final Supplier<DatabaseHealth> databaseHealthSupplier=dependencies.provideDependency(DatabaseHealth.class);
  CoreDiscoveryService discoveryService=discoveryServiceFactory.coreDiscoveryService(config);
  life.add(dependencies.satisfyDependency(discoveryService));
  final CoreReplicatedContentMarshal marshal=new CoreReplicatedContentMarshal();
  int maxQueueSize=config.get(CoreEdgeClusterSettings.outgoing_queue_size);
  final SenderService senderService=new SenderService(new ExpiryScheduler(platformModule.jobScheduler),new Expiration(SYSTEM_CLOCK),new RaftChannelInitializer(marshal),logProvider,platformModule.monitors,maxQueueSize);
  life.add(senderService);
  final CoreMember myself=new CoreMember(config.get(CoreEdgeClusterSettings.transaction_advertised_address),config.get(CoreEdgeClusterSettings.raft_advertised_address));
  final MessageLogger<AdvertisedSocketAddress> messageLogger=new BetterMessageLogger<>(myself.getRaftAddress(),raftMessagesLog(storeDir));
  LoggingOutbound<AdvertisedSocketAddress> loggingOutbound=new LoggingOutbound<>(senderService,myself.getRaftAddress(),messageLogger);
  ListenSocketAddress raftListenAddress=config.get(CoreEdgeClusterSettings.raft_listen_address);
  RaftServer<CoreMember> raftServer=new RaftServer<>(marshal,raftListenAddress,logProvider);
  final DelayedRenewableTimeoutService raftTimeoutService=new DelayedRenewableTimeoutService(SYSTEM_CLOCK,logProvider);
  NaiveDurableRaftLog raftLog=life.add(new NaiveDurableRaftLog(fileSystem,new File(clusterStateDirectory,NaiveDurableRaftLog.DIRECTORY_NAME),new RaftContentSerializer(),logProvider));
  MonitoredRaftLog monitoredRaftLog=new MonitoredRaftLog(raftLog,platformModule.monitors);
  TermState termState;
  try {
    OnDiskTermState onDiskTermState=life.add(new OnDiskTermState(fileSystem,new File(clusterStateDirectory,OnDiskTermState.DIRECTORY_NAME),config.get(CoreEdgeClusterSettings.term_state_size),databaseHealthSupplier,logProvider));
    termState=new MonitoredTermState(onDiskTermState,platformModule.monitors);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  VoteState<CoreMember> voteState;
  try {
    voteState=life.add(new OnDiskVoteState<>(fileSystem,new File(clusterStateDirectory,OnDiskVoteState.DIRECTORY_NAME),config.get(CoreEdgeClusterSettings.vote_state_size),databaseHealthSupplier,new CoreMemberMarshal(),logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  RaftMembershipState<CoreMember> raftMembershipState;
  try {
    raftMembershipState=life.add(new OnDiskRaftMembershipState<>(fileSystem,new File(clusterStateDirectory,OnDiskRaftMembershipState.DIRECTORY_NAME),config.get(CoreEdgeClusterSettings.raft_membership_state_size),databaseHealthSupplier,new CoreMemberMarshal(),logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  raft=createRaft(life,loggingOutbound,discoveryService,config,messageLogger,monitoredRaftLog,termState,voteState,myself,logProvider,raftServer,raftTimeoutService,databaseHealthSupplier,raftMembershipState,platformModule.monitors);
  dependencies.satisfyDependency(raft);
  dependencies.satisfyDependency(raft);
  RaftReplicator<CoreMember> replicator=new RaftReplicator<>(raft,myself,new RaftOutbound(loggingOutbound));
  LocalSessionPool localSessionPool=new LocalSessionPool(myself);
  OnDiskReplicatedLockTokenState<CoreMember> onDiskReplicatedLockTokenState;
  try {
    onDiskReplicatedLockTokenState=life.add(new OnDiskReplicatedLockTokenState<>(fileSystem,new File(clusterStateDirectory,OnDiskReplicatedLockTokenState.DIRECTORY_NAME),config.get(CoreEdgeClusterSettings.replicated_lock_token_state_size),new CoreMember.CoreMemberMarshal(),databaseHealthSupplier,logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  ReplicatedLockTokenStateMachine<CoreMember> replicatedLockTokenStateMachine=new ReplicatedLockTokenStateMachine<>(replicator,onDiskReplicatedLockTokenState);
  OnDiskGlobalSessionTrackerState<CoreMember> onDiskGlobalSessionTrackerState;
  try {
    onDiskGlobalSessionTrackerState=new OnDiskGlobalSessionTrackerState<>(fileSystem,new File(clusterStateDirectory,OnDiskGlobalSessionTrackerState.DIRECTORY_NAME),new CoreMemberMarshal(),config.get(CoreEdgeClusterSettings.global_session_tracker_state_size),databaseHealthSupplier,logProvider);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  commitProcessFactory=createCommitProcessFactory(replicator,localSessionPool,replicatedLockTokenStateMachine,dependencies,logging,platformModule.monitors,onDiskGlobalSessionTrackerState);
  final IdAllocationState idAllocationState;
  try {
    idAllocationState=life.add(new OnDiskIdAllocationState(fileSystem,new File(clusterStateDirectory,OnDiskIdAllocationState.DIRECTORY_NAME),config.get(CoreEdgeClusterSettings.id_alloc_state_size),databaseHealthSupplier,logProvider));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  ReplicatedIdAllocationStateMachine idAllocationStateMachine=new ReplicatedIdAllocationStateMachine(myself,idAllocationState,logProvider);
  replicator.subscribe(idAllocationStateMachine);
  ReplicatedIdRangeAcquirer idRangeAcquirer=new ReplicatedIdRangeAcquirer(replicator,idAllocationStateMachine,1024,1000,myself,logProvider);
  monitoredRaftLog.registerListener(replicator);
  long electionTimeout=config.get(CoreEdgeClusterSettings.leader_election_timeout);
  MembershipWaiter<CoreMember> membershipWaiter=new MembershipWaiter<>(myself,platformModule.jobScheduler,electionTimeout * 4,logProvider);
  ReplicatedIdGeneratorFactory replicatedIdGeneratorFactory=createIdGeneratorFactory(fileSystem,idRangeAcquirer,logProvider);
  this.idGeneratorFactory=dependencies.satisfyDependency(replicatedIdGeneratorFactory);
  dependencies.satisfyDependency(new IdBasedStoreEntityCounters(this.idGeneratorFactory));
  Long tokenCreationTimeout=config.get(CoreEdgeClusterSettings.token_creation_timeout);
  ReplicatedRelationshipTypeTokenHolder relationshipTypeTokenHolder=new ReplicatedRelationshipTypeTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  ReplicatedPropertyKeyTokenHolder propertyKeyTokenHolder=new ReplicatedPropertyKeyTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  ReplicatedLabelTokenHolder labelTokenHolder=new ReplicatedLabelTokenHolder(replicator,this.idGeneratorFactory,dependencies,tokenCreationTimeout,logProvider);
  LifeSupport tokenLife=new LifeSupport();
  this.relationshipTypeTokenHolder=tokenLife.add(relationshipTypeTokenHolder);
  this.propertyKeyTokenHolder=tokenLife.add(propertyKeyTokenHolder);
  this.labelTokenHolder=tokenLife.add(labelTokenHolder);
  dependencies.satisfyDependency(createKernelData(fileSystem,platformModule.pageCache,storeDir,config,graphDatabaseFacade,life));
  headerInformationFactory=createHeaderInformationFactory();
  schemaWriteGuard=createSchemaWriteGuard();
  transactionStartTimeout=config.get(GraphDatabaseSettings.transaction_start_timeout);
  constraintSemantics=new EnterpriseConstraintSemantics();
  registerRecovery(platformModule.databaseInfo,life,dependencies);
  publishEditionInfo(dependencies.resolveDependency(UsageData.class),platformModule.databaseInfo,config);
  ExpiryScheduler expiryScheduler=new ExpiryScheduler(platformModule.jobScheduler);
  Expiration expiration=new Expiration(SYSTEM_CLOCK);
  CoreToCoreClient.ChannelInitializer channelInitializer=new CoreToCoreClient.ChannelInitializer(logProvider);
  CoreToCoreClient coreToCoreClient=life.add(new CoreToCoreClient(logProvider,expiryScheduler,expiration,channelInitializer,platformModule.monitors,maxQueueSize));
  channelInitializer.setOwner(coreToCoreClient);
  long leaderLockTokenTimeout=config.get(CoreEdgeClusterSettings.leader_lock_token_timeout);
  lockManager=dependencies.satisfyDependency(createLockManager(config,logging,replicator,myself,replicatedLockTokenStateMachine,raft,leaderLockTokenTimeout));
  CatchupServer catchupServer=new CatchupServer(logProvider,new StoreIdSupplier(platformModule),platformModule.dependencies.provideDependency(TransactionIdStore.class),platformModule.dependencies.provideDependency(LogicalTransactionStore.class),new DataSourceSupplier(platformModule),new CheckpointerSupplier(platformModule.dependencies),config.get(CoreEdgeClusterSettings.transaction_listen_address),platformModule.monitors);
  life.add(CoreServerStartupProcess.createLifeSupport(platformModule.dataSourceManager,replicatedIdGeneratorFactory,raft,new RaftLogReplay(monitoredRaftLog,logProvider),raftServer,catchupServer,raftTimeoutService,membershipWaiter,config.get(CoreEdgeClusterSettings.join_catch_up_timeout),new RecoverTransactionLogState(dependencies,logProvider,relationshipTypeTokenHolder,propertyKeyTokenHolder,labelTokenHolder),tokenLife));
}
