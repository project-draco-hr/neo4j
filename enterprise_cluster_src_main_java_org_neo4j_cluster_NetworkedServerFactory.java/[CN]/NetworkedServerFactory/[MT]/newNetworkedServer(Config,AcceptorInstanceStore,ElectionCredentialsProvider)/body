{
  final NetworkReceiver receiver=new NetworkReceiver(networkReceiverMonitor,new NetworkReceiver.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.get(ClusterSettings.cluster_server);
    }
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public String name(){
      return null;
    }
  }
,logging);
  final NetworkSender sender=new NetworkSender(networkSenderMonitor,new NetworkSender.Configuration(){
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public int port(){
      return config.get(ClusterSettings.cluster_server).getPort();
    }
  }
,receiver,logging);
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine",namedThreadFactoryMonitor));
    }
  }
);
  final ProtocolServer protocolServer=protocolServerFactory.newProtocolServer(config.get(ClusterSettings.server_id),config.get(ClusterSettings.max_acceptors),timeoutStrategy,receiver,sender,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor,objectInputStreamFactory,objectOutputStreamFactory);
  receiver.addNetworkChannelsListener(new NetworkReceiver.NetworkChannelsListener(){
    private StateTransitionLogger logger;
    @Override public void listeningAt(    URI me){
      protocolServer.listeningAt(me);
      if (logger == null) {
        logger=new StateTransitionLogger(logging);
        protocolServer.addStateTransitionListener(logger);
      }
    }
    @Override public void channelOpened(    URI to){
    }
    @Override public void channelClosed(    URI to){
    }
  }
);
  life.add(stateMachineExecutor);
  life.add(new Lifecycle(){
    private ScheduledExecutorService scheduler;
    @Override public void init() throws Throwable {
      protocolServer.getTimeouts().tick(System.currentTimeMillis());
    }
    @Override public void start() throws Throwable {
      scheduler=Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("timeout"));
      scheduler.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          long now=System.currentTimeMillis();
          protocolServer.getTimeouts().tick(now);
        }
      }
,0,10,TimeUnit.MILLISECONDS);
    }
    @Override public void stop() throws Throwable {
      scheduler.shutdownNow();
    }
    @Override public void shutdown() throws Throwable {
    }
  }
);
  life.add(sender);
  life.add(receiver);
  return protocolServer;
}
