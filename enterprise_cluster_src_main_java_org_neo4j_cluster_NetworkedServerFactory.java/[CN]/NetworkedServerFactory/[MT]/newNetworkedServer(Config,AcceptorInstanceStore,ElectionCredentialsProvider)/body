{
  final NetworkInstance node=new NetworkInstance(new NetworkInstance.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.get(ClusterSettings.cluster_server);
    }
    @Override public int defaultPort(){
      return 5001;
    }
  }
,logging);
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine"));
    }
  }
);
  final ProtocolServer protocolServer=protocolServerFactory.newProtocolServer(timeoutStrategy,node,node,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor);
  node.addNetworkChannelsListener(new NetworkInstance.NetworkChannelsListener(){
    @Override public void listeningAt(    URI me){
      protocolServer.listeningAt(me);
      protocolServer.addStateTransitionListener(new StateTransitionLogger(logging));
    }
    @Override public void channelOpened(    URI to){
    }
    @Override public void channelClosed(    URI to){
    }
  }
);
  life.add(stateMachineExecutor);
  life.add(new Lifecycle(){
    private ScheduledExecutorService scheduler;
    @Override public void init() throws Throwable {
      protocolServer.getTimeouts().tick(System.currentTimeMillis());
    }
    @Override public void start() throws Throwable {
      scheduler=Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory("timeout"));
      scheduler.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          long now=System.currentTimeMillis();
          protocolServer.getTimeouts().tick(now);
        }
      }
,0,10,TimeUnit.MILLISECONDS);
    }
    @Override public void stop() throws Throwable {
      scheduler.shutdownNow();
    }
    @Override public void shutdown() throws Throwable {
    }
  }
);
  life.add(node);
  return protocolServer;
}
