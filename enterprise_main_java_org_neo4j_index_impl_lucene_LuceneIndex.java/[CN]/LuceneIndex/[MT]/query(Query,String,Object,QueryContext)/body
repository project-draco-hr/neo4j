{
  List<Long> ids=new ArrayList<Long>();
  LuceneXaConnection con=getReadOnlyConnection();
  LuceneTransaction luceneTx=con != null ? con.getLuceneTx() : null;
  Collection<Long> addedIds=Collections.emptySet();
  Collection<Long> removedIds=Collections.emptySet();
  if (luceneTx != null) {
    addedIds=keyForDirectLookup != null ? luceneTx.getAddedIds(this,keyForDirectLookup,valueForDirectLookup) : luceneTx.getAddedIds(this,query,additionalParametersOrNull);
    ids.addAll(addedIds);
    removedIds=keyForDirectLookup != null ? luceneTx.getRemovedIds(this,keyForDirectLookup,valueForDirectLookup) : luceneTx.getRemovedIds(this,query);
  }
  service.dataSource().getReadLock();
  IndexHits<Long> idIterator=null;
  IndexSearcherRef searcher=null;
  try {
    searcher=service.dataSource().getIndexSearcher(identifier,true);
    if (searcher != null) {
      boolean foundInCache=false;
      LruCache<String,Collection<Long>> cachedIdsMap=null;
      if (keyForDirectLookup != null) {
        cachedIdsMap=service.dataSource().getFromCache(identifier,keyForDirectLookup);
        foundInCache=fillFromCache(cachedIdsMap,ids,keyForDirectLookup,valueForDirectLookup.toString(),removedIds);
      }
      if (!foundInCache) {
        DocToIdIterator searchedIds=new DocToIdIterator(search(searcher,query,additionalParametersOrNull),removedIds,searcher);
        if (ids.isEmpty()) {
          idIterator=searchedIds;
        }
 else {
          Collection<IndexHits<Long>> iterators=new ArrayList<IndexHits<Long>>();
          iterators.add(searchedIds);
          iterators.add(new ConstantScoreIterator<Long>(ids,Float.NaN));
          idIterator=new CombinedIndexHits<Long>(iterators);
        }
      }
    }
  }
  finally {
    service.dataSource().releaseReadLock();
  }
  idIterator=idIterator == null ? new ConstantScoreIterator<Long>(ids,0) : idIterator;
  return new IdToEntityIterator<T>(idIterator){
    @Override protected T underlyingObjectToObject(    Long id){
      return getById(id);
    }
    protected void itemDodged(    Long item){
      abandonedIds.add(item);
    }
  }
;
}
