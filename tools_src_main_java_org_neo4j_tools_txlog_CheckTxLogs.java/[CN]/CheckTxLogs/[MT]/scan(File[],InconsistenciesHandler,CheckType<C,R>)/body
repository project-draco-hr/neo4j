{
  out.println("Checking logs for " + check.name() + " inconsistencies");
  CommittedRecords<R> state=new CommittedRecords<>(check);
  List<CommandAndLogVersion> txCommands=new ArrayList<>();
  boolean validLogs=true;
  for (  File log : logs) {
    long commandsRead=0;
    long logVersion=PhysicalLogFiles.getLogVersion(log);
    try (LogEntryCursor logEntryCursor=LogTestUtils.openLog(fs,log)){
      while (logEntryCursor.next()) {
        LogEntry entry=logEntryCursor.get();
        if (entry instanceof LogEntryCommand) {
          StorageCommand command=((LogEntryCommand)entry).getXaCommand();
          if (check.commandClass().isInstance(command)) {
            txCommands.add(new CommandAndLogVersion(command,logVersion));
          }
        }
 else         if (entry instanceof LogEntryCommit) {
          long txId=((LogEntryCommit)entry).getTxId();
          for (          CommandAndLogVersion txCommand : txCommands) {
            validLogs&=checkAndHandleInconsistencies(txCommand,check,state,txId,handler);
          }
          txCommands.clear();
        }
        commandsRead++;
      }
    }
     out.println("Processed " + log.getCanonicalPath() + " with "+ commandsRead+ " commands");
    out.println(state);
  }
  if (!txCommands.isEmpty()) {
    out.println("Found " + txCommands.size() + " uncommitted commands at the end.");
    for (    CommandAndLogVersion txCommand : txCommands) {
      validLogs&=checkAndHandleInconsistencies(txCommand,check,state,-1,handler);
    }
    txCommands.clear();
  }
  return validLogs;
}
