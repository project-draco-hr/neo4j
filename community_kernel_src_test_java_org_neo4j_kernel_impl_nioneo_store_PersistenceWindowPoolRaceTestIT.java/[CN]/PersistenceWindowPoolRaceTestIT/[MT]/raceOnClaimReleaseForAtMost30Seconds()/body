{
  ExecutorService executor=Executors.newCachedThreadPool();
  File file=new File(testDir.directory(),"test.file.db");
  file.deleteOnExit();
  int blockSize=512;
  int maxId=10000;
  RandomAccessFile raf=new RandomAccessFile(file,"rw");
  FileChannel fileChannel=raf.getChannel();
  setSize(fileChannel,blockSize * maxId);
  long mappedMem=blockSize + (blockSize * (maxId / 10)) + (blockSize / 2);
  boolean useMemoryMappedBuffers=true;
  boolean readOnly=false;
  ConcurrentMap<Long,PersistenceRow> activeRowWindows=new ConcurrentHashMap<Long,PersistenceRow>();
  BrickElementFactory brickFactory=BrickElementFactory.DEFAULT;
  StringLogger log=StringLogger.SYSTEM;
  PersistenceWindowPool pwp=new PersistenceWindowPool(file,blockSize,new StoreFileChannel(fileChannel),mappedMem,useMemoryMappedBuffers,readOnly,activeRowWindows,brickFactory,log);
  for (int i=0; i <= 9; i++) {
    PersistenceWindow window=pwp.acquire(i * 10,OperationType.WRITE);
    pwp.release(window);
  }
  AtomicReference<Throwable> mailbox=new AtomicReference<Throwable>();
  AcquireReleaseJob[] jobs=new AcquireReleaseJob[]{new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox),new AcquireReleaseJob(pwp,maxId,mailbox)};
  for (  AcquireReleaseJob job : jobs) {
    executor.submit(job);
  }
  long deadline=System.currentTimeMillis() + 30000;
  Throwable observedFailure;
  do {
    Thread.sleep(100);
    observedFailure=mailbox.get();
  }
 while (observedFailure == null && System.currentTimeMillis() < deadline);
  executor.shutdown();
  mailbox.compareAndSet(null,STOP_SIGNAL);
  if (observedFailure != null) {
    throw observedFailure;
  }
}
