{
  long deadline=System.currentTimeMillis() + maxWaitTimeMillis;
  AbstractLockService.LockedNode targetLock=new AbstractLockService.LockedNode(lockedNodeId);
  Thread thread=null;
  ThreadGroup group=Thread.currentThread().getThreadGroup();
  while (group.getParent() != null) {
    group=group.getParent();
  }
  Thread[] threads=new Thread[100];
  int snapshotCount=0;
  while (thread == null && System.currentTimeMillis() < deadline) {
    if (snapshotCount == threads.length) {
      threads=new Thread[threads.length * 2];
    }
    snapshotCount=group.enumerate(threads);
    for (int i=0; i < snapshotCount; i++) {
      Thread candidate=threads[i];
      Object blocker=LockSupport.getBlocker(candidate);
      if (blocker instanceof AbstractLockService.LockedNode) {
        AbstractLockService.LockedNode lockedNode=(AbstractLockService.LockedNode)blocker;
        if (lockedNode.equals(targetLock)) {
          thread=candidate;
          break;
        }
      }
    }
  }
  if (thread == null) {
    throw new AssertionError("Found no thread blocked on " + targetLock);
  }
  return thread;
}
