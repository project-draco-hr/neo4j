{
  List<ConsistencyCheckerTask> tasks=new ArrayList<>();
  if (checkGraph) {
    MandatoryProperties mandatoryProperties=new MandatoryProperties(nativeStores);
    StoreProcessor processor=multiPass.processor(CheckStage.Stage1_NS_PropsLabels,PROPERTIES);
    tasks.add(create(CheckStage.Stage1_NS_PropsLabels.name(),nativeStores.getNodeStore(),processor,ROUND_ROBIN));
    processor=multiPass.processor(CheckStage.Stage2_RS_Labels,LABELS);
    multiPass.reDecorateRelationship(processor,RelationshipRecordCheck.relationshipRecordCheckForwardPass());
    tasks.add(create(CheckStage.Stage2_RS_Labels.name(),nativeStores.getRelationshipStore(),processor,ROUND_ROBIN));
    tasks.add(new CacheTask.CacheNextRel(CheckStage.Stage3_NS_NextRel,cacheAccess,Scanner.scan(nativeStores.getNodeStore())));
    processor=multiPass.processor(CheckStage.Stage4_RS_NextRel,NODES);
    multiPass.reDecorateRelationship(processor,RelationshipRecordCheck.relationshipRecordCheckBackwardPass(new PropertyChain<>(mandatoryProperties.forRelationships(reporter))));
    tasks.add(create(CheckStage.Stage4_RS_NextRel.name(),nativeStores.getRelationshipStore(),processor,ROUND_ROBIN));
    multiPass.reDecorateNode(processor,NodeRecordCheck.toCheckNextRel(),true);
    multiPass.reDecorateNode(processor,NodeRecordCheck.toCheckNextRelationshipGroup(),false);
    tasks.add(new CacheTask.CheckNextRel(CheckStage.Stage5_Check_NextRel,cacheAccess,nativeStores,processor));
    processor=multiPass.processor(CheckStage.Stage6_RS_Forward,RELATIONSHIPS);
    multiPass.reDecorateRelationship(processor,RelationshipRecordCheck.relationshipRecordCheckSourceChain());
    tasks.add(create(CheckStage.Stage6_RS_Forward.name(),nativeStores.getRelationshipStore(),processor,QueueDistribution.RELATIONSHIPS));
    processor=multiPass.processor(CheckStage.Stage7_RS_Backward,RELATIONSHIPS);
    multiPass.reDecorateRelationship(processor,RelationshipRecordCheck.relationshipRecordCheckSourceChain());
    tasks.add(create(CheckStage.Stage7_RS_Backward.name(),nativeStores.getRelationshipStore(),processor,QueueDistribution.RELATIONSHIPS));
    StoreProcessor relGrpProcessor=multiPass.processor(Stage.PARALLEL_FORWARD,RELATIONSHIP_GROUPS);
    tasks.add(create("RelationshipGroupStore-RelGrp",nativeStores.getRelationshipGroupStore(),relGrpProcessor,ROUND_ROBIN));
    PropertyReader propertyReader=new PropertyReader(nativeStores);
    tasks.add(recordScanner(CheckStage.Stage8_PS_Props.name(),new IterableStore<>(nativeStores.getNodeStore(),true),new PropertyAndNode2LabelIndexProcessor(reporter,(checkIndexes ? indexes : null),propertyReader,cacheAccess,mandatoryProperties.forNodes(reporter)),CheckStage.Stage8_PS_Props,ROUND_ROBIN,new IterableStore<>(nativeStores.getPropertyStore(),true)));
    tasks.add(create("StringStore-Str",nativeStores.getStringStore(),multiPass.processor(Stage.SEQUENTIAL_FORWARD,STRINGS),ROUND_ROBIN));
    tasks.add(create("ArrayStore-Arrays",nativeStores.getArrayStore(),multiPass.processor(Stage.SEQUENTIAL_FORWARD,ARRAYS),ROUND_ROBIN));
  }
  tasks.add(create("SchemaStore",nativeStores.getSchemaStore(),ROUND_ROBIN));
  final SchemaRecordCheck schemaCheck=new SchemaRecordCheck(new SchemaStorage(nativeStores.getSchemaStore()));
  tasks.add(new SchemaStoreProcessorTask<>("SchemaStoreProcessor-check_rules",statistics,numberOfThreads,nativeStores.getSchemaStore(),nativeStores,"check_rules",schemaCheck,progress,cacheAccess,defaultProcessor,ROUND_ROBIN));
  tasks.add(new SchemaStoreProcessorTask<>("SchemaStoreProcessor-check_obligations",statistics,numberOfThreads,nativeStores.getSchemaStore(),nativeStores,"check_obligations",schemaCheck.forObligationChecking(),progress,cacheAccess,defaultProcessor,ROUND_ROBIN));
  if (checkGraph) {
    tasks.add(create("RelationshipTypeTokenStore",nativeStores.getRelationshipTypeTokenStore(),ROUND_ROBIN));
    tasks.add(create("PropertyKeyTokenStore",nativeStores.getPropertyKeyTokenStore(),ROUND_ROBIN));
    tasks.add(create("LabelTokenStore",nativeStores.getLabelTokenStore(),ROUND_ROBIN));
    tasks.add(create("RelationshipTypeNameStore",nativeStores.getRelationshipTypeNameStore(),ROUND_ROBIN));
    tasks.add(create("PropertyKeyNameStore",nativeStores.getPropertyKeyNameStore(),ROUND_ROBIN));
    tasks.add(create("LabelNameStore",nativeStores.getLabelNameStore(),ROUND_ROBIN));
    tasks.add(create("NodeDynamicLabelStore",nativeStores.getNodeDynamicLabelStore(),ROUND_ROBIN));
  }
  if (checkLabelScanStore) {
    tasks.add(recordScanner("NodeStoreToLabelScanStore",new IterableStore<>(nativeStores.getNodeStore(),true),new NodeToLabelScanRecordProcessor(reporter,labelScanStore),CheckStage.Stage9_NS_LabelCounts,ROUND_ROBIN));
  }
  ConsistencyReporter filteredReporter=multiPass.reporter(NODES);
  if (checkLabelScanStore) {
    tasks.add(recordScanner("LabelScanStore",labelScanStore.allNodeLabelRanges(),new LabelScanDocumentProcessor(filteredReporter,new LabelScanCheck()),Stage.SEQUENTIAL_FORWARD,ROUND_ROBIN));
  }
  if (checkIndexes) {
    for (    IndexRule indexRule : indexes.rules()) {
      tasks.add(recordScanner(format("Index_%d",indexRule.getId()),new IndexIterator(indexes.accessorFor(indexRule)),new IndexEntryProcessor(filteredReporter,new IndexCheck(indexRule)),Stage.SEQUENTIAL_FORWARD,ROUND_ROBIN));
    }
  }
  return tasks;
}
