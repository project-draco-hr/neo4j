{
  try {
    Throwable commitFailureCause=null;
    int xaErrorCode=-1;
    if (tx.getResourceCount() == 0) {
      tx.setStatus(Status.STATUS_COMMITTED);
    }
 else {
      try {
        tx.doCommit();
      }
 catch (      XAException e) {
        xaErrorCode=e.errorCode;
        e.printStackTrace();
        log.severe("Commit failed, status=" + getTxStatusAsString(tx.getStatus()) + ", errorCode="+ xaErrorCode);
        if (tx.getStatus() == Status.STATUS_COMMITTED) {
          setTmNotOk();
          throw new TransactionFailureException("commit threw exception but status is committed?",e);
        }
      }
catch (      Throwable t) {
        t.printStackTrace();
        commitFailureCause=t;
      }
    }
    if (tx.getStatus() != Status.STATUS_COMMITTED) {
      try {
        tx.doRollback();
      }
 catch (      XAException e) {
        e.printStackTrace();
        log.severe("Unable to rollback transaction. " + "Some resources may be commited others not. " + "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->");
        setTmNotOk();
        if (commitFailureCause != null) {
          commitFailureCause.printStackTrace();
        }
        throw new HeuristicMixedException("Unable to rollback ---> error code in commit: " + xaErrorCode + " ---> error code for rollback: "+ e.errorCode);
      }
      tx.doAfterCompletion();
      txThreadMap.remove(thread);
      try {
        if (tx.isGlobalStartRecordWritten()) {
          getTxLog().txDone(tx.getGlobalId());
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        log.severe("Error writing transaction log");
        setTmNotOk();
        throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
      }
      tx.setStatus(Status.STATUS_NO_TRANSACTION);
      if (commitFailureCause == null) {
        throw new HeuristicRollbackException("Failed to commit, transaction rolledback ---> " + "error code was: " + xaErrorCode);
      }
 else {
        throw new HeuristicRollbackException("Failed to commit, transaction rolledback ---> " + commitFailureCause);
      }
    }
    tx.doAfterCompletion();
    txThreadMap.remove(thread);
    try {
      if (tx.isGlobalStartRecordWritten()) {
        getTxLog().txDone(tx.getGlobalId());
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      log.severe("Error writing transaction log");
      setTmNotOk();
      throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
    }
    tx.setStatus(Status.STATUS_NO_TRANSACTION);
  }
  finally {
    rollbackHook.doneCommitting(tx.getEventIdentifier());
  }
}
