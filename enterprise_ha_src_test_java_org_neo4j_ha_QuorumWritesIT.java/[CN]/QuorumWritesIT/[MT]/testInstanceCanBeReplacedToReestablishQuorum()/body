{
  ManagedCluster cluster=clusterRule.startCluster();
  HighlyAvailableGraphDatabase master=cluster.getMaster();
  doTx(master);
  final CountDownLatch latch1=new CountDownLatch(1);
  waitOnHeartbeatFail(master,latch1);
  HighlyAvailableGraphDatabase slave1=cluster.getAnySlave();
  cluster.fail(slave1);
  latch1.await();
  slave1.shutdown();
  doTx(master);
  final CountDownLatch latch2=new CountDownLatch(1);
  waitOnHeartbeatFail(master,latch2);
  HighlyAvailableGraphDatabase slave2=cluster.getAnySlave(slave1);
  cluster.fail(slave2);
  latch2.await();
  assertFalse(master.isMaster());
  try {
    doTx(master);
    fail("After both slaves fail txs should not go through");
  }
 catch (  TransactionFailureException e) {
    assertEquals("Timeout waiting for cluster to elect master",e.getMessage());
  }
  Thread.sleep(120000);
  final CountDownLatch latch3=new CountDownLatch(1);
  final CountDownLatch latch4=new CountDownLatch(1);
  final CountDownLatch latch5=new CountDownLatch(1);
  waitOnHeartbeatAlive(master,latch3);
  waitOnRoleIsAvailable(master,latch4,HighAvailabilityModeSwitcher.MASTER);
  waitOnRoleIsAvailable(master,latch5,HighAvailabilityModeSwitcher.SLAVE);
  HighlyAvailableGraphDatabase replacement=(HighlyAvailableGraphDatabase)new TestHighlyAvailableGraphDatabaseFactory().newHighlyAvailableDatabaseBuilder(new File(clusterRule.directory("another"),"replacement").getAbsolutePath()).setConfig(ClusterSettings.cluster_server,":5010").setConfig(HaSettings.ha_server,":6010").setConfig(ClusterSettings.server_id,"3").setConfig(ClusterSettings.initial_hosts,cluster.getInitialHostsConfigString()).setConfig(HaSettings.tx_push_factor,"0").newGraphDatabase();
  latch3.await();
  latch4.await();
  latch5.await();
  assertTrue(master.isMaster());
  assertFalse(replacement.isMaster());
  Node finalNode=doTx(master);
  try (Transaction transaction=replacement.beginTx()){
    replacement.getNodeById(finalNode.getId());
  }
   replacement.shutdown();
}
