{
  if (brickMiss < REFRESH_BRICK_COUNT || brickSize <= 0)   return;
synchronized (this) {
    brickMiss=0;
    Pair<List<BrickElement>,List<BrickElement>> currentMappings=gatherMappedVersusUnmappedWindows();
    List<BrickElement> mappedBricks=currentMappings.first();
    List<BrickElement> unmappedBricks=currentMappings.other();
    int unmappedIndex=unmappedBricks.size() - 1;
    while (memUsed + brickSize <= availableMem && unmappedIndex >= 0) {
      BrickElement unmappedBrick=unmappedBricks.get(unmappedIndex--);
      if (unmappedBrick.getHit() == 0)       return;
      allocateNewWindow(unmappedBrick);
    }
    int mappedIndex=0;
    while (unmappedIndex >= 0 && mappedIndex < mappedBricks.size()) {
      BrickElement mappedBrick=mappedBricks.get(mappedIndex++);
      BrickElement unmappedBrick=unmappedBricks.get(unmappedIndex--);
      if (mappedBrick.getHit() >= unmappedBrick.getHit())       break;
      LockableWindow window=mappedBrick.getWindow();
      if (window.writeOutAndCloseIfFree(readOnly)) {
        mappedBrick.setWindow(null);
        memUsed-=brickSize;
        if (allocateNewWindow(unmappedBrick))         switches++;
      }
    }
  }
}
