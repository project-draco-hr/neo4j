{
  List<TypedId> paths=readPaths(session);
  NodeOrRelationship current=getCurrent(session);
  NodeOrRelationship newThing=null;
  if (parser.arguments().isEmpty()) {
    newThing=NodeOrRelationship.wrap(getServer().getDb().getReferenceNode());
    paths.clear();
  }
 else {
    String arg=parser.arguments().get(0);
    TypedId newId=current.getTypedId();
    if (arg.equals("..")) {
      if (paths.size() > 0) {
        newId=paths.remove(paths.size() - 1);
      }
    }
 else     if (arg.equals(".")) {
    }
 else     if (arg.equals("start") || arg.equals("end")) {
      newId=getStartOrEnd(current,arg);
      paths.add(current.getTypedId());
    }
 else {
      long suppliedId=Long.parseLong(arg);
      if (parser.options().containsKey("r")) {
        newId=new TypedId(NodeOrRelationship.TYPE_RELATIONSHIP,suppliedId);
      }
 else {
        newId=new TypedId(NodeOrRelationship.TYPE_NODE,suppliedId);
      }
      if (newId.equals(current.getTypedId())) {
        throw new ShellException("Can't cd to where you stand");
      }
      boolean absolute=parser.options().containsKey("a");
      if (!absolute && !this.isConnected(current,newId)) {
        throw new ShellException(getDisplayName(getServer(),session,newId,false) + " isn't connected to the current primitive," + " use -a to force it to go there anyway");
      }
      paths.add(current.getTypedId());
    }
    newThing=this.getThingById(newId);
  }
  setCurrent(session,newThing);
  session.set(WORKING_DIR_KEY,this.makePath(paths));
  return null;
}
