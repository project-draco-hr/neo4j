{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
        sampler.increment(1);
      writer.updateDocument(documentStructure.newTermForChangeOrRemove(nodeId),documentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
    updatedPropertyValues.add(update.getValueAfter());
  break;
case CHANGED:
writer.updateDocument(documentStructure.newTermForChangeOrRemove(nodeId),documentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
updatedPropertyValues.add(update.getValueAfter());
break;
case REMOVED:
sampler.increment(-1);
writer.deleteDocuments(documentStructure.newTermForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
luceneIndex.maybeRefresh();
try (IndexReader indexReader=luceneIndex.getIndexReader()){
indexReader.verifyDeferredConstraints(accessor,descriptor.getPropertyKeyId(),updatedPropertyValues);
}
 catch (Exception e) {
throw new IOException(e);
}
}
@Override public void remove(PrimitiveLongSet nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
