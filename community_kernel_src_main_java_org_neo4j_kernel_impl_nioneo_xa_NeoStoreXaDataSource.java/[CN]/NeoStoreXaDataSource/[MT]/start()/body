{
  life=new LifeSupport();
  readOnly=config.get(Configuration.read_only);
  storeDir=config.get(Configuration.store_dir);
  File store=config.get(Configuration.neo_store);
  if (!storeFactory.storeExists()) {
    storeFactory.createNeoStore().close();
  }
  indexProvider=dependencyResolver.resolveDependency(SchemaIndexProvider.class,SchemaIndexProvider.HIGHEST_PRIORITIZED_OR_NONE);
  storeMigrationProcess.addParticipant(indexProvider.storeMigrationParticipant());
  DefaultSchemaIndexProviderMap providerMap=new DefaultSchemaIndexProviderMap(indexProvider);
  storeMigrationProcess.migrateIfNeeded(store.getParentFile());
  neoStore=storeFactory.newNeoStore(false);
  schemaCache=new SchemaCache(Collections.<SchemaRule>emptyList());
  AutoLoadingCache<NodeImpl> nodeCache=new AutoLoadingCache<>(cacheProvider.node(),nodeLoader(neoStore.getNodeStore()));
  AutoLoadingCache<RelationshipImpl> relationshipCache=new AutoLoadingCache<>(cacheProvider.relationship(),relationshipLoader(neoStore.getRelationshipStore()));
  RelationshipLoader relationshipLoader=new RelationshipLoader(relationshipCache,new RelationshipChainLoader(neoStore));
  persistenceCache=new PersistenceCache(nodeCache,relationshipCache,nodeManager.newGraphProperties(),relationshipLoader,propertyKeyTokenHolder,relationshipTypeTokens,labelTokens);
  cacheAccess=new BridgingCacheAccess(schemaCache,updateableSchemaState,persistenceCache);
  try {
    indexingService=life.add(new IndexingService(scheduler,providerMap,new NeoStoreIndexStoreView(lockService,neoStore),tokenNameLookup,updateableSchemaState,logging,indexingServiceMonitor));
    integrityValidator=new IntegrityValidator(neoStore,indexingService);
    labelScanStore=life.add(dependencyResolver.resolveDependency(LabelScanStoreProvider.class,LabelScanStoreProvider.HIGHEST_PRIORITIZED).getLabelScanStore());
    fileListing=new NeoStoreFileListing(storeDir,labelScanStore,indexingService);
    Provider<NeoStore> neoStoreProvider=new Provider<NeoStore>(){
      @Override public NeoStore instance(){
        return getNeoStore();
      }
    }
;
    storeLayer=new CacheLayer(new DiskLayer(propertyKeyTokenHolder,labelTokens,relationshipTypeTokens,new SchemaStorage(neoStore.getSchemaStore()),neoStoreProvider,indexingService),persistenceCache,indexingService,schemaCache);
    kernel=life.add(new Kernel(propertyKeyTokenHolder,updateableSchemaState,schemaWriteGuard,indexingService,nodeManager,neoStoreProvider,persistenceCache,schemaCache,providerMap,fs,config,labelScanStore,storeLayer,scheduler,transactionMonitor,kernelHealth,readOnly,cacheAccess,integrityValidator,locks,lockService,remoteTxHook,txIdGenerator,transactionHeaderInformation,this,startupStatistics,logging));
    kernel.registerTransactionHook(transactionEventHandlers);
    life.init();
    life.start();
    propertyKeyTokenHolder.addTokens(((TokenStore<?>)neoStore.getPropertyKeyTokenStore()).getTokens(Integer.MAX_VALUE));
    relationshipTypeTokens.addTokens(((TokenStore<?>)neoStore.getRelationshipTypeTokenStore()).getTokens(Integer.MAX_VALUE));
    labelTokens.addTokens(((TokenStore<?>)neoStore.getLabelTokenStore()).getTokens(Integer.MAX_VALUE));
  }
 catch (  Throwable e) {
    try {
      neoStore.close();
    }
 catch (    Exception closeException) {
      msgLog.logMessage("Couldn't close neostore after startup failure");
    }
    throw Exceptions.launderedException(e);
  }
}
