{
  readOnly=config.get(Configuration.read_only);
  storeDir=config.get(Configuration.store_dir);
  File store=config.get(Configuration.neo_store);
  storeFactory.ensureStoreExists();
  final TransactionFactory tf;
  if (providers.shouldInterceptCommitting()) {
    tf=new InterceptingTransactionFactory();
  }
 else {
    tf=new TransactionFactory();
  }
  neoStore=storeFactory.newNeoStore(store);
  indexingService=life.add(new IndexingService(scheduler,indexProvider,new NeoStoreIndexStoreView(neoStore),logging));
  xaContainer=xaFactory.newXaContainer(this,config.get(Configuration.logical_log),new CommandFactory(neoStore,indexingService),tf,stateFactory,providers);
  try {
    if (!readOnly) {
      neoStore.setRecoveredStatus(true);
      try {
        indexingService.initIndexes(loadIndexRules());
        xaContainer.openLogicalLog();
      }
  finally {
        neoStore.setRecoveredStatus(false);
      }
    }
    if (!xaContainer.getResourceManager().hasRecoveredTransactions()) {
      neoStore.makeStoreOk();
    }
 else {
      msgLog.debug("Waiting for TM to take care of recovered " + "transactions.");
    }
    idGenerators=new ArrayMap<Class<?>,Store>((byte)5,false,false);
    this.idGenerators.put(Node.class,neoStore.getNodeStore());
    this.idGenerators.put(Relationship.class,neoStore.getRelationshipStore());
    this.idGenerators.put(RelationshipType.class,neoStore.getRelationshipTypeStore());
    this.idGenerators.put(PropertyStore.class,neoStore.getPropertyStore());
    this.idGenerators.put(PropertyIndex.class,neoStore.getPropertyStore().getIndexStore());
    setLogicalLogAtCreationTime(xaContainer.getLogicalLog());
    life.start();
  }
 catch (  Throwable e) {
    try {
      neoStore.close();
    }
 catch (    Exception closeException) {
      msgLog.logMessage("Couldn't close neostore after startup failure");
    }
    throw Exceptions.launderedException(e);
  }
}
