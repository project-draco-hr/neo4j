{
  super(fileName,conf,IdType.NEOSTORE_BLOCK,idGeneratorFactory,pageCache,fileSystemAbstraction,stringLogger,versionMismatchHandler);
  this.relTypeStore=relTypeStore;
  this.labelTokenStore=labelTokenStore;
  this.propStore=propStore;
  this.relStore=relStore;
  this.nodeStore=nodeStore;
  this.schemaStore=schemaStore;
  this.relGroupStore=relGroupStore;
  this.counts=counts;
  this.relGrabSize=conf.get(Configuration.relationship_grab_size);
  this.transactionCloseWaitLogger=new CappedOperation<Void>(time(30,SECONDS)){
    @Override protected void triggered(    Void event){
      stringLogger.info(format("Waiting for all transactions to close...%n committed:  %s%n  committing: %s%n  closed:     %s",highestCommittedTransaction.get(),lastCommittingTxField,lastClosedTx));
    }
  }
;
  counts.setInitializer(new DataInitializer<CountsAccessor.Updater>(){
    @Override public void initialize(    CountsAccessor.Updater updater){
      stringLogger.warn("Missing counts store, rebuilding it.");
      new CountsComputer(NeoStore.this).initialize(updater);
    }
    @Override public long initialVersion(){
      return getLastCommittedTransactionId();
    }
  }
);
  try {
    counts.init();
  }
 catch (  IOException e) {
    throw new UnderlyingStorageException("Failed to initialize counts store",e);
  }
}
