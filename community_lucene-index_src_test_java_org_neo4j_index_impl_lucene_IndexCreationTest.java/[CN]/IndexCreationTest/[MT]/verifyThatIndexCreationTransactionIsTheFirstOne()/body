{
  NeoStoreDataSource ds=db.getDependencyResolver().resolveDependency(NeoStoreDataSource.class);
  PhysicalLogFile pLogFile=db.getDependencyResolver().resolveDependency(PhysicalLogFile.class);
  long version=ds.getCurrentLogVersion();
  db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
  ReadableVersionableLogChannel logChannel=pLogFile.getReader(new LogPosition(version,LOG_HEADER_SIZE));
  LogDeserializer deserializer=new LogDeserializer();
  final AtomicBoolean success=new AtomicBoolean(false);
  try (IOCursor<LogEntry> cursor=deserializer.logEntries(logChannel)){
    List<Command> commandsInFirstEntry=new ArrayList<>();
    boolean startFound=false;
    while (cursor.next()) {
      LogEntry entry=cursor.get();
      if (entry instanceof LogEntryStart) {
        if (startFound) {
          throw new IllegalArgumentException("More than one start entry");
        }
        startFound=true;
      }
      if (startFound && entry instanceof LogEntryCommand) {
        commandsInFirstEntry.add(entry.<LogEntryCommand>as().getXaCommand());
      }
      if (entry instanceof LogEntryCommit) {
        assertTrue(startFound);
        assertFalse("Index creation transaction wasn't the first one",commandsInFirstEntry.isEmpty());
        List<Command> createCommands=IteratorUtil.asList(new FilteringIterator<>(commandsInFirstEntry.iterator(),new Predicate<Command>(){
          @Override public boolean accept(          Command item){
            return item instanceof IndexDefineCommand;
          }
        }
));
        assertEquals(1,createCommands.size());
        success.set(true);
        break;
      }
    }
  }
   assertTrue("Didn't find any commit record in log " + version,success.get());
}
