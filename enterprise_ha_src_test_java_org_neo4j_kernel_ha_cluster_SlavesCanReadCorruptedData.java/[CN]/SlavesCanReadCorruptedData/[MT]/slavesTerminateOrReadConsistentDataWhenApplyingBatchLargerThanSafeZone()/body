{
  long safeZone=TimeUnit.MILLISECONDS.toMillis(0);
  clusterRule.withSharedSetting(id_reuse_safe_zone_time,String.valueOf(safeZone));
  final ClusterManager.ManagedCluster cluster=clusterRule.startCluster();
  HighlyAvailableGraphDatabase master=cluster.getMaster();
  int stringLength=1000;
  final String stringA=buildString(stringLength,'a');
  final String stringB=buildString(stringLength,'b');
  final String key="key";
  final long nodeId=createNodeAndSetProperty(master,key,stringA);
  cluster.sync();
  removeProperty(master,nodeId,key);
  Thread.sleep(100);
  forceMaintenance(master);
  setProperty(master,nodeId,key,stringB);
  final HighlyAvailableGraphDatabase slave=cluster.getAnySlave();
  Race race=new Race();
  int nbrOfReaders=100;
  final AtomicBoolean end=new AtomicBoolean(false);
  final AtomicInteger successfulReads=new AtomicInteger();
  final AtomicInteger transientExceptions=new AtomicInteger();
  for (int i=0; i < nbrOfReaders; i++) {
    race.addContestant(readContestant(stringA,stringB,key,nodeId,slave,end,successfulReads,transientExceptions));
  }
  race.addContestant(new Runnable(){
    @Override public void run(){
      try {
        Random rnd=new Random();
        Thread.sleep(rnd.nextInt(100));
        slave.getDependencyResolver().resolveDependency(UpdatePuller.class).pullUpdates();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
 finally {
        end.set(true);
      }
    }
  }
);
  race.go();
  assertTrue("Expected at least one transaction to be interrupted when applying update",transientExceptions.get() > 0);
}
