{
  int diff=(int)fileChannel.size() - (brickCount * brickSize);
  if (diff > 0 && diff < brickSize) {
    byte zeroBuf[]=new byte[brickSize - diff];
    java.util.Arrays.fill(zeroBuf,(byte)0);
    fileChannel.write(java.nio.ByteBuffer.wrap(zeroBuf),fileChannel.size());
  }
  int newBrickCount=(int)fileChannel.size() / brickSize;
  if (newBrickCount > brickCount) {
    BrickElement tmpArray[]=new BrickElement[newBrickCount];
    System.arraycopy(brickArray,0,tmpArray,0,brickArray.length);
    for (int i=brickArray.length; i < tmpArray.length; i++) {
      BrickElement be=new BrickElement(i);
      tmpArray[i]=new BrickElement(i);
      if (memUsed + brickSize <= mappedMem) {
        try {
          be.setWindow(new MappedPersistenceWindow(i * brickSize / blockSize,blockSize,brickSize,fileChannel));
          memUsed+=brickSize;
        }
 catch (        MappedMemException e) {
          ooe++;
          logWarn("Unable to memory map");
        }
      }
    }
    brickArray=tmpArray;
    brickCount=tmpArray.length;
  }
}
