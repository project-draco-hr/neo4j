{
  TraversalDescription description=new TraversalDescriptionImpl().filter(Traversal.returnAll()).prune(Traversal.pruneAfterDepth(1)).prune(new PruneEvaluator(){
    public boolean pruneAfter(    Path position){
      int counter=0;
      for (Iterator<Relationship> rels=position.endNode().getRelationships(Direction.OUTGOING).iterator(); rels.hasNext(); ) {
        counter++;
        rels.next();
      }
      return counter < 3;
    }
  }
);
  Set<String> expectedNodes=new HashSet<String>(Arrays.asList("a","b","c","d","e"));
  for (  Path position : description.traverse(referenceNode())) {
    String name=(String)position.endNode().getProperty("name");
    assertTrue(name + " shouldn't have been returned",expectedNodes.remove(name));
  }
  assertTrue(expectedNodes.isEmpty());
}
