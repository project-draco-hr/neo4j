{
  final Race race=new Race();
  final AtomicInteger coordination=new AtomicInteger(-1);
  final AtomicInteger expected=new AtomicInteger();
  final int threads=30;
  @SuppressWarnings("unchecked") final RecordCheckWorker<Integer>[] workers=new RecordCheckWorker[threads];
  final RecordProcessor<Integer> processor=new RecordProcessor.Adapter<Integer>(){
    @Override public void process(    Integer record){
    }
    @Override public void init(    int id){
      assertEquals(id,expected.getAndAdd(1));
    }
  }
;
  for (int id=0; id < threads; id++) {
    ArrayBlockingQueue<Integer> queue=new ArrayBlockingQueue<>(10);
    race.addContestant(workers[id]=new RecordCheckWorker<>(id,coordination,queue,processor));
  }
  race.addContestant(new Runnable(){
    @Override public void run(){
      try {
        long end=currentTimeMillis() + SECONDS.toMillis(100);
        while (currentTimeMillis() < end && expected.get() < threads) {
          parkNanos(MILLISECONDS.toNanos(10));
        }
        assertEquals(threads,expected.get());
      }
  finally {
        for (        RecordCheckWorker<Integer> worker : workers) {
          worker.done();
        }
      }
    }
  }
);
  race.go();
}
