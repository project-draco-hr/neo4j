{
  if (startNode == null || endNode == null || type == null) {
    throw new IllegalArgumentException("Null parameter, startNode=" + startNode + ", endNode="+ endNode+ ", type="+ type);
  }
  if (!RelationshipTypeHolder.getHolder().isValidRelationshipType(type)) {
    setRollbackOnly();
    throw new IllegalArgumentException("Relationship type: " + type + " not valid");
  }
  NodeImpl firstNode=getLightNode((int)startNode.getId());
  if (firstNode == null) {
    setRollbackOnly();
    throw new RuntimeException("Node[" + startNode.getId() + "] deleted?");
  }
  NodeImpl secondNode=getLightNode((int)endNode.getId());
  if (secondNode == null) {
    setRollbackOnly();
    throw new RuntimeException("Node[" + endNode.getId() + "] deleted?");
  }
  int id=IdGenerator.getGenerator().nextId(Relationship.class);
  int startNodeId=(int)startNode.getId();
  int endNodeId=(int)endNode.getId();
  RelationshipImpl rel=new RelationshipImpl(id,startNodeId,endNodeId,type,true);
  boolean firstNodeTaken=false;
  boolean secondNodeTaken=false;
  acquireLock(rel,LockType.WRITE);
  try {
    acquireLock(firstNode,LockType.WRITE);
    firstNodeTaken=true;
    if (firstNode.isDeleted()) {
      setRollbackOnly();
      throw new CreateException("" + startNode + " has been deleted in other transaction");
    }
    acquireLock(secondNode,LockType.WRITE);
    secondNodeTaken=true;
    if (secondNode.isDeleted()) {
      setRollbackOnly();
      throw new CreateException("" + endNode + " has been deleted in other transaction");
    }
    int typeId=RelationshipTypeHolder.getHolder().getIdFor(type);
    EventManager em=EventManager.getManager();
    EventData eventData=new EventData(new RelationshipOpData(rel,id,typeId,startNodeId,endNodeId));
    if (!em.generateProActiveEvent(Event.RELATIONSHIP_CREATE,eventData)) {
      setRollbackOnly();
      throw new CreateException("Unable to create relationship, " + "pro-active event failed.");
    }
    firstNode.addRelationship(type,id);
    secondNode.addRelationship(type,id);
    addRelationshipToCache(rel);
    em.generateReActiveEvent(Event.RELATIONSHIP_CREATE,eventData);
    return new RelationshipProxy(id);
  }
  finally {
    boolean releaseFailed=false;
    if (firstNodeTaken) {
      try {
        releaseLock(firstNode,LockType.WRITE);
      }
 catch (      Exception e) {
        releaseFailed=true;
        e.printStackTrace();
        log.severe("Failed to release lock");
      }
    }
    if (secondNodeTaken) {
      try {
        releaseLock(secondNode,LockType.WRITE);
      }
 catch (      Exception e) {
        releaseFailed=true;
        e.printStackTrace();
        log.severe("Failed to release lock");
      }
    }
    releaseLock(rel,LockType.WRITE);
    if (releaseFailed) {
      throw new RuntimeException("Unable to release locks [" + startNode + ","+ endNode+ "] in relationship create->"+ rel);
    }
  }
}
