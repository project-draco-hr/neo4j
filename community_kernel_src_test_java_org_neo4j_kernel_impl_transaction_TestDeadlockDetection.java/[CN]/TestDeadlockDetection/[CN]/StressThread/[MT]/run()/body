{
  try {
    startSignal.await();
    java.util.Stack<Object> lockStack=new java.util.Stack<Object>();
    java.util.Stack<ResourceObject> resourceStack=new java.util.Stack<ResourceObject>();
    for (int i=0; i < numberOfIterations; i++) {
      try {
        int depth=depthCount;
        do {
          float f=rand.nextFloat();
          int n=rand.nextInt(resources.length);
          if (f < readWriteRatio) {
            lm.getReadLock(resources[n],tx);
            lockStack.push(READ);
          }
 else {
            lm.getWriteLock(resources[n],tx);
            lockStack.push(WRITE);
          }
          resourceStack.push(resources[n]);
        }
 while (--depth > 0);
        while (!lockStack.isEmpty()) {
          if (lockStack.pop() == READ) {
            lm.releaseReadLock(resourceStack.pop(),tx);
          }
 else {
            lm.releaseWriteLock(resourceStack.pop(),tx);
          }
        }
      }
 catch (      DeadlockDetectedException e) {
      }
 finally {
        while (!lockStack.isEmpty()) {
          if (lockStack.pop() == READ) {
            lm.releaseReadLock(resourceStack.pop(),tx);
          }
 else {
            lm.releaseWriteLock(resourceStack.pop(),tx);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    error=e;
  }
}
