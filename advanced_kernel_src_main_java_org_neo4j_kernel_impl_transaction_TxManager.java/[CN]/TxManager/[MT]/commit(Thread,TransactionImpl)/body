{
  Throwable commitFailureCause=null;
  int xaErrorCode=-1;
  if (tx.getResourceCount() == 0) {
    tx.setStatus(Status.STATUS_COMMITTED);
  }
 else {
    try {
      tx.doCommit();
    }
 catch (    XAException e) {
      xaErrorCode=e.errorCode;
      e.printStackTrace();
      log.severe("Commit failed, status=" + getTxStatusAsString(tx.getStatus()) + ", errorCode="+ xaErrorCode);
      if (tx.getStatus() == Status.STATUS_COMMITTED) {
        setTmNotOk();
        throw new TransactionFailureException("commit threw exception but status is committed?",e);
      }
    }
catch (    Throwable t) {
      t.printStackTrace();
      commitFailureCause=t;
    }
  }
  if (tx.getStatus() != Status.STATUS_COMMITTED) {
    try {
      tx.doRollback();
    }
 catch (    XAException e) {
      e.printStackTrace();
      log.severe("Unable to rollback transaction. " + "Some resources may be commited others not. " + "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->");
      setTmNotOk();
      if (commitFailureCause != null) {
        commitFailureCause.printStackTrace();
      }
      throw new HeuristicMixedException("Unable to rollback ---> error code in commit: " + xaErrorCode + " ---> error code for rollback: "+ e.errorCode);
    }
    tx.doAfterCompletion();
    txThreadMap.remove(thread);
    try {
      if (tx.isGlobalStartRecordWritten()) {
        getTxLog().txDone(tx.getGlobalId());
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      log.severe("Error writing transaction log");
      setTmNotOk();
      throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
    }
    tx.setStatus(Status.STATUS_NO_TRANSACTION);
    if (commitFailureCause == null) {
      throw new HeuristicRollbackException("Failed to commit, transaction rolledback ---> " + "error code was: " + xaErrorCode);
    }
 else {
      throw new HeuristicRollbackException("Failed to commit, transaction rolledback ---> " + commitFailureCause);
    }
  }
  tx.doAfterCompletion();
  txThreadMap.remove(thread);
  try {
    if (tx.isGlobalStartRecordWritten()) {
      getTxLog().txDone(tx.getGlobalId());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    log.severe("Error writing transaction log");
    setTmNotOk();
    throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
  }
  tx.setStatus(Status.STATUS_NO_TRANSACTION);
}
