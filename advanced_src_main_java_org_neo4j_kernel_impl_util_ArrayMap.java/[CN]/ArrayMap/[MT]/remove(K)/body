{
  if (useThreadSafeMap) {
    return synchronizedRemove(key);
  }
  for (int i=0; i < arrayCount; i++) {
    if (arrayEntries[i].getKey().equals(key)) {
      V removedProperty=arrayEntries[i].getValue();
      arrayCount--;
      System.arraycopy(arrayEntries,i + 1,arrayEntries,i,arrayCount - i);
      arrayEntries[arrayCount]=null;
      return removedProperty;
    }
  }
  if (arrayCount == -1) {
    V value=propertyMap.remove(key);
    if (switchBackToArray && propertyMap.size() < toMapThreshold) {
      arrayEntries=new ArrayEntry[toMapThreshold];
      int tmpCount=0;
      for (      Entry<K,V> entry : propertyMap.entrySet()) {
        arrayEntries[tmpCount++]=new ArrayEntry<K,V>(entry.getKey(),entry.getValue());
      }
      arrayCount=tmpCount;
    }
    return value;
  }
  return null;
}
