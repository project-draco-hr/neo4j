{
  state=State.STARTING;
  applyRecoveredUpdates();
  IndexMap indexMap=indexMapRef.indexMapSnapshot();
  final Map<Long,RebuildingIndexDescriptor> rebuildingDescriptors=new HashMap<>();
  indexMap.foreachIndexProxy(new BiConsumer<Long,IndexProxy>(){
    @Override public void accept(    Long indexId,    IndexProxy proxy){
      InternalIndexState state=proxy.getState();
      IndexDescriptor descriptor=proxy.getDescriptor();
      log.info(proxySetup.indexStateInfo("start",indexId,state,descriptor));
switch (state) {
case ONLINE:
        break;
case POPULATING:
      rebuildingDescriptors.put(indexId,new RebuildingIndexDescriptor(descriptor,proxy.getProviderDescriptor(),proxy.config()));
    break;
case FAILED:
  break;
}
}
}
);
dropRecoveringIndexes(indexMap,rebuildingDescriptors.keySet());
for (Map.Entry<Long,RebuildingIndexDescriptor> entry : rebuildingDescriptors.entrySet()) {
long indexId=entry.getKey();
RebuildingIndexDescriptor descriptors=entry.getValue();
IndexProxy proxy=proxySetup.createPopulatingIndexProxy(indexId,descriptors.getIndexDescriptor(),descriptors.getProviderDescriptor(),false,monitor);
proxy.start();
indexMap.putIndexProxy(indexId,proxy);
}
indexMapRef.setIndexMap(indexMap);
samplingController.recoverIndexSamples();
samplingController.start();
for (Map.Entry<Long,RebuildingIndexDescriptor> entry : rebuildingDescriptors.entrySet()) {
if (!entry.getValue().getConfiguration().isUnique()) {
continue;
}
IndexProxy proxy;
try {
proxy=getIndexProxy(entry.getKey().longValue());
}
 catch (IndexNotFoundKernelException e) {
throw new ThisShouldNotHappenError("Mattias","What? This index was seen during recovery just now, why isn't it available now?");
}
monitor.awaitingPopulationOfRecoveredIndex(entry.getKey(),entry.getValue().getIndexDescriptor());
awaitOnline(proxy);
}
state=State.RUNNING;
}
