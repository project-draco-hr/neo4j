{
  state=State.STARTING;
  applyRecoveredUpdates();
  IndexMap indexMap=indexMapSnapshot();
  final Map<Long,Pair<IndexDescriptor,SchemaIndexProvider.Descriptor>> rebuildingDescriptors=new HashMap<>();
  indexMap.foreachIndexProxy(new BiConsumer<Long,IndexProxy>(){
    @Override public void accept(    Long indexId,    IndexProxy proxy){
      InternalIndexState state=proxy.getState();
      IndexDescriptor descriptor=proxy.getDescriptor();
      logger.info(proxySetup.indexStateInfo("start",indexId,state,descriptor));
switch (state) {
case ONLINE:
        break;
case POPULATING:
      rebuildingDescriptors.put(indexId,Pair.of(descriptor,proxy.getProviderDescriptor()));
    break;
case FAILED:
  break;
}
}
}
);
dropRecoveringIndexes(indexMap,rebuildingDescriptors);
for (Map.Entry<Long,Pair<IndexDescriptor,SchemaIndexProvider.Descriptor>> entry : rebuildingDescriptors.entrySet()) {
long indexId=entry.getKey();
Pair<IndexDescriptor,SchemaIndexProvider.Descriptor> descriptors=entry.getValue();
IndexDescriptor indexDescriptor=descriptors.first();
SchemaIndexProvider.Descriptor providerDescriptor=descriptors.other();
IndexProxy proxy=proxySetup.createPopulatingIndexProxy(indexId,indexDescriptor,providerDescriptor,false);
proxy.start();
indexMap.putIndexProxy(indexId,proxy);
}
indexMapRef.setIndexMap(indexMap);
samplingController.recoverIndexSamples(samplingSetup.reSamplingPredicate());
samplingSetup.scheduleBackgroundJob(samplingController);
state=State.RUNNING;
}
