{
  List<NonCompletedTransaction> commitList=new ArrayList<NonCompletedTransaction>();
  final List<Xid> rollbackList=new LinkedList<Xid>();
  final Map<Resource,XaDataSource> resourceMap=new HashMap<Resource,XaDataSource>();
  buildRecoveryInfo(commitList,rollbackList,resourceMap,danglingRecordList);
  final List<Xid> recoveredXidsList=new LinkedList<Xid>();
  try {
    for (    XaDataSource xaDataSource : dataSources.values()) {
      XAResource xaRes=xaDataSource.getXaConnection().getXaResource();
      Xid xids[]=xaRes.recover(XAResource.TMNOFLAGS);
      for (int i=0; i < xids.length; i++) {
        if (XidImpl.isThisTm(xids[i].getGlobalTransactionId())) {
          if (rollbackList.contains(xids[i])) {
            log.fine("Found pre commit " + xids[i] + " rolling back ... ");
            msgLog.logMessage("TM: Found pre commit " + xids[i] + " rolling back ... ",true);
            rollbackList.remove(xids[i]);
            xaRes.rollback(xids[i]);
          }
 else {
            Resource resource=new Resource(xids[i].getBranchQualifier());
            if (!resourceMap.containsKey(resource)) {
              resourceMap.put(resource,xaDataSource);
            }
            recoveredXidsList.add(xids[i]);
          }
        }
 else {
          log.warning("Unknown xid: " + xids[i]);
        }
      }
    }
    Collections.sort(commitList);
    Iterator<NonCompletedTransaction> commitItr=commitList.iterator();
    while (commitItr.hasNext()) {
      NonCompletedTransaction nct=commitItr.next();
      int seq=nct.getSequenceNumber();
      Xid xids[]=nct.getXids();
      log.fine("Marked as commit tx-seq[" + seq + "] branch length: "+ xids.length);
      for (      Xid xid : xids) {
        if (!recoveredXidsList.contains(xid)) {
          log.fine("Tx-seq[" + seq + "]["+ xid+ "] not found in recovered xid list, "+ "assuming already committed");
          continue;
        }
        recoveredXidsList.remove(xid);
        Resource resource=new Resource(xid.getBranchQualifier());
        if (!resourceMap.containsKey(resource)) {
          final TransactionFailureException ex=new TransactionFailureException("Couldn't find XAResource for " + xid);
          throw logAndReturn("TM: recovery error",ex);
        }
        log.fine("Commiting tx seq[" + seq + "]["+ xid+ "] ... ");
        msgLog.logMessage("TM: Committing tx " + xid,true);
        resourceMap.get(resource).getXaConnection().getXaResource().commit(xid,false);
      }
    }
    Iterator<Xid> rollbackItr=recoveredXidsList.iterator();
    while (rollbackItr.hasNext()) {
      Xid xid=rollbackItr.next();
      Resource resource=new Resource(xid.getBranchQualifier());
      if (!resourceMap.containsKey(resource)) {
        final TransactionFailureException ex=new TransactionFailureException("Couldn't find XAResource for " + xid);
        throw logAndReturn("TM: recovery error",ex);
      }
      log.fine("Rollback " + xid + " ... ");
      msgLog.logMessage("TM: no match found for " + xid + " removing",true);
      resourceMap.get(resource).getXaConnection().getXaResource().rollback(xid);
    }
    if (rollbackList.size() > 0) {
      log.fine("TxLog contained unresolved " + "xids that needed rollback. They couldn't be matched to " + "any of the XAResources recover list. "+ "Assuming " + rollbackList.size() + " transactions already rolled back.");
      msgLog.logMessage("TM: no match found for in total " + rollbackList.size() + " transaction that should have been rolled back",true);
    }
    for (    XaDataSource participant : MapUtil.reverse(resourceMap).keySet()) {
      participant.rotateLogicalLog();
    }
  }
 catch (  IOException e) {
    throw logAndReturn("TM: recovery failed",new TransactionFailureException("Recovery failed.",e));
  }
catch (  XAException e) {
    throw logAndReturn("TM: recovery failed",new TransactionFailureException("Recovery failed.",e));
  }
}
