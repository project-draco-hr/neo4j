{
  final AtomicBoolean shouldStop=new AtomicBoolean();
  final int cachePages=40;
  final int filePages=cachePages * 2;
  final int threadCount=8;
  final int pageSize=threadCount * 4;
  final int maxCursorsPerThread=cachePages / (1 + threadCount);
  assertThat(maxCursorsPerThread * threadCount,lessThan(cachePages));
  getPageCache(fs,cachePages,pageSize,PageCacheTracer.NULL);
  final PagedFile pagedFile=pageCache.map(file("a"),pageSize);
  ensureAllPagesExists(filePages,pagedFile);
  List<Future<UpdateResult>> futures=new ArrayList<>();
  for (int i=0; i < threadCount; i++) {
    UpdateWorker worker=new UpdateWorker(i,filePages,shouldStop,pagedFile){
      protected void performReadOrUpdate(      ThreadLocalRandom rng,      boolean updateCounter,      int pf_flags) throws IOException {
        try {
          int pageCount=rng.nextInt(1,maxCursorsPerThread);
          int[] pageIds=new int[pageCount];
          for (int j=0; j < pageCount; j++) {
            pageIds[j]=rng.nextInt(0,filePages);
          }
          PageCursor[] cursors=new PageCursor[pageCount];
          for (int j=0; j < pageCount; j++) {
            cursors[j]=pagedFile.io(pageIds[j],pf_flags);
            assertTrue(cursors[j].next());
          }
          for (int j=0; j < pageCount; j++) {
            int pageId=pageIds[j];
            PageCursor cursor=cursors[j];
            int counter;
            do {
              cursor.setOffset(offset);
              counter=cursor.getInt();
            }
 while (cursor.shouldRetry());
            String lockName=updateCounter ? "PF_SHARED_WRITE_LOCK" : "PF_SHARED_READ_LOCK";
            String reason=String.format("inconsistent page read from filePageId = %s, with %s, workerId = %s [t:%s]",pageId,lockName,threadId,Thread.currentThread().getId());
            assertThat(reason,counter,is(pageCounts[pageId]));
            if (updateCounter) {
              counter++;
              pageCounts[pageId]++;
              cursor.setOffset(offset);
              cursor.putInt(counter);
            }
          }
          for (          PageCursor cursor : cursors) {
            cursor.close();
          }
        }
 catch (        Throwable throwable) {
          shouldStop.set(true);
          throw throwable;
        }
      }
    }
;
    futures.add(executor.submit(worker));
  }
  Thread.sleep(40);
  shouldStop.set(true);
  verifyUpdateResults(filePages,pagedFile,futures);
  pagedFile.close();
}
