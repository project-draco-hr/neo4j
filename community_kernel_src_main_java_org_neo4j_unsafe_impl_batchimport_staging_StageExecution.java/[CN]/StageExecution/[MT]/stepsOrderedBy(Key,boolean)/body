{
  final List<Step<?>> steps=new ArrayList<>(pipeline);
  Collections.sort(steps,new Comparator<Step<?>>(){
    @Override public int compare(    Step<?> o1,    Step<?> o2){
      Long stat1=o1.stats().stat(stat).asLong();
      Long stat2=o2.stats().stat(stat).asLong();
      return trueForAscending ? stat1.compareTo(stat2) : stat2.compareTo(stat1);
    }
  }
);
  return new Iterable<Pair<Step<?>,Float>>(){
    @Override public Iterator<Pair<Step<?>,Float>> iterator(){
      return new PrefetchingIterator<Pair<Step<?>,Float>>(){
        private final Iterator<Step<?>> source=steps.iterator();
        private Step<?> next=source.hasNext() ? source.next() : null;
        @Override protected Pair<Step<?>,Float> fetchNextOrNull(){
          if (next == null) {
            return null;
          }
          Step<?> current=next;
          next=source.hasNext() ? source.next() : null;
          float factor=next != null ? (float)stat(current,stat) / (float)stat(next,stat) : 1.0f;
          return Pair.<Step<?>,Float>of(current,factor);
        }
        private long stat(        Step<?> step,        Key stat){
          return step.stats().stat(stat).asLong();
        }
      }
;
    }
  }
;
}
