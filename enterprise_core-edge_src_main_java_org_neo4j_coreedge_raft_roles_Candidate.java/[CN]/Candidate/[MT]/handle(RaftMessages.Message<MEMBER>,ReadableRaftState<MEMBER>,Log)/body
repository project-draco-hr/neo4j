{
  Role nextRole=CANDIDATE;
  MEMBER leader=ctx.leader();
  long leaderCommit=ctx.leaderCommit();
  Collection<RaftMessages.Directed<MEMBER>> outgoingMessages=new ArrayList<>();
  ArrayList<LogCommand> logCommands=new ArrayList<>();
  ArrayList<ShipCommand> shipCommands=new ArrayList<>();
  Set<MEMBER> updatedVotesForMe=new HashSet<>(ctx.votesForMe());
  long newTerm=ctx.term();
  long lastLogIndexBeforeWeBecameLeader=-1;
switch (message.type()) {
case HEARTBEAT:
{
      RaftMessages.Heartbeat<MEMBER> req=(RaftMessages.Heartbeat<MEMBER>)message;
      if (req.leaderTerm() < ctx.term()) {
        break;
      }
      nextRole=FOLLOWER;
      outgoingMessages.add(new RaftMessages.Directed<>(ctx.myself(),message));
      break;
    }
case APPEND_ENTRIES_REQUEST:
{
    RaftMessages.AppendEntries.Request<MEMBER> req=(RaftMessages.AppendEntries.Request<MEMBER>)message;
    if (req.leaderTerm() < ctx.term()) {
      RaftMessages.AppendEntries.Response<MEMBER> appendResponse=new RaftMessages.AppendEntries.Response<>(ctx.myself(),ctx.term(),false,req.prevLogIndex());
      outgoingMessages.add(new RaftMessages.Directed<>(req.from(),appendResponse));
      break;
    }
    nextRole=FOLLOWER;
    outgoingMessages.add(new RaftMessages.Directed<>(ctx.myself(),req));
    break;
  }
case VOTE_RESPONSE:
{
  RaftMessages.Vote.Response<MEMBER> res=(RaftMessages.Vote.Response<MEMBER>)message;
  if (res.term() > ctx.term()) {
    newTerm=res.term();
    nextRole=FOLLOWER;
    break;
  }
 else   if (res.term() < ctx.term() || !res.voteGranted()) {
    break;
  }
  if (!res.from().equals(ctx.myself())) {
    updatedVotesForMe.add(res.from());
  }
  if (isQuorum(ctx.votingMembers().size(),updatedVotesForMe.size())) {
    log.info("In term %d %s ELECTED AS LEADER voted for by %s%n",ctx.term(),ctx.myself(),updatedVotesForMe);
    leader=ctx.myself();
    Leader.sendHeartbeats(ctx,outgoingMessages);
    lastLogIndexBeforeWeBecameLeader=ctx.entryLog().appendIndex();
    nextRole=LEADER;
  }
  break;
}
case VOTE_REQUEST:
{
RaftMessages.Vote.Request<MEMBER> req=(RaftMessages.Vote.Request<MEMBER>)message;
if (req.term() > ctx.term()) {
  newTerm=req.term();
  updatedVotesForMe.clear();
  nextRole=FOLLOWER;
  outgoingMessages.add(new RaftMessages.Directed<>(ctx.myself(),req));
  break;
}
outgoingMessages.add(new RaftMessages.Directed<>(req.from(),new RaftMessages.Vote.Response<>(ctx.myself(),newTerm,false)));
break;
}
case ELECTION_TIMEOUT:
{
nextRole=FOLLOWER;
break;
}
}
return new Outcome<>(nextRole,newTerm,leader,leaderCommit,null,updatedVotesForMe,lastLogIndexBeforeWeBecameLeader,new FollowerStates<>(),false,logCommands,outgoingMessages,shipCommands);
}
