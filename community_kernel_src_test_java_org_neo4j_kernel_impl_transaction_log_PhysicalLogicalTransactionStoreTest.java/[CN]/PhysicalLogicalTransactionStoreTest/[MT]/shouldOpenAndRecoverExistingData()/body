{
  TransactionIdStore transactionIdStore=new DeadSimpleTransactionIdStore();
  TransactionMetadataCache positionCache=new TransactionMetadataCache(10,100);
  final byte[] additionalHeader=new byte[]{1,2,5};
  final int masterId=2, authorId=1;
  final long timeStarted=12345, latestCommittedTxWhenStarted=4545, timeCommitted=timeStarted + 10;
  LifeSupport life=new LifeSupport();
  final PhysicalLogFiles logFiles=new PhysicalLogFiles(testDir,DEFAULT_NAME,fs);
  Monitor monitor=new Monitors().newMonitor(PhysicalLogFile.Monitor.class);
  LogFile logFile=life.add(new PhysicalLogFile(fs,logFiles,1000,transactionIdStore,mock(LogVersionRepository.class),monitor,positionCache));
  life.start();
  try {
    addATransactionAndRewind(life,logFile,positionCache,transactionIdStore,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted);
  }
  finally {
    life.shutdown();
  }
  life=new LifeSupport();
  FakeRecoveryVisitor visitor=new FakeRecoveryVisitor(additionalHeader,masterId,authorId,timeStarted,timeCommitted,latestCommittedTxWhenStarted);
  final LogFileRecoverer recoverer=new LogFileRecoverer(new LogEntryReaderFactory().versionable(),visitor);
  logFile=life.add(new PhysicalLogFile(fs,logFiles,1000,transactionIdStore,mock(LogVersionRepository.class),monitor,positionCache));
  TransactionAppender appender=new BatchingTransactionAppender(logFile,NO_ROTATION,positionCache,transactionIdStore,BYPASS,kernelHealth);
  life.add(appender);
  life.add(new Recovery(new Recovery.SPI(){
    @Override public void forceEverything(){
    }
    @Override public Visitor<LogVersionedStoreChannel,IOException> getRecoverer(){
      return recoverer;
    }
    @Override public Iterator<LogVersionedStoreChannel> getLogFiles(    final long recoveryVersion) throws IOException {
      return new Iterator<LogVersionedStoreChannel>(){
        private final StoreChannel channel=PhysicalLogFile.openForVersion(logFiles,fs,recoveryVersion);
        private boolean consumed=false;
        @Override public boolean hasNext(){
          return !consumed;
        }
        @Override public LogVersionedStoreChannel next(){
          PhysicalLogVersionedStoreChannel physicalLogVersionedStoreChannel;
          try {
            physicalLogVersionedStoreChannel=new PhysicalLogVersionedStoreChannel(channel,recoveryVersion,CURRENT_LOG_VERSION);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
          consumed=true;
          return physicalLogVersionedStoreChannel;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
    @Override public LogPosition getPositionToRecoverFrom() throws IOException {
      return LogPosition.start(0);
    }
  }
,mock(Recovery.Monitor.class)));
  try {
    life.start();
  }
  finally {
    life.shutdown();
  }
  assertEquals(1,visitor.getVisitedTransactions());
}
