{
  if (hasTxStateWithChanges()) {
    final AtomicBoolean clearState=new AtomicBoolean(false);
    txState().accept(new TxState.VisitorAdapter(){
      @Override public void visitCreatedNode(      long id){
        recordState.nodeCreate(id);
      }
      @Override public void visitDeletedNode(      long id){
        recordState.nodeDelete(id);
      }
      @Override public void visitCreatedRelationship(      long id,      int type,      long startNode,      long endNode){
        try {
          for (PrimitiveIntIterator labels=labelsOf(startNode); labels.hasNext(); ) {
            int label=labels.next();
            counts.increment(label,ANY_RELATIONSHIP_TYPE,ANY_LABEL);
            counts.increment(label,type,ANY_LABEL);
          }
          for (PrimitiveIntIterator labels=labelsOf(endNode); labels.hasNext(); ) {
            int label=labels.next();
            counts.increment(ANY_LABEL,ANY_RELATIONSHIP_TYPE,label);
            counts.increment(ANY_LABEL,type,label);
          }
        }
 catch (        EntityNotFoundException e) {
          throw new IllegalStateException("Nodes with added relationships should exist.",e);
        }
        recordState.relCreate(id,type,startNode,endNode);
      }
      @Override public void visitDeletedRelationship(      long id){
        try {
          RelationshipDataExtractor rel=new RelationshipDataExtractor();
          storeLayer.relationshipVisit(id,rel);
          for (PrimitiveIntIterator labels=labelsOf(rel.startNode()); labels.hasNext(); ) {
            int label=labels.next();
            counts.decrement(label,ANY_RELATIONSHIP_TYPE,ANY_LABEL);
            counts.decrement(label,rel.type(),ANY_LABEL);
          }
          for (PrimitiveIntIterator labels=labelsOf(rel.endNode()); labels.hasNext(); ) {
            int label=labels.next();
            counts.decrement(ANY_LABEL,ANY_RELATIONSHIP_TYPE,label);
            counts.decrement(ANY_LABEL,rel.type(),label);
          }
        }
 catch (        EntityNotFoundException e) {
          throw new IllegalStateException("Relationship being deleted should exist along with its nodes.",e);
        }
        recordState.relDelete(id);
      }
      private PrimitiveIntIterator labelsOf(      long nodeId) throws EntityNotFoundException {
        return StateHandlingStatementOperations.nodeGetLabels(storeLayer,txState,nodeId);
      }
      @Override public void visitNodePropertyChanges(      long id,      Iterator<DefinedProperty> added,      Iterator<DefinedProperty> changed,      Iterator<Integer> removed){
        while (removed.hasNext()) {
          recordState.nodeRemoveProperty(id,removed.next());
        }
        while (changed.hasNext()) {
          DefinedProperty prop=changed.next();
          recordState.nodeChangeProperty(id,prop.propertyKeyId(),prop.value());
        }
        while (added.hasNext()) {
          DefinedProperty prop=added.next();
          recordState.nodeAddProperty(id,prop.propertyKeyId(),prop.value());
        }
      }
      @Override public void visitRelPropertyChanges(      long id,      Iterator<DefinedProperty> added,      Iterator<DefinedProperty> changed,      Iterator<Integer> removed){
        while (removed.hasNext()) {
          recordState.relRemoveProperty(id,removed.next());
        }
        while (changed.hasNext()) {
          DefinedProperty prop=changed.next();
          recordState.relChangeProperty(id,prop.propertyKeyId(),prop.value());
        }
        while (added.hasNext()) {
          DefinedProperty prop=added.next();
          recordState.relAddProperty(id,prop.propertyKeyId(),prop.value());
        }
      }
      @Override public void visitGraphPropertyChanges(      Iterator<DefinedProperty> added,      Iterator<DefinedProperty> changed,      Iterator<Integer> removed){
        while (removed.hasNext()) {
          recordState.graphRemoveProperty(removed.next());
        }
        while (changed.hasNext()) {
          DefinedProperty prop=changed.next();
          recordState.graphChangeProperty(prop.propertyKeyId(),prop.value());
        }
        while (added.hasNext()) {
          DefinedProperty prop=added.next();
          recordState.graphAddProperty(prop.propertyKeyId(),prop.value());
        }
      }
      @Override public void visitNodeLabelChanges(      long id,      final Set<Integer> added,      final Set<Integer> removed){
        try {
          if (!(added.isEmpty() && removed.isEmpty())) {
            storeLayer.nodeVisitDegrees(id,new DegreeVisitor(){
              @Override public void visitDegree(              int type,              int outgoing,              int incoming){
                for (                Integer label : added) {
                  counts.updateCountsForRelationship(label,-1,-1,outgoing);
                  counts.updateCountsForRelationship(-1,-1,label,incoming);
                  counts.updateCountsForRelationship(label,type,-1,outgoing);
                  counts.updateCountsForRelationship(-1,type,label,incoming);
                }
                for (                Integer label : removed) {
                  counts.updateCountsForRelationship(label,-1,-1,-outgoing);
                  counts.updateCountsForRelationship(-1,-1,label,-incoming);
                  counts.updateCountsForRelationship(label,type,-1,-outgoing);
                  counts.updateCountsForRelationship(-1,type,label,-incoming);
                }
              }
            }
);
          }
        }
 catch (        EntityNotFoundException e) {
        }
        for (        Integer label : removed) {
          recordState.removeLabelFromNode(label,id);
        }
        for (        Integer label : added) {
          recordState.addLabelToNode(label,id);
        }
      }
      @Override public void visitAddedIndex(      IndexDescriptor element,      boolean isConstraintIndex){
        SchemaIndexProvider.Descriptor providerDescriptor=providerMap.getDefaultProvider().getProviderDescriptor();
        IndexRule rule;
        if (isConstraintIndex) {
          rule=IndexRule.constraintIndexRule(schemaStorage.newRuleId(),element.getLabelId(),element.getPropertyKeyId(),providerDescriptor,null);
        }
 else {
          rule=IndexRule.indexRule(schemaStorage.newRuleId(),element.getLabelId(),element.getPropertyKeyId(),providerDescriptor);
        }
        recordState.createSchemaRule(rule);
      }
      @Override public void visitRemovedIndex(      IndexDescriptor element,      boolean isConstraintIndex){
        try {
          SchemaStorage.IndexRuleKind kind=isConstraintIndex ? SchemaStorage.IndexRuleKind.CONSTRAINT : SchemaStorage.IndexRuleKind.INDEX;
          IndexRule rule=schemaStorage.indexRule(element.getLabelId(),element.getPropertyKeyId(),kind);
          recordState.dropSchemaRule(rule);
        }
 catch (        SchemaRuleNotFoundException e) {
          throw new ThisShouldNotHappenError("Tobias Lindaaker","Index to be removed should exist, since its existence should have " + "been validated earlier and the schema should have been locked.",e);
        }
      }
      @Override public void visitAddedConstraint(      UniquenessConstraint element){
        clearState.set(true);
        long constraintId=schemaStorage.newRuleId();
        IndexRule indexRule;
        try {
          indexRule=schemaStorage.indexRule(element.label(),element.propertyKeyId(),SchemaStorage.IndexRuleKind.CONSTRAINT);
        }
 catch (        SchemaRuleNotFoundException e) {
          throw new ThisShouldNotHappenError("Jacob Hansson","Index is always created for the constraint before this point.",e);
        }
        recordState.createSchemaRule(UniquenessConstraintRule.uniquenessConstraintRule(constraintId,element.label(),element.propertyKeyId(),indexRule.getId()));
        recordState.setConstraintIndexOwner(indexRule,constraintId);
      }
      @Override public void visitRemovedConstraint(      UniquenessConstraint element){
        try {
          clearState.set(true);
          UniquenessConstraintRule rule=schemaStorage.uniquenessConstraint(element.label(),element.propertyKeyId());
          recordState.dropSchemaRule(rule);
        }
 catch (        SchemaRuleNotFoundException e) {
          throw new ThisShouldNotHappenError("Tobias Lindaaker","Constraint to be removed should exist, since its existence should " + "have been validated earlier and the schema should have been locked.");
        }
        visitRemovedIndex(new IndexDescriptor(element.label(),element.propertyKeyId()),true);
      }
    }
);
    if (clearState.get()) {
      schemaState.clear();
    }
  }
}
