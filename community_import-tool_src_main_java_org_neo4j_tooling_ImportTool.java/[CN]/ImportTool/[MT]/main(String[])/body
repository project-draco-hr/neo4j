{
  Args args=new Args(incomingArguments);
  if (asksForUsage(args)) {
    printUsage();
    return;
  }
  FileSystemAbstraction fs=new DefaultFileSystemAbstraction();
  File storeDir;
  Collection<File[]> nodesFiles, relationshipsFiles;
  try {
    storeDir=args.interpretOption(STORE_DIR,Converters.<File>mandatory(),Converters.toFile(),Validators.DIRECTORY_IS_WRITABLE,Validators.CONTAINS_NO_EXISTING_DATABASE);
    nodesFiles=args.interpretOptions(NODE_DATA,Converters.<File[]>mandatory(),Converters.toFiles(MULTI_DELIMITER),Validators.FILES_EXISTS,Validators.<File>atLeast(1));
    relationshipsFiles=args.interpretOptions(RELATIONSHIP_DATA,Converters.<File[]>mandatory(),Converters.toFiles(MULTI_DELIMITER),Validators.FILES_EXISTS,Validators.<File>atLeast(1));
  }
 catch (  IllegalArgumentException e) {
    printUsage();
    throw new RuntimeException(e);
  }
  BatchImporter importer=new ParallelBatchImporter(storeDir.getPath(),DEFAULT,new SystemOutLogging(),ExecutionMonitors.defaultVisible());
  Input input=new CsvInput(DataFactories.data(nodesFiles),defaultFormatNodeFileHeader(),DataFactories.data(relationshipsFiles),defaultFormatRelationshipFileHeader(),args.interpretOption(ID_TYPE,withDefault(IdType.STRING),TO_ID_TYPE),csvConfiguration(args));
  boolean success=false;
  try {
    importer.doImport(input);
    success=true;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    if (!success) {
      try {
        StoreFile.fileOperation(FileOperation.DELETE,fs,storeDir,null,Iterables.<StoreFile,StoreFile>iterable(StoreFile.values()),false,false,StoreFileType.values());
      }
 catch (      IOException e) {
        System.err.println("Unable to delete store files after an aborted import " + e);
      }
    }
  }
}
