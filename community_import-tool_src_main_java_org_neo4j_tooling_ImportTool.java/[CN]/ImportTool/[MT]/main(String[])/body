{
  Args args=new Args(incomingArguments);
  if (asksForUsage(args)) {
    printUsage();
    return;
  }
  FileSystemAbstraction fs=new DefaultFileSystemAbstraction();
  File storeDir;
  Collection<Option<File[]>> nodesFiles, relationshipsFiles;
  try {
    storeDir=args.interpretOption(STORE_DIR,Converters.<File>mandatory(),Converters.toFile(),Validators.DIRECTORY_IS_WRITABLE,Validators.CONTAINS_NO_EXISTING_DATABASE);
    nodesFiles=args.interpretOptionsWithMetadata(NODE_DATA,Converters.<File[]>mandatory(),Converters.toFiles(MULTI_FILE_DELIMITER),Validators.FILES_EXISTS,Validators.<File>atLeast(1));
    relationshipsFiles=args.interpretOptionsWithMetadata(RELATIONSHIP_DATA,Converters.<File[]>mandatory(),Converters.toFiles(MULTI_FILE_DELIMITER),Validators.FILES_EXISTS,Validators.<File>atLeast(1));
  }
 catch (  IllegalArgumentException e) {
    printUsage();
    throw new RuntimeException(e);
  }
  LifeSupport life=new LifeSupport();
  Logging logging=life.add(new ClassicLoggingService(new Config(stringMap(store_dir.name(),storeDir.getAbsolutePath()))));
  life.start();
  BatchImporter importer=new ParallelBatchImporter(storeDir.getPath(),DEFAULT,logging,ExecutionMonitors.defaultVisible());
  Input input=new CsvInput(nodeData(nodesFiles),defaultFormatNodeFileHeader(),relationshipData(relationshipsFiles),defaultFormatRelationshipFileHeader(),args.interpretOption(ID_TYPE,withDefault(IdType.STRING),TO_ID_TYPE),csvConfiguration(args));
  boolean success=false;
  try {
    importer.doImport(input);
    success=true;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    life.shutdown();
    if (!success) {
      try {
        StoreFile.fileOperation(FileOperation.DELETE,fs,storeDir,null,Iterables.<StoreFile,StoreFile>iterable(StoreFile.values()),false,false,StoreFileType.values());
      }
 catch (      IOException e) {
        System.err.println("Unable to delete store files after an aborted import " + e);
      }
    }
  }
}
