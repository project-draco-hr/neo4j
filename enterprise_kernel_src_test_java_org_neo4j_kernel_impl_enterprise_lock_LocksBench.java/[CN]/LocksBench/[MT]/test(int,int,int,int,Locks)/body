{
  AtomicLong deadlocks=new AtomicLong();
  ExecutorService executor=Executors.newFixedThreadPool(numThreads);
  long start=System.currentTimeMillis();
  for (int i=numThreads; i-- > 0; ) {
    executor.execute(new Runnable(){
      private final Locks.Client client=lockManager.newClient();
      @Override public void run(){
        ThreadLocalRandom rand=ThreadLocalRandom.current();
        for (int i=iterations; i-- > 0; ) {
          try {
            for (int currentLock=0; currentLock < numLocks; currentLock++) {
              client.acquireExclusive(ResourceTypes.NODE,rand.nextInt(numResources));
            }
          }
 catch (          DeadlockDetectedException e) {
            deadlocks.incrementAndGet();
          }
          client.releaseAll();
        }
      }
    }
);
  }
  executor.shutdown();
  executor.awaitTermination(1,TimeUnit.HOURS);
  long delta=System.currentTimeMillis() - start;
  double locksPerSecond=((double)numLocks * numThreads * iterations) / (delta / 1000.0);
  System.out.println("Concurrency: " + numThreads);
  System.out.println("Locks per second: " + ((long)locksPerSecond));
  System.out.println("Deadlocks: " + deadlocks.get());
}
