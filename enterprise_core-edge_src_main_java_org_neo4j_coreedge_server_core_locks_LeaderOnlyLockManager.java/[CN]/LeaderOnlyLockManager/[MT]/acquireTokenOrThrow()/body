{
  LockToken currentToken=pendingLockTokensRequests.currentToken();
  if (myself.equals(currentToken.owner())) {
    return currentToken.id();
  }
  ensureLeader();
  ReplicatedLockTokenRequest<MEMBER> lockTokenRequest=new ReplicatedLockTokenRequest<>(myself,LockToken.nextCandidateId(currentToken.id()));
  try (PendingLockTokenRequest pendingLockTokenRequest=pendingLockTokensRequests.register(lockTokenRequest)){
    try {
      replicator.replicate(lockTokenRequest);
    }
 catch (    Replicator.ReplicationFailedException e) {
      throw new AcquireLockTimeoutException(e,"Could not acquire lock token.");
    }
    try {
      if (pendingLockTokenRequest.waitUntilAcquired(leaderLockTokenTimeout,MILLISECONDS)) {
        return lockTokenRequest.id();
      }
 else {
        throw new AcquireLockTimeoutException("Failed to acquire requested lock token.");
      }
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new AcquireLockTimeoutException(e,"Interrupted");
    }
catch (    TimeoutException e) {
      throw new AcquireLockTimeoutException("Failed to acquire requested lock token.");
    }
  }
 }
