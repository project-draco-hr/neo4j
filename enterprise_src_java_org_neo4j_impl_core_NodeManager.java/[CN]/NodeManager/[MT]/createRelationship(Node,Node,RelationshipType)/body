{
  if (startNode == null || endNode == null || type == null) {
    throw new IllegalArgumentException("Null parameter, startNode=" + startNode + ", endNode="+ endNode+ ", type="+ type);
  }
  if (!relTypeHolder.isValidRelationshipType(type)) {
    relTypeHolder.addValidRelationshipType(type.name(),true);
  }
  int startNodeId=(int)startNode.getId();
  NodeImpl firstNode=getLightNode(startNodeId);
  if (firstNode == null) {
    setRollbackOnly();
    throw new RuntimeException("First node[" + startNode.getId() + "] deleted");
  }
  int endNodeId=(int)endNode.getId();
  NodeImpl secondNode=getLightNode(endNodeId);
  if (secondNode == null) {
    setRollbackOnly();
    throw new RuntimeException("Second node[" + endNode.getId() + "] deleted");
  }
  int id=idGenerator.nextId(Relationship.class);
  RelationshipImpl rel=new RelationshipImpl(id,startNodeId,endNodeId,type,true,this);
  boolean firstNodeTaken=false;
  boolean secondNodeTaken=false;
  acquireLock(rel,LockType.WRITE);
  boolean success=false;
  try {
    acquireLock(firstNode,LockType.WRITE);
    firstNodeTaken=true;
    if (firstNode.isDeleted()) {
      setRollbackOnly();
      throw new IllegalStateException("" + startNode + " has been deleted in other transaction");
    }
    acquireLock(secondNode,LockType.WRITE);
    secondNodeTaken=true;
    if (secondNode.isDeleted()) {
      setRollbackOnly();
      throw new IllegalStateException("" + endNode + " has been deleted in other transaction");
    }
    int typeId=getRelationshipTypeIdFor(type);
    persistenceManager.relationshipCreate(id,typeId,startNodeId,endNodeId);
    firstNode.addRelationship(type,id);
    secondNode.addRelationship(type,id);
    relCache.add((int)rel.getId(),rel);
    success=true;
    return new RelationshipProxy(id,this);
  }
  finally {
    boolean releaseFailed=false;
    if (firstNodeTaken) {
      try {
        releaseLock(firstNode,LockType.WRITE);
      }
 catch (      Exception e) {
        releaseFailed=true;
        e.printStackTrace();
        log.severe("Failed to release lock");
      }
    }
    if (secondNodeTaken) {
      try {
        releaseLock(secondNode,LockType.WRITE);
      }
 catch (      Exception e) {
        releaseFailed=true;
        e.printStackTrace();
        log.severe("Failed to release lock");
      }
    }
    releaseLock(rel,LockType.WRITE);
    if (!success) {
      setRollbackOnly();
    }
    if (releaseFailed) {
      throw new RuntimeException("Unable to release locks [" + startNode + ","+ endNode+ "] in relationship create->"+ rel);
    }
  }
}
