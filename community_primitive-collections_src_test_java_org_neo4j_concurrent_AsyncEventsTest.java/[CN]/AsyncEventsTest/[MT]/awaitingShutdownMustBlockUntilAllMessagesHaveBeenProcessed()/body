{
  final Event specialShutdownObservedEvent=new Event();
  final CountDownLatch awaitStartLatch=new CountDownLatch(1);
  final EventConsumer consumer=new EventConsumer();
  final AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
  executor.submit(asyncEvents);
  do {
    asyncEvents.send(new Event());
  }
 while (consumer.eventsProcessed.take().processedBy == Thread.currentThread());
  Future<?> awaitShutdownFuture=executor.submit(new Runnable(){
    @Override public void run(){
      awaitStartLatch.countDown();
      try {
        asyncEvents.awaitTermination();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
      consumer.eventsProcessed.offer(specialShutdownObservedEvent);
    }
  }
);
  awaitStartLatch.await();
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.poll(20,TimeUnit.MILLISECONDS),is(nullValue()));
  asyncEvents.shutdown();
  awaitShutdownFuture.get();
  assertThat(consumer.eventsProcessed.take(),sameInstance(specialShutdownObservedEvent));
}
