{
  ConcurrentMap<Long,ForsetiLockManager.Lock> lockMap=lockMaps[resourceType.typeId()];
  Map<Long,Integer> heldShareLocks=sharedLockCounts[resourceType.typeId()];
  Map<Long,Integer> heldExclusiveLocks=exclusiveLockCounts[resourceType.typeId()];
  for (  long resourceId : resourceIds) {
    Integer heldCount=heldShareLocks.get(resourceId);
    if (heldCount != null) {
      heldShareLocks.put(resourceId,heldCount + 1);
      continue;
    }
    if (heldExclusiveLocks.containsKey(resourceId)) {
      heldShareLocks.put(resourceId,1);
      continue;
    }
    int tries=0;
    SharedLock mySharedLock=null;
    while (true) {
      ForsetiLockManager.Lock existingLock=lockMap.get(resourceId);
      if (existingLock == null) {
        if (mySharedLock == null) {
          mySharedLock=new SharedLock(this);
        }
        if (lockMap.putIfAbsent(resourceId,mySharedLock) == null) {
          break;
        }
 else {
          continue;
        }
      }
 else       if (existingLock instanceof SharedLock) {
        if (((SharedLock)existingLock).acquire(this)) {
          break;
        }
      }
 else       if (existingLock instanceof ExclusiveLock) {
      }
 else {
        throw new UnsupportedOperationException("Unknown lock type: " + existingLock);
      }
      waitStrategies[resourceType.typeId()].apply(tries++);
      markAsWaitingFor(existingLock,resourceType,resourceId);
    }
    clearWaitList();
    heldShareLocks.put(resourceId,1);
  }
}
