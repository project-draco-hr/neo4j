{
  return new IndexUpdater(){
    @Override public Reservation validate(    Iterable<NodePropertyUpdate> updates) throws IOException {
      return Reservation.EMPTY;
    }
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
switch (update.getUpdateMode()) {
case ADDED:
        String encodedValue=documentStructure.encodedStringValue(update.getValueAfter());
      sampler.include(encodedValue);
    break;
case CHANGED:
  String encodedValueBefore=documentStructure.encodedStringValue(update.getValueBefore());
sampler.exclude(encodedValueBefore);
String encodedValueAfter=documentStructure.encodedStringValue(update.getValueAfter());
sampler.include(encodedValueAfter);
break;
case REMOVED:
String removedValue=documentStructure.encodedStringValue(update.getValueBefore());
sampler.exclude(removedValue);
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
updates.add(update);
}
@Override public void close() throws IOException, IndexEntryConflictException, IndexCapacityExceededException {
if (updates.size() > queueThreshold) {
flush();
updates.clear();
}
}
@Override public void remove(PrimitiveLongSet nodeIds) throws IOException {
throw new UnsupportedOperationException("Should not remove() from populating index.");
}
}
;
}
