{
  return new IndexUpdater(){
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
switch (update.getUpdateMode()) {
case ADDED:
        Fieldable encodedValue=documentStructure.encodeAsFieldable(update.getValueAfter());
      sampler.include(encodedValue.stringValue());
    break;
case CHANGED:
  Fieldable encodedValueBefore=documentStructure.encodeAsFieldable(update.getValueBefore());
sampler.exclude(encodedValueBefore.stringValue());
Fieldable encodedValueAfter=documentStructure.encodeAsFieldable(update.getValueAfter());
sampler.include(encodedValueAfter.stringValue());
break;
case REMOVED:
Fieldable removedValue=documentStructure.encodeAsFieldable(update.getValueBefore());
sampler.exclude(removedValue.stringValue());
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
updates.add(update);
}
@Override public void close() throws IOException, IndexEntryConflictException {
if (updates.size() > queueThreshold) {
flush();
updates.clear();
}
}
@Override public void remove(Iterable<Long> nodeIds) throws IOException {
throw new UnsupportedOperationException("Should not remove() from populating index.");
}
}
;
}
