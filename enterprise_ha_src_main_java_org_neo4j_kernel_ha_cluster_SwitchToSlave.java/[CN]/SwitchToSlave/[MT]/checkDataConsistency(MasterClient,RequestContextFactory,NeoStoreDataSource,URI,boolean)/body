{
  TransactionIdStore txIdStore=nioneoDataSource.getDependencyResolver().resolveDependency(TransactionIdStore.class);
  try {
    console.log("Checking store consistency with master");
    checkMyStoreIdAndMastersStoreId(nioneoDataSource,masterIsOld);
    checkDataConsistencyWithMaster(masterUri,masterClient,nioneoDataSource,txIdStore);
    console.log("Store is consistent");
    RequestContext catchUpRequestContext=requestContextFactory.newRequestContext();
    console.log("Catching up with master. I'm at " + catchUpRequestContext);
    masterClient.pullUpdates(catchUpRequestContext,new TxHandler(){
      @Override public void accept(      CommittedTransactionRepresentation tx){
        long txId=tx.getCommitEntry().getTxId();
        if (txId % 10 == 0) {
          console.log("  ...still catching up with master, now at " + txId);
        }
      }
      @Override public void done(){
      }
    }
);
    console.log("Now consistent with master");
  }
 catch (  NoSuchLogVersionException e) {
    msgLog.logMessage("Cannot catch up to master by pulling updates, because I cannot find the archived " + "logical log file that has the transaction I would start from. I'm going to copy the whole " + "store from the master instead.");
    try {
      stopServicesAndHandleBranchedStore(config.get(HaSettings.branched_data_policy));
    }
 catch (    Throwable throwable) {
      msgLog.warn("Failed preparing for copying the store from the master instance",throwable);
    }
    throw e;
  }
catch (  StoreUnableToParticipateInClusterException upe) {
    console.log("The store is inconsistent. Will treat it as branched and fetch a new one from the master");
    msgLog.warn("Current store is unable to participate in the cluster; fetching new store from master",upe);
    try {
      stopServicesAndHandleBranchedStore(config.get(HaSettings.branched_data_policy));
    }
 catch (    IOException e) {
      msgLog.warn("Failed while trying to handle branched data",e);
    }
    throw upe;
  }
catch (  MismatchingStoreIdException e) {
    console.log("The store does not represent the same database as master. Will remove and fetch a new one from master");
    if (txIdStore.getLastCommittedTransactionId() == BASE_TX_ID) {
      msgLog.warn("Found and deleting empty store with mismatching store id",e);
      stopServicesAndHandleBranchedStore(BranchedDataPolicy.keep_none);
    }
 else {
      msgLog.error("Store cannot participate in cluster due to mismatching store IDs",e);
    }
    throw e;
  }
}
