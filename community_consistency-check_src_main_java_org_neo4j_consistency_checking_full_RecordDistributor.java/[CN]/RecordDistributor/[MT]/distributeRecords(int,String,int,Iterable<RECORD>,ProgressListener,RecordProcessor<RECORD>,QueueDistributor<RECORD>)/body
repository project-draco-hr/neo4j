{
  Iterator<RECORD> iterator=records.iterator();
  if (iterator.hasNext()) {
    processor.process(iterator.next());
    progress.add(1);
  }
 else {
    return;
  }
  final ArrayBlockingQueue<RECORD>[] recordQ=new ArrayBlockingQueue[numberOfThreads];
  final Workers<Worker<RECORD>> workers=new Workers<>(workerNames);
  final AtomicInteger idGroup=new AtomicInteger(-1);
  for (int threadId=0; threadId < numberOfThreads; threadId++) {
    recordQ[threadId]=new ArrayBlockingQueue<>(queueSize);
    workers.start(new Worker<>(threadId,idGroup,recordQ[threadId],processor));
  }
  final int[] recsProcessed=new int[numberOfThreads];
  RecordConsumer<RECORD> recordConsumer=new RecordConsumer<RECORD>(){
    @Override public void accept(    RECORD record,    int qIndex) throws InterruptedException {
      recordQ[qIndex].put(record);
      recsProcessed[qIndex]++;
    }
  }
;
  RECORD last=null;
  while (iterator.hasNext()) {
    try {
      RECORD record=iterator.next();
      if (!iterator.hasNext()) {
        last=record;
        break;
      }
      idDistributor.distribute(record,recordConsumer);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      break;
    }
    progress.add(1);
  }
  for (  Worker<RECORD> worker : workers) {
    worker.done();
  }
  try {
    workers.awaitAndThrowOnError(RuntimeException.class);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new RuntimeException("Was interrupted while awaiting completion");
  }
  if (last != null) {
    processor.process(last);
    progress.add(1);
  }
}
