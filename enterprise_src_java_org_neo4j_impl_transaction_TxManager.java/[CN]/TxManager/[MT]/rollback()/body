{
  if (!tmOk) {
    throw new SystemException("TM has encountered some problem, " + "please perform neccesary action (tx recovery/kernel restart)");
  }
  Thread thread=Thread.currentThread();
  if (!txThreadMap.containsKey(thread)) {
    throw new IllegalStateException("Not in transaction");
  }
  TransactionImpl tx=(TransactionImpl)txThreadMap.get(thread);
  if (tx.getStatus() == Status.STATUS_ACTIVE || tx.getStatus() == Status.STATUS_MARKED_ROLLBACK) {
    tx.doBeforeCompletion();
    try {
      tx.doRollback();
    }
 catch (    XAException e) {
      e.printStackTrace();
      log.severe("Unable to rollback marked or active transaction. " + "Some resources may be commited others not. " + "Kernel should be SHUTDOWN or FREEZED for "+ "resource maintance and transaction recovery ---->");
      tmOk=false;
      throw new SystemException("Unable to rollback " + " ---> error code for rollback: " + e.errorCode);
    }
    tx.doAfterCompletion();
    txThreadMap.remove(thread);
    try {
      getTxLog().txDone(tx.getGlobalId());
    }
 catch (    IOException e) {
      e.printStackTrace();
      log.severe("Error writing transaction log");
      tmOk=false;
      throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
    }
    tx.setStatus(Status.STATUS_NO_TRANSACTION);
  }
 else   if (tx.getStatus() == Status.STATUS_PREPARING) {
    tx.setStatus(Status.STATUS_MARKED_ROLLBACK);
    throw new RuntimeException("Should never be, not yet");
  }
 else {
    throw new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus()));
  }
}
