{
  boolean success=true;
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext;
  Throwable failure=null;
  Channel channel;
  ChannelBuffer output;
  ByteBuffer input;
  try {
    channelContext=getChannel(type);
    channel=channelContext.first();
    output=channelContext.second();
    input=channelContext.third();
  }
 catch (  Throwable e) {
    throw Exceptions.launderedException(ComException.class,e);
  }
  try {
    notifyRequestMonitor(type,context,channel);
    protocol.serializeRequest(channel,output,type,context,serializer);
    @SuppressWarnings("unchecked") Response<R> response=protocol.deserializeResponse((BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get("blockingHandler"),input,getReadTimeout(type,readTimeout),deserializer,resourcePoolReleaser);
    if (type.responseShouldBeUnpacked()) {
      responseUnpacker.unpackResponse(response,txHandler);
    }
    if (shouldCheckStoreId(type)) {
      if (specificStoreId != null) {
        assertCorrectStoreId(response.getStoreId(),specificStoreId);
      }
 else {
        assertCorrectStoreId(response.getStoreId(),storeId);
      }
    }
    return response;
  }
 catch (  ComException e) {
    failure=e;
    success=false;
    for (    ComExceptionHandler handler : comExceptionHandlers) {
      handler.handle(e);
    }
    throw e;
  }
catch (  Throwable e) {
    failure=e;
    success=false;
    if (channelContext != null) {
      closeChannel(channelContext);
    }
    throw Exceptions.launderedException(ComException.class,e);
  }
 finally {
    if (!success) {
      releaseChannel();
    }
    requestMonitor.endRequest(failure);
  }
}
