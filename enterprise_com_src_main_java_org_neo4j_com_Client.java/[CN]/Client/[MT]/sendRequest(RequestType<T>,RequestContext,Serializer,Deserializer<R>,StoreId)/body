{
  boolean success=true;
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext=null;
  Throwable failure=null;
  try {
    channelContext=getChannel(type);
    Channel channel=channelContext.first();
    ChannelBuffer output=channelContext.second();
    ByteBuffer input=channelContext.third();
    Map<String,String> requestContext=new HashMap<String,String>();
    requestContext.put("type",type.toString());
    requestContext.put("slaveContext",context.toString());
    requestContext.put("serverAddress",channel.getRemoteAddress().toString());
    requestMonitor.beginRequest(requestContext);
    protocol.serializeRequest(channel,output,type,context,serializer);
    @SuppressWarnings("unchecked") Response<R> response=protocol.deserializeResponse((BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get("blockingHandler"),input,getReadTimeout(type,readTimeout),deserializer,resourcePoolReleaser);
    if (shouldCheckStoreId(type)) {
      if (specificStoreId != null) {
        assertCorrectStoreId(response.getStoreId(),specificStoreId);
      }
 else {
        assertCorrectStoreId(response.getStoreId(),storeId);
      }
    }
    return response;
  }
 catch (  ComException e) {
    failure=e;
    success=false;
    for (    ComExceptionHandler handler : comExceptionHandlers) {
      handler.handle(e);
    }
    throw e;
  }
catch (  Throwable e) {
    failure=e;
    success=false;
    if (channelContext != null) {
      closeChannel(channelContext);
    }
    throw Exceptions.launderedException(ComException.class,e);
  }
 finally {
    if (!success) {
      releaseChannel();
    }
    requestMonitor.endRequest(failure);
  }
}
