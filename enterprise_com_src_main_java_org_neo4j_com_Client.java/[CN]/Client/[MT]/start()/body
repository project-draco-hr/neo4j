{
  bossExecutor=Executors.newCachedThreadPool(named(getClass().getSimpleName() + "-boss@" + address));
  workerExecutor=Executors.newCachedThreadPool(named(getClass().getSimpleName() + "-worker@" + address));
  bootstrap=new ClientBootstrap(new NioClientSocketChannelFactory(bossExecutor,workerExecutor));
  bootstrap.setPipelineFactory(this);
  channelPool=new ResourcePool<Triplet<Channel,ChannelBuffer,ByteBuffer>>(maxUnusedChannels,new ResourcePool.CheckStrategy.TimeoutCheckStrategy(ResourcePool.DEFAULT_CHECK_INTERVAL,SYSTEM_CLOCK),new LoggingResourcePoolMonitor(msgLog)){
    @Override protected Triplet<Channel,ChannelBuffer,ByteBuffer> create(){
      ChannelFuture channelFuture=bootstrap.connect(address);
      channelFuture.awaitUninterruptibly(5,TimeUnit.SECONDS);
      Triplet<Channel,ChannelBuffer,ByteBuffer> channel;
      if (channelFuture.isSuccess()) {
        channel=Triplet.of(channelFuture.getChannel(),ChannelBuffers.dynamicBuffer(),ByteBuffer.allocate(1024 * 1024));
        msgLog.logMessage("Opened a new channel to " + address,true);
        return channel;
      }
      String msg=Client.this.getClass().getSimpleName() + " could not connect to " + address;
      msgLog.logMessage(msg,true);
      ComException exception=new ComException(msg);
      throw exception;
    }
    @Override protected boolean isAlive(    Triplet<Channel,ChannelBuffer,ByteBuffer> resource){
      return resource.first().isConnected();
    }
    @Override protected void dispose(    Triplet<Channel,ChannelBuffer,ByteBuffer> resource){
      Channel channel=resource.first();
      if (channel.isConnected()) {
        msgLog.debug("Closing channel: " + channel + ". Channel pool size is now "+ channelPool.currentSize());
        channel.close();
      }
    }
  }
;
  resourcePoolReleaser=new ResourceReleaser(){
    @Override public void release(){
      if (channelPool != null)       channelPool.release();
    }
  }
;
}
