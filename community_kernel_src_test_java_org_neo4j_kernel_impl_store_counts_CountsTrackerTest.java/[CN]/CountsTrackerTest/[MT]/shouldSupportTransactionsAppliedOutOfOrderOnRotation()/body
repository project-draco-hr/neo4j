{
  final CountsTracker tracker=the.managed(newTracker());
  try (CountsAccessor.Updater tx=tracker.apply(2).get()){
    tx.incrementNodeCount(1,1);
  }
   try (CountsAccessor.Updater tx=tracker.apply(4).get()){
    tx.incrementNodeCount(1,1);
  }
   Future<Long> rotated=threading.executeAndAwait(new Rotation(2),tracker,new Predicate<Thread>(){
    @Override public boolean accept(    Thread thread){
switch (thread.getState()) {
case BLOCKED:
case WAITING:
case TIMED_WAITING:
case TERMINATED:
        return true;
default :
      return false;
  }
}
}
,10,SECONDS);
try (CountsAccessor.Updater tx=tracker.apply(5).get()){
tx.incrementNodeCount(1,1);
}
 try (CountsAccessor.Updater tx=tracker.apply(3).get()){
tx.incrementNodeCount(1,1);
}
 assertEquals("rotated transaction",4,rotated.get().longValue());
assertEquals("stored transaction",4,tracker.txId());
assertEquals("count",4,tracker.nodeCount(1,Registers.newDoubleLongRegister()).readSecond());
CountsVisitor visitor=mock(CountsVisitor.class);
tracker.visitFile(tracker.currentFile(),visitor);
verify(visitor).visitNodeCount(1,3);
verifyNoMoreInteractions(visitor);
assertEquals("final rotation",5,tracker.rotate(5));
}
