{
  ByteArrayOutputStream output=new ByteArrayOutputStream();
  ExecutionResultSerializer serializer=new ExecutionResultSerializer(output,null,NullLogProvider.getInstance());
  Notification notification=NotificationCode.CARTESIAN_PRODUCT.notification(InputPosition.empty);
  List<Notification> notifications=Arrays.asList(notification);
  Result executionResult=mockExecutionResult(null,notifications,map("column1","value1","column2","value2"));
  serializer.transactionCommitUri(URI.create("commit/uri/1"));
  serializer.statementResult(executionResult,false);
  serializer.notifications(notifications);
  serializer.finish();
  String result=output.toString(UTF_8.name());
  assertEquals("{\"commit\":\"commit/uri/1\",\"results\":[{\"columns\":[\"column1\",\"column2\"]," + "\"data\":[{\"row\":[\"value1\",\"value2\"]}]}],\"notifications\":[{\"code\":\"Neo" + ".ClientNotification.Statement.CartesianProduct\",\"severity\":\"WARNING\",\"title\":\"This "+ "query builds a cartesian product between disconnected patterns.\",\"description\":\"If a "+ "part of a query contains multiple disconnected patterns, this will build a cartesian product"+ " between all those parts. This may produce a large amount of data and slow down query "+ "processing. While occasionally intended, it may often be possible to reformulate the query "+ "that avoids the use of this cross product, perhaps by adding a relationship between the "+ "different parts or by using OPTIONAL MATCH\"}],\"errors\":[]}",result);
}
