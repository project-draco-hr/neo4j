{
  if (neoStore != null) {
    fs.clear();
  }
  config=new Config(stringMap(GraphDatabaseSettings.dense_node_threshold.name(),"" + denseNodeThreshold));
  @SuppressWarnings("deprecation") StoreFactory storeFactory=new StoreFactory(config,idGeneratorFactory,windowPoolFactory,fs.get(),DEV_NULL,new DefaultTxHook());
  neoStore=storeFactory.createNeoStore(new File("neostore"));
  lockMocks.clear();
  locks=mock(LockService.class,new Answer(){
    @Override public synchronized Object answer(    final InvocationOnMock invocation) throws Throwable {
      if (invocation.getMethod().getName().equals("acquireNodeLock")) {
        final Lock mock=mock(Lock.class,new Answer(){
          @Override public Object answer(          InvocationOnMock invocationOnMock) throws Throwable {
            return null;
          }
        }
);
        lockMocks.add(mock);
        return mock;
      }
 else {
        return null;
      }
    }
  }
);
  cacheAccessBackDoor=mock(CacheAccessBackDoor.class);
  mockIndexing=mock(IndexingService.class);
  TransactionAppender appenderMock=mock(TransactionAppender.class);
  Future<Long> futureMock=mock(Future.class);
  when(futureMock.get()).thenReturn(3l);
  when(appenderMock.append(Matchers.<TransactionRepresentation>any())).thenReturn(futureMock);
  this.commitProcess=new TransactionRepresentationCommitProcess(appenderMock,mock(KernelHealth.class),mockIndexing,mock(LabelScanStore.class),neoStore,cacheAccessBackDoor,locks,false);
}
