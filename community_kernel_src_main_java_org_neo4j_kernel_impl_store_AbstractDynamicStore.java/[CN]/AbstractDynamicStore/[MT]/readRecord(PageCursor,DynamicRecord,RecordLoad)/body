{
  long firstInteger=cursor.getUnsignedInt();
  boolean isStartRecord=(firstInteger & 0x80000000) == 0;
  boolean inUse=(firstInteger & 0x10000000) != 0;
  if (mode.shouldLoad(inUse)) {
    int dataSize=getRecordSize() - AbstractDynamicStore.RECORD_HEADER_SIZE;
    int nrOfBytes=(int)(firstInteger & 0xFFFFFF);
    long nextBlock=cursor.getUnsignedInt();
    long nextModifier=(firstInteger & 0xF000000L) << 8;
    long longNextBlock=CommonAbstractStore.longFromIntAndMod(nextBlock,nextModifier);
    record.initialize(inUse,isStartRecord,longNextBlock,-1,nrOfBytes);
    if (longNextBlock != Record.NO_NEXT_BLOCK.intValue() && nrOfBytes < dataSize || nrOfBytes > dataSize) {
      int blockDataSize=getRecordSize() - getRecordHeaderSize();
      mode.report(format("Next block set[%d] current block illegal size[%d/%d]",record.getNextBlock(),record.getLength(),blockDataSize));
    }
    if (record.getLength() == 0) {
      record.setData(NO_DATA);
      return;
    }
    int len=record.getLength();
    byte[] data=record.getData();
    if (data == null || data.length != len) {
      data=new byte[len];
    }
    cursor.getBytes(data);
    record.setData(data);
  }
}
