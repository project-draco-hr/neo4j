{
  LifeSupport life=new LifeSupport();
  Map<String,String> params=new HashMap<>();
  params.put(ClusterSettings.server_id.name(),"-1");
  params.put(ClusterSettings.cluster_name.name(),clusterName);
  params.put(ClusterSettings.initial_hosts.name(),from);
  params.put(ClusterSettings.instance_name.name(),"Backup");
  params.put(ClusterClient.clusterJoinTimeout.name(),"20s");
  final Config config=null;
  ObjectStreamFactory objectStreamFactory=new ObjectStreamFactory();
  Monitors monitors=new Monitors();
  final ClusterClient clusterClient=life.add(new ClusterClient(monitors,ClusterClient.adapt(config),logging,new NotElectableElectionCredentialsProvider(),objectStreamFactory,objectStreamFactory));
  ClusterMemberEvents events=life.add(new PaxosClusterMemberEvents(clusterClient,clusterClient,clusterClient,clusterClient,new SystemOutLogging(),Predicates.<PaxosClusterMemberEvents.ClusterMembersSnapshot>alwaysTrue(),new HANewSnapshotFunction(),objectStreamFactory,objectStreamFactory,monitors.newMonitor(NamedThreadFactory.Monitor.class)));
  clusterClient.addClusterListener(new ClusterListener.Adapter(){
    @Override public void enteredCluster(    ClusterConfiguration clusterConfiguration){
      clusterClient.performRoleElections();
      clusterClient.removeClusterListener(this);
    }
  }
);
  final Semaphore infoReceivedLatch=new Semaphore(0);
  final AtomicReference<URI> backupUri=new AtomicReference<>();
  events.addClusterMemberListener(new ClusterMemberListener.Adapter(){
    Map<InstanceId,URI> backupUris=new HashMap<>();
    InstanceId master=null;
    @Override public void memberIsAvailable(    String role,    InstanceId clusterUri,    URI roleUri,    StoreId storeId){
      if (master != null && backupUris.containsKey(master)) {
        backupUri.set(backupUris.get(master));
        infoReceivedLatch.release();
      }
    }
    /** 
 * Called when new master has been elected. The new master may not be available a.t.m.
 * A call to {@link #memberIsAvailable} will confirm that the master given in
 * the most recent {@link #coordinatorIsElected(org.neo4j.cluster.InstanceId)} call is up and running as
 * master.
 * @param coordinatorId the connection information to the master.
 */
    @Override public void coordinatorIsElected(    InstanceId coordinatorId){
    }
  }
);
  try {
    life.start();
    if (!infoReceivedLatch.tryAcquire(20,TimeUnit.SECONDS)) {
      throw new RuntimeException("Could not find backup server in cluster " + clusterName + " at "+ from+ ", "+ "operation timed out");
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  LifecycleException e) {
    Throwable ex=Exceptions.peel(e,Predicates.<Throwable>instanceOf(LifecycleException.class));
    if (ex != null && ex instanceof ClusterEntryDeniedException) {
      throw new RuntimeException("Another backup client is currently performing backup; concurrent backups" + " are not allowed");
    }
    ex=Exceptions.peel(e,Predicates.<Throwable>instanceOf(TimeoutException.class));
    if (ex != null) {
      throw new RuntimeException("Could not find backup server in cluster " + clusterName + " at "+ from+ ", "+ "operation timed out");
    }
 else {
      throw new RuntimeException(Exceptions.peel(e,new Predicate<Throwable>(){
        @Override public boolean test(        Throwable item){
          return !(item instanceof LifecycleException);
        }
      }
));
    }
  }
 finally {
    life.shutdown();
  }
  return backupUri.get().toString();
}
