{
  LifeSupport life=new LifeSupport();
  Map<String,String> params=new HashMap<String,String>();
  params.put(HaSettings.server_id.name(),"-1");
  params.put(ClusterSettings.cluster_name.name(),clusterName);
  params.put(ClusterSettings.initial_hosts.name(),from);
  params.put(ClusterSettings.cluster_discovery_enabled.name(),"false");
  final Config config=new Config(params,ClusterSettings.class,OnlineBackupSettings.class);
  ClusterClient clusterClient=life.add(new ClusterClient(ClusterClient.adapt(config),logging,new BackupElectionCredentialsProvider()));
  HighAvailabilityEvents events=life.add(new PaxosHighAvailabilityEvents(PaxosHighAvailabilityEvents.adapt(config),clusterClient,StringLogger.SYSTEM));
  final Semaphore infoReceivedLatch=new Semaphore(0);
  final ClusterInfoHolder addresses=new ClusterInfoHolder();
  events.addHighAvailabilityEventListener(new HighAvailabilityListener(){
    @Override public void masterIsElected(    URI masterUri){
    }
    @Override public void memberIsAvailable(    String role,    URI masterClusterUri,    Iterable<URI> masterURIs){
      if (HighAvailabilityEvents.MASTER.equals(role)) {
        addresses.held=masterURIs;
        infoReceivedLatch.release();
      }
    }
  }
);
  life.start();
  try {
    if (!infoReceivedLatch.tryAcquire(10,TimeUnit.SECONDS)) {
      throw new RuntimeException("Could not find master in cluster " + clusterName + " at "+ from+ ", "+ "operation timed out");
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
 finally {
    life.shutdown();
  }
  String backupAddress=null;
  for (  URI uri : addresses.held) {
    if ("backup".equals(uri.getScheme())) {
      backupAddress=uri.toString();
      break;
    }
  }
  return backupAddress;
}
