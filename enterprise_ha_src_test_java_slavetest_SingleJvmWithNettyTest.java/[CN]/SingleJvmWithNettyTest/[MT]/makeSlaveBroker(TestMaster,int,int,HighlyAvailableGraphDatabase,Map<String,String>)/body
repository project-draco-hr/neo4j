{
  config.put("server_id",Integer.toString(id));
  final Machine masterMachine=new Machine(masterId,-1,1,-1,"localhost:" + Protocol.PORT,0);
  int readTimeout=getConfigInt(config,HaSettings.read_timeout.name(),TEST_READ_TIMEOUT);
  final Master client=new MasterClient18(masterMachine.getServer().first(),masterMachine.getServer().other(),db.getMessageLog(),AbstractBroker.storeId,ConnectionLostHandler.NO_ACTION,readTimeout,getConfigInt(config,HaSettings.lock_read_timeout.name(),readTimeout),Client.DEFAULT_MAX_NUMBER_OF_CONCURRENT_CHANNELS_PER_CLIENT);
  return new AbstractBroker(new Config(new ConfigurationDefaults(GraphDatabaseSettings.class,HaSettings.class).apply(config))){
    public boolean iAmMaster(){
      return false;
    }
    public Pair<Master,Machine> getMasterReally(    boolean allowChange){
      if (allowChange)       cachedMasterOverride=null;
      return getMasterPair();
    }
    public Pair<Master,Machine> getMaster(){
      return cachedMasterOverride != null ? cachedMasterOverride : getMasterPair();
    }
    private Pair<Master,Machine> getMasterPair(){
      return Pair.of(client,masterMachine);
    }
    public Object instantiateMasterServer(    GraphDatabaseAPI graphDb){
      throw new UnsupportedOperationException("cannot instantiate master server on slave");
    }
    @Override public Object instantiateSlaveServer(    GraphDatabaseAPI graphDb,    SlaveDatabaseOperations ops){
      int machineId=getMyMachineId();
      int port=FakeSlaveBroker.LOW_SLAVE_PORT + machineId;
      SlaveServer server=new SlaveServer(new SlaveImpl(graphDb,this,ops),port,graphDb.getMessageLog());
      masterBroker.addSlave(new SlaveClient(machineId,"localhost",port,graphDb.getMessageLog(),getClusterStoreId(false),10));
      return server;
    }
  }
;
}
