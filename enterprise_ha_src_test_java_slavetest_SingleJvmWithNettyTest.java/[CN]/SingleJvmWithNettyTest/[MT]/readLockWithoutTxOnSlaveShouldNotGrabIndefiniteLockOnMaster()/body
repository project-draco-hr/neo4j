{
  final long lockTimeout=1;
  initializeDbs(1,stringMap(CONFIG_KEY_LOCK_READ_TIMEOUT,String.valueOf(lockTimeout)));
  final long[] id=new long[1];
  final Fetcher<DoubleLatch> latchFetcher=getDoubleLatch();
  Thread lockHolder=new Thread(new Runnable(){
    @Override public void run(){
      DoubleLatch latch=latchFetcher.fetch();
      try {
        final GraphDatabaseService slaveDb=getSlave(0);
        Node node;
        Transaction tx=slaveDb.beginTx();
        try {
          node=slaveDb.createNode();
          tx.success();
        }
  finally {
          tx.finish();
        }
        ((GraphDatabaseSPI)slaveDb).getLockManager().getReadLock(node);
        ((GraphDatabaseSPI)slaveDb).getLockReleaser().addLockToTransaction(node,LockType.READ);
        id[0]=node.getId();
        latch.countDownFirst();
        latch.awaitSecond();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
 finally {
        try {
          latch.countDownFirst();
          latch.awaitSecond();
        }
 catch (        RemoteException e) {
          e.printStackTrace();
        }
      }
    }
  }
,"slaveLockHolder");
  lockHolder.start();
  final DoubleLatch latch=latchFetcher.fetch();
  latch.awaitFirst();
  final HighlyAvailableGraphDatabase masterDb=getMasterHaDb();
  final Transaction tx=masterDb.beginTx();
  try {
    long startTime=System.currentTimeMillis();
    masterDb.getNodeById(id[0]).setProperty("name","David");
    long duration=System.currentTimeMillis() - startTime;
    latch.countDownSecond();
    assertTrue("Read lock was acquired but not released.",duration < lockTimeout * 1000);
  }
  finally {
    tx.finish();
  }
}
