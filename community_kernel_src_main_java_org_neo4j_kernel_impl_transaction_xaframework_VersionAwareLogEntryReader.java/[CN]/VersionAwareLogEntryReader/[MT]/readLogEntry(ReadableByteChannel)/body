{
  byte version=1;
  byteBuffer.clear();
  byteBuffer.limit(1);
  if (channel.read(byteBuffer) != byteBuffer.limit()) {
    return null;
  }
  byteBuffer.flip();
  byte type=byteBuffer.get();
  if (type < 0) {
    byteBuffer.clear();
    byteBuffer.limit(1);
    if (channel.read(byteBuffer) != byteBuffer.limit()) {
      return null;
    }
    byteBuffer.flip();
    version=type;
    type=byteBuffer.get();
  }
  try {
switch (type) {
case LogEntry.TX_START:
      return readTxStartEntry(version,channel);
case LogEntry.TX_PREPARE:
    return readTxPrepareEntry(version,channel);
case LogEntry.TX_1P_COMMIT:
  return readTxOnePhaseCommitEntry(version,channel);
case LogEntry.TX_2P_COMMIT:
return readTxTwoPhaseCommitEntry(version,channel);
case LogEntry.COMMAND:
return readTxCommandEntry(version,channel);
case LogEntry.DONE:
return readTxDoneEntry(version,channel);
case LogEntry.EMPTY:
return null;
default :
throw new IOException("Unknown entry[" + type + "]");
}
}
 catch (ReadPastEndException e) {
return null;
}
}
