{
  OperationContext operationContext=sessionPool.acquireSession();
  ReplicatedTransaction transaction;
  try {
    transaction=createImmutableReplicatedTransaction(tx.transactionRepresentation(),operationContext.globalSession(),operationContext.localOperationId());
  }
 catch (  IOException e) {
    throw new TransactionFailureException("Could not create immutable transaction for replication",e);
  }
  RetryStrategy.Timeout timeout=retryStrategy.newTimeout();
  boolean hasNeverReplicated=true;
  boolean interrupted=false;
  try (CommittingTransaction futureTxId=txFutures.register(operationContext.localOperationId())){
    for (long numberOfRetries=1; true; numberOfRetries++) {
      log.info("Replicating transaction %s, attempt: %d ",operationContext,numberOfRetries);
      try {
        replicator.replicate(transaction);
        hasNeverReplicated=false;
      }
 catch (      ReplicationFailedException e) {
        if (hasNeverReplicated) {
          throw new TransactionFailureException(CouldNotCommit,"Failed to replicate transaction",e);
        }
        log.warn("Transaction replication failed, but a previous attempt may have succeeded," + "so commit process must keep waiting for possible success.",e);
        txRetryMonitor.retry();
      }
      try {
        Long txId=futureTxId.waitUntilCommitted(timeout.getMillis(),TimeUnit.MILLISECONDS);
        sessionPool.releaseSession(operationContext);
        return txId;
      }
 catch (      InterruptedException e) {
        interrupted=true;
        log.info("Replication of %s was interrupted; retrying.",operationContext);
        txRetryMonitor.retry();
      }
catch (      TimeoutException e) {
        log.info("Replication of %s timed out after %d %s; retrying.",operationContext,timeout.getMillis(),TimeUnit.MILLISECONDS);
        timeout.increment();
        txRetryMonitor.retry();
      }
    }
  }
  finally {
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
  }
}
