{
  OperationContext operationContext=sessionPool.acquireSession();
  ReplicatedTransaction transaction;
  try {
    transaction=createImmutableReplicatedTransaction(tx.transactionRepresentation(),operationContext.globalSession(),operationContext.localOperationId());
  }
 catch (  IOException e) {
    throw new TransactionFailureException("Could not create immutable object for replication",e);
  }
  while (true) {
    final Future<Long> futureTxId=replicatedTxListener.getFutureTxId(operationContext.localOperationId());
    try {
      int currentLockSessionId=currentReplicatedLockState.currentLockSession().id();
      int txLockSessionId=tx.transactionRepresentation().getLockSessionId();
      if (currentLockSessionId != txLockSessionId) {
        throw new TransactionFailureException(LockSessionInvalid,"The lock session in the cluster has changed: " + "[current lock session id:%d, tx lock session id:%d]",currentLockSessionId,txLockSessionId);
      }
      replicator.replicate(transaction);
      Long txId=futureTxId.get(retryIntervalMillis,TimeUnit.MILLISECONDS);
      sessionPool.releaseSession(operationContext);
      return txId;
    }
 catch (    InterruptedException|TimeoutException e) {
      futureTxId.cancel(false);
    }
catch (    ReplicationFailedException|ExecutionException e) {
      futureTxId.cancel(false);
      throw new TransactionFailureException("Failed to replicate transaction",e);
    }
    log.info("Retrying replication: " + operationContext);
  }
}
