{
  ConsistencyCheck consistency=diffs.applyToAll(new ConsistencyCheck(diffs){
    @Override protected <R extends AbstractBaseRecord>void report(    RecordStore<R> recordStore,    R record,    String message){
      StringBuilder log=messageHeader("Inconsistencies");
      logRecord(log,recordStore,record);
      log.append(message);
      msgLog.logMessage(log.toString());
    }
    @Override protected <R1 extends AbstractBaseRecord,R2 extends AbstractBaseRecord>void report(    RecordStore<R1> recordStore,    R1 record,    RecordStore<? extends R2> referredStore,    R2 referred,    String message){
      if (recordStore == referredStore && record.getLongId() == referred.getLongId()) {
        report(recordStore,record,message);
        return;
      }
      StringBuilder log=messageHeader("Inconsistencies");
      logRecord(log,recordStore,record);
      logRecord(log,referredStore,referred);
      log.append(message);
      msgLog.logMessage(log.toString());
    }
  }
);
  try {
    consistency.checkResult();
  }
 catch (  AssertionError e) {
    DataInconsistencyError error=new DataInconsistencyError("Cannot apply transaction\n\t" + startEntry + "\n\t"+ commitEntry+ "\n\t"+ e.getMessage());
    msgLog.logMessage(error.getMessage());
    if (rejectInconsistentTransactions) {
      startEntry=null;
      commitEntry=null;
      logEntries.clear();
      throw error;
    }
 else {
      final StringBuilder changes=messageHeader("Changes");
      diffs.applyToAll(new RecordStore.Processor(){
        @Override protected <R extends AbstractBaseRecord>void processRecord(        Class<R> type,        RecordStore<R> store,        R record){
          DiffRecordStore<R> diff=(DiffRecordStore<R>)store;
          if (diff.isModified(record.getLongId())) {
            logRecord(changes,store,record);
          }
        }
      }
);
      msgLog.logMessage(changes.toString());
    }
  }
}
