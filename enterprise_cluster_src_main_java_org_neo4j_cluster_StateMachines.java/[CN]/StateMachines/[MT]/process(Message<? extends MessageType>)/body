{
  stateMachineExecutor.execute(new Runnable(){
    OutgoingMessageHolder temporaryOutgoing=new OutgoingMessageHolder();
    @Override public void run(){
      monitor.beganProcessing(message);
      lock.writeLock().lock();
      try {
synchronized (timeouts) {
          StateMachine stateMachine=stateMachines.get(message.getMessageType().getClass());
          if (stateMachine == null) {
            return;
          }
          stateMachine.handle(message,temporaryOutgoing);
          Message<? extends MessageType> tempMessage;
          while ((tempMessage=temporaryOutgoing.nextOutgoingMessage()) != null) {
            outgoing.offer(tempMessage);
          }
          Message<? extends MessageType> outgoingMessage;
          List<Message<? extends MessageType>> toSend=new LinkedList<Message<? extends MessageType>>();
          try {
            while ((outgoingMessage=outgoing.nextOutgoingMessage()) != null) {
              message.copyHeadersTo(outgoingMessage,CONVERSATION_ID,CREATED_BY);
              for (              MessageProcessor outgoingProcessor : outgoingProcessors) {
                try {
                  if (!outgoingProcessor.process(outgoingMessage)) {
                    break;
                  }
                }
 catch (                Throwable e) {
                  log.warn("Outgoing message processor threw exception",e);
                }
              }
              if (outgoingMessage.hasHeader(Message.TO)) {
                outgoingMessage.setHeader(Message.INSTANCE_ID,instanceIdHeaderValue);
                toSend.add(outgoingMessage);
              }
 else {
                StateMachine internalStatemachine=stateMachines.get(outgoingMessage.getMessageType().getClass());
                if (internalStatemachine != null) {
                  internalStatemachine.handle((Message)outgoingMessage,temporaryOutgoing);
                  while ((tempMessage=temporaryOutgoing.nextOutgoingMessage()) != null) {
                    outgoing.offer(tempMessage);
                  }
                }
              }
            }
            if (!toSend.isEmpty()) {
              sender.process(toSend);
            }
          }
 catch (          Exception e) {
            log.warn("Error processing message " + message,e);
          }
        }
      }
  finally {
        lock.writeLock().unlock();
      }
      executor.drain();
      monitor.finishedProcessing(message);
    }
  }
);
  return true;
}
