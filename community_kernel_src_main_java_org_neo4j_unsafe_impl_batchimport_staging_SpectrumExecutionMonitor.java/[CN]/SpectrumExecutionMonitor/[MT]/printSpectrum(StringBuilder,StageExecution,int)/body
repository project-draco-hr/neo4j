{
  long[] values=values(execution);
  long total=total(values);
  width-=values.length + 1 + 4;
  Pair<Step<?>,Float> bottleNeck=execution.stepsOrderedBy(Keys.avg_processing_time,false).iterator().next();
  QuantizedProjection projection=new QuantizedProjection(total,width);
  long lastDoneBatches=0;
  int stepIndex=0;
  for (  Step<?> step : execution.steps()) {
    StepStats stats=step.stats();
    if (!projection.next(avg(stats))) {
      break;
    }
    long stepWidth=total == 0 && stepIndex == 0 ? width : projection.step();
    boolean isBottleNeck=bottleNeck.first() == step;
    String name=(isBottleNeck ? "*" : "") + stats.toString(DetailLevel.IMPORTANT) + (step.numberOfProcessors() > 1 ? "(" + step.numberOfProcessors() + ")" : "");
    builder.append(stepIndex++ == 0 ? '[' : '|');
    int charIndex=0;
    char backgroundChar=step.numberOfProcessors() > 1 ? '=' : '-';
    for (int i=0; i < stepWidth; i++, charIndex++) {
      char ch=backgroundChar;
      if (charIndex >= 0 && charIndex < name.length() && charIndex < stepWidth) {
        ch=name.charAt(charIndex);
      }
      builder.append(ch);
    }
    lastDoneBatches=stats.stat(Keys.done_batches).asLong();
  }
  long progress=lastDoneBatches * execution.getConfig().batchSize();
  builder.append("]").append(fitInFour(progress));
  return true;
}
