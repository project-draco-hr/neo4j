{
  if (lockingThread == waitingThread) {
    StringBuffer circle=null;
    Object resource=null;
    do {
      lockingThread=(Thread)graphStack.pop();
      resource=graphStack.pop();
      if (circle == null) {
        circle=new StringBuffer();
        circle.append(lockingThread + " <- " + resource);
      }
 else {
        circle.append(" <- " + lockingThread + " <- "+ resource);
      }
    }
 while (!graphStack.isEmpty());
    throw new DeadlockDetectedException(waitingThread + " can't wait on resource " + resource+ " since => "+ circle);
  }
  checkedThreads.add(lockingThread);
  Object resource=waitingThreadMap.get(lockingThread);
  if (resource != null) {
    graphStack.push(resource);
    List<Thread> lockingThreadList=resourceMap.get(resource);
    if (lockingThreadList != null) {
      Iterator<Thread> itr=lockingThreadList.iterator();
      while (itr.hasNext()) {
        lockingThread=itr.next();
        if (!checkedThreads.contains(lockingThread)) {
          graphStack.push(lockingThread);
          checkWaitOnRecursive(lockingThread,waitingThread,checkedThreads,graphStack);
          graphStack.pop();
        }
      }
    }
    graphStack.pop();
  }
}
