{
  AtomicBoolean afterInit=new AtomicBoolean();
  final DoubleLatch latch=new DoubleLatch();
  raftLog=new DelegatingRaftLog(raftLog){
    @Override public long readEntryTerm(    long logIndex) throws IOException {
      if (afterInit.get()) {
        latch.start();
        latch.awaitFinish();
      }
      return super.readEntryTerm(logIndex);
    }
  }
;
  raftLog.append(entry0);
  raftLog.append(entry1);
  raftLog.append(entry2);
  raftLog.append(entry3);
  startLogShipper();
  afterInit.set(true);
  outbound.clear();
  Thread pruningThread=new Thread("Pruning"){
    @Override public void run(){
      try {
        latch.awaitStart();
        raftLog.prune(2);
        latch.finish();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
;
  pruningThread.start();
  logShipper.onMatch(1,new LeaderContext(0,0));
  assertTrue(outbound.hasAnyEntriesTo(follower));
  assertThat(outbound.sentTo(follower),hasMessage(new RaftMessages.LogCompactionInfo<>(leader,0,1,storeId)));
  pruningThread.join();
}
