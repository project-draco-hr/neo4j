{
  if (commandIndex <= lastCommittedIndex) {
    log.debug("Ignoring transaction at log index %d since already committed up to %d",commandIndex,lastCommittedIndex);
    return Optional.empty();
  }
  TransactionRepresentation tx;
  byte[] extraHeader=encodeLogIndexAsTxHeader(commandIndex);
  tx=ReplicatedTransactionFactory.extractTransactionRepresentation(replicatedTx,extraHeader);
  int currentTokenId=lockTokenStateMachine.currentToken().id();
  int txLockSessionId=tx.getLockSessionId();
  if (currentTokenId != txLockSessionId && txLockSessionId != Locks.Client.NO_LOCK_SESSION_ID) {
    return Optional.of(Result.of(new TransactionFailureException(LockSessionExpired,"The lock session in the cluster has changed: [current lock session id:%d, tx lock session id:%d]",currentTokenId,txLockSessionId)));
  }
  try {
    long txId=commitProcess.commit(new TransactionToApply(tx),CommitEvent.NULL,TransactionApplicationMode.EXTERNAL);
    return Optional.of(Result.of(txId));
  }
 catch (  TransactionFailureException e) {
    throw new IllegalStateException("Failed to locally commit a transaction that has already been " + "committed to the RAFT log. This server cannot process later transactions and needs to be " + "restarted once the underlying cause has been addressed.",e);
  }
}
