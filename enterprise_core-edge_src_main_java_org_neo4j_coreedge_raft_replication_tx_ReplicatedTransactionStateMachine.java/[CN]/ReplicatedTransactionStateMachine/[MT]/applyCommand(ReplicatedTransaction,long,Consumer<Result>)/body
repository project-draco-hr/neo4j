{
  if (commandIndex <= lastCommittedIndex) {
    log.debug("Ignoring transaction at log index %d since already committed up to %d",commandIndex,lastCommittedIndex);
    return;
  }
  TransactionRepresentation tx;
  byte[] extraHeader=encodeLogIndexAsTxHeader(commandIndex);
  tx=ReplicatedTransactionFactory.extractTransactionRepresentation(replicatedTx,extraHeader);
  int currentTokenId=lockTokenStateMachine.currentToken().id();
  int txLockSessionId=tx.getLockSessionId();
  if (currentTokenId != txLockSessionId && txLockSessionId != Locks.Client.NO_LOCK_SESSION_ID) {
    callback.accept(Result.of(new TransactionFailureException(LockSessionExpired,"The lock session in the cluster has changed: [current lock session id:%d, tx lock session id:%d]",currentTokenId,txLockSessionId)));
  }
 else {
    try {
      long txId=commitProcess.commit(new TransactionToApply(tx),CommitEvent.NULL,TransactionApplicationMode.EXTERNAL);
      callback.accept(Result.of(txId));
    }
 catch (    TransactionFailureException e) {
      throw new IllegalStateException("Failed to locally commit a transaction that has already been " + "committed to the RAFT log. This server cannot process later transactions and needs to be " + "restarted once the underlying cause has been addressed.",e);
    }
  }
}
