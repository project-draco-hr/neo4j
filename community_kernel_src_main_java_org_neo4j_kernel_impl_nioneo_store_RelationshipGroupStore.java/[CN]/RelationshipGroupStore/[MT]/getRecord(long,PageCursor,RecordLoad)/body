{
  cursor.setOffset(offsetForId(id));
  long inUseByte=cursor.getByte();
  boolean inUse=(inUseByte & 0x1) > 0;
  if (!inUse) {
switch (load) {
case NORMAL:
      throw new InvalidRecordException("Record[" + id + "] not in use");
case CHECK:
    return null;
}
}
long highByte=cursor.getByte();
int type=cursor.getShort();
long nextLowBits=cursor.getUnsignedInt();
long nextOutLowBits=cursor.getUnsignedInt();
long nextInLowBits=cursor.getUnsignedInt();
long nextLoopLowBits=cursor.getUnsignedInt();
long owningNode=cursor.getUnsignedInt() | (((long)cursor.getByte()) << 32);
long nextMod=(inUseByte & 0xE) << 31;
long nextOutMod=(inUseByte & 0x70) << 28;
long nextInMod=(highByte & 0xE) << 31;
long nextLoopMod=(highByte & 0x70) << 28;
RelationshipGroupRecord record=new RelationshipGroupRecord(id,type);
record.setInUse(inUse);
record.setNext(longFromIntAndMod(nextLowBits,nextMod));
record.setFirstOut(longFromIntAndMod(nextOutLowBits,nextOutMod));
record.setFirstIn(longFromIntAndMod(nextInLowBits,nextInMod));
record.setFirstLoop(longFromIntAndMod(nextLoopLowBits,nextLoopMod));
record.setOwningNode(owningNode);
return record;
}
