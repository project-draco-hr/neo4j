{
  String path="target/hcdb";
  File hcdb=new File(path);
  FileUtils.deleteRecursively(hcdb);
  Process process=Runtime.getRuntime().exec(new String[]{ProcessUtil.getJavaExecutable().toString(),"-cp",ProcessUtil.getClassPath(),Inserter.class.getName(),path});
  awaitFile(new File(path,"started"));
  Thread.sleep(5000);
  process.destroy();
  process.waitFor();
  final GraphDatabaseService db=new TestGraphDatabaseFactory().newEmbeddedDatabase(hcdb);
  try (Transaction transaction=db.beginTx()){
    assertTrue(db.index().existsForNodes("myIndex"));
    Index<Node> index=db.index().forNodes("myIndex");
    for (    Node node : db.getAllNodes()) {
      for (      String key : node.getPropertyKeys()) {
        String value=(String)node.getProperty(key);
        boolean found=false;
        for (        Node indexedNode : index.get(key,value)) {
          if (indexedNode.equals(node)) {
            found=true;
            break;
          }
        }
        if (!found) {
          throw new IllegalStateException(node + " has property '" + key+ "'='"+ value+ "', but not in index");
        }
      }
    }
  }
 catch (  Throwable e) {
    if (Exceptions.contains(e,CorruptIndexException.class) || exceptionContainsStackTraceElementFromPackage(e,"org.apache.lucene")) {
      System.err.println("Lucene exception happened during recovery after a real crash. " + "It may be that the index is corrupt somehow and this is out of control and not " + "something this test can reall improve on right now. Printing the exception for reference");
      e.printStackTrace();
      return;
    }
    throw e;
  }
  Thread t=new Thread(){
    @Override public void run(){
      try (Transaction tx=db.beginTx()){
        Index<Node> index=db.index().forNodes("myIndex");
        index.add(db.createNode(),"one","two");
        tx.success();
      }
     }
  }
;
  t.start();
  t.join();
  db.shutdown();
}
