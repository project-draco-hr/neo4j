{
  long defragCount=0;
  long[] freedBatch=new long[recordsPerPage];
  int startingId=getNumberOfReservedLowIds();
  int defragged;
  boolean done=false;
  while (!done && cursor.next()) {
    long idPageOffset=(cursor.getCurrentPageId() * recordsPerPage);
    do {
      defragged=0;
      done=false;
      for (int i=startingId; i < recordsPerPage; i++) {
        int offset=i * blockSize;
        cursor.setOffset(offset);
        long recordId=idPageOffset + i;
        if (recordId >= foundHighId) {
          done=true;
          break;
        }
        if (!isInUse(cursor)) {
          freedBatch[defragged++]=recordId;
        }
 else         if (isRecordReserved(cursor)) {
          cursor.setOffset(offset);
          cursor.putByte(Record.NOT_IN_USE.byteValue());
          cursor.putInt(0);
          freedBatch[defragged++]=recordId;
        }
      }
    }
 while (cursor.shouldRetry());
    checkIdScanCursorBounds(cursor);
    for (int i=0; i < defragged; i++) {
      freeId(freedBatch[i]);
    }
    defragCount+=defragged;
    startingId=0;
  }
  return defragCount;
}
