{
  this.fileSystem=fileSystem;
  this.monitors=monitors;
  this.writerFactory=writerFactory;
  this.logger=logging.getMessagesLog(getClass());
  this.neo4jConfig=configForStoreDir(new Config(stringMap(dense_node_threshold.name(),valueOf(config.denseNodeThreshold())),GraphDatabaseSettings.class),storeDir);
  this.pageCache=new BatchingPageCache(fileSystem,config.fileChannelBufferSize(),config.bigFileChannelBufferSizeMultiplier(),writerFactory,writeMonitor);
  this.neoStore=newNeoStore(pageCache);
  flushNeoStoreAndAwaitEverythingWritten();
  if (alreadyContainsData(neoStore)) {
    neoStore.close();
    throw new IllegalStateException(storeDir + " already contains data, cannot do import here");
  }
  try {
    neoStore.rebuildCountStoreIfNeeded();
  }
 catch (  IOException e) {
    throw new UnderlyingStorageException(e);
  }
  neoStore.setLastCommittedAndClosedTransactionId(initialIds.lastCommittedTransactionId(),initialIds.lastCommittedTransactionChecksum());
  this.propertyKeyRepository=new BatchingPropertyKeyTokenRepository(neoStore.getPropertyKeyTokenStore(),initialIds.highPropertyKeyTokenId());
  this.labelRepository=new BatchingLabelTokenRepository(neoStore.getLabelTokenStore(),initialIds.highLabelTokenId());
  this.relationshipTypeRepository=new BatchingRelationshipTypeTokenRepository(neoStore.getRelationshipTypeTokenStore(),initialIds.highRelationshipTypeTokenId());
  Dependencies dependencies=new Dependencies();
  dependencies.satisfyDependency(neo4jConfig);
  dependencies.satisfyDependency(fileSystem);
  dependencies.satisfyDependency(this);
  dependencies.satisfyDependency(logging);
  @SuppressWarnings({"unchecked","rawtypes"}) KernelExtensions extensions=life.add(new KernelExtensions((Iterable)Service.load(KernelExtensionFactory.class),dependencies,UnsatisfiedDependencyStrategies.ignore()));
  life.start();
  labelScanStore=life.add(extensions.resolveDependency(LabelScanStoreProvider.class,LabelScanStoreProvider.HIGHEST_PRIORITIZED).getLabelScanStore());
}
