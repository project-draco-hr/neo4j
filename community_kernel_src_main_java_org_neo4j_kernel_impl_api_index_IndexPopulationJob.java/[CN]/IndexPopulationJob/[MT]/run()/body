{
  String oldThreadName=currentThread().getName();
  currentThread().setName(format("Index populator on %s [runs on: %s]",indexUserDescription,oldThreadName));
  boolean success=false;
  Throwable failureCause=null;
  try {
    try {
      log.info("Index population started: [%s]",indexUserDescription);
      populator.create();
      storeView.replaceIndexCounts(descriptor,0,0,0);
      indexAllNodes();
      verifyDeferredConstraints();
      if (cancelled) {
        storeView.replaceIndexCounts(descriptor,0,0,0);
        return;
      }
      Callable<Void> duringFlip=new Callable<Void>(){
        @Override public Void call() throws Exception {
          populateFromQueueIfAvailable(Long.MAX_VALUE);
          DoubleLongRegister result=Registers.newDoubleLongRegister();
          long indexSize=populator.sampleResult(result);
          storeView.replaceIndexCounts(descriptor,result.readFirst(),result.readSecond(),indexSize);
          populator.close(true);
          updateableSchemaState.clear();
          return null;
        }
      }
;
      flipper.flip(duringFlip,failureDelegate);
      success=true;
      log.info("Index population completed. Index is now online: [%s]",indexUserDescription);
    }
 catch (    Throwable t) {
      if (t instanceof IndexPopulationFailedKernelException) {
        Throwable cause=t.getCause();
        if (cause instanceof IndexEntryConflictException) {
          t=cause;
        }
      }
      if (!(t instanceof IndexEntryConflictException)) {
        log.error(format("Failed to populate index: [%s]",indexUserDescription),t);
      }
      failureCause=t;
      flipper.flipTo(new FailedIndexProxy(descriptor,config,providerDescriptor,indexUserDescription,populator,failure(t),indexCountsRemover,logProvider));
    }
 finally {
      try {
        if (!success) {
          if (failureCause != null) {
            populator.markAsFailed(failure(failureCause).asString());
          }
          populator.close(false);
        }
      }
 catch (      Throwable e) {
        log.error(format("Unable to close failed populator for index: [%s]",indexUserDescription),e);
      }
    }
  }
  finally {
    doneSignal.countDown();
    currentThread().setName(oldThreadName);
  }
}
