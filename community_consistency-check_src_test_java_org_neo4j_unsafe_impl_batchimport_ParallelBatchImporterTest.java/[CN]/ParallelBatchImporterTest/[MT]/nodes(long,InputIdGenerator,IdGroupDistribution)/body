{
  return new InputIterable<InputNode>(){
    private int calls;
    @Override public InputIterator<InputNode> iterator(){
      calls++;
      assertTrue("Unexpected use of input iterator " + multiPassIterators + ", "+ calls,multiPassIterators || (!multiPassIterators && calls == 1));
      return new SimpleInputIterator<InputNode>("test nodes"){
        private int cursor;
        @Override protected InputNode fetchNextOrNull(){
          if (cursor < count) {
            Object nodeId=inputIdGenerator.nextNodeId();
            Object[] properties=new Object[]{"name","Nisse " + cursor,"age",10,"long-string","OK here goes... a long string that will certainly end up in a dynamic " + "record1234567890!@#$%^&*()_|","array",new long[]{1234567890123L,987654321987L,123456789123L,987654321987L},"id",nodeId};
            try {
              Group group=groups.groupOf(cursor);
              return new InputNode(sourceDescription,itemNumber,itemNumber,group,nodeId,properties,null,LABELS,null);
            }
  finally {
              cursor++;
            }
          }
          return null;
        }
      }
;
    }
    @Override public boolean supportsMultiplePasses(){
      return multiPassIterators;
    }
  }
;
}
