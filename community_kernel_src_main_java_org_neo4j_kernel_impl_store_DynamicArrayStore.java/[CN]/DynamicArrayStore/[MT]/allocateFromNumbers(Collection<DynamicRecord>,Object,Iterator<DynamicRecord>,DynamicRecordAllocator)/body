{
  Class<?> componentType=array.getClass().getComponentType();
  boolean isPrimitiveByteArray=componentType.equals(Byte.TYPE);
  boolean isByteArray=componentType.equals(Byte.class) || isPrimitiveByteArray;
  ShortArray type=ShortArray.typeOf(array);
  if (type == null) {
    throw new IllegalArgumentException(array + " not a valid array type.");
  }
  int arrayLength=Array.getLength(array);
  int requiredBits=isByteArray ? Byte.SIZE : type.calculateRequiredBitsForArray(array,arrayLength);
  int totalBits=requiredBits * arrayLength;
  int numberOfBytes=(totalBits - 1) / 8 + 1;
  int bitsUsedInLastByte=totalBits % 8;
  bitsUsedInLastByte=bitsUsedInLastByte == 0 ? 8 : bitsUsedInLastByte;
  numberOfBytes+=NUMBER_HEADER_SIZE;
  byte[] bytes;
  if (isByteArray) {
    bytes=new byte[NUMBER_HEADER_SIZE + arrayLength];
    bytes[0]=(byte)type.intValue();
    bytes[1]=(byte)bitsUsedInLastByte;
    bytes[2]=(byte)requiredBits;
    if (isPrimitiveByteArray) {
      arraycopy(array,0,bytes,NUMBER_HEADER_SIZE,arrayLength);
    }
 else {
      Byte[] source=(Byte[])array;
      for (int i=0; i < source.length; i++) {
        bytes[NUMBER_HEADER_SIZE + i]=source[i];
      }
    }
  }
 else {
    Bits bits=Bits.bits(numberOfBytes);
    bits.put((byte)type.intValue());
    bits.put((byte)bitsUsedInLastByte);
    bits.put((byte)requiredBits);
    type.writeAll(array,arrayLength,requiredBits,bits);
    bytes=bits.asBytes();
  }
  allocateRecordsFromBytes(target,bytes,recordsToUseFirst,recordAllocator);
}
