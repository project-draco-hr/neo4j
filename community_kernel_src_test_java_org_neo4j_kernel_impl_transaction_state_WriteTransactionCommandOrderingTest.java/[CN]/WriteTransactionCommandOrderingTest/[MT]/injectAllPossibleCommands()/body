{
  NeoStoreTransactionContext context=mock(NeoStoreTransactionContext.class);
  RecordChanges<Integer,LabelTokenRecord,Void> labelTokenChanges=mock(RecordChanges.class);
  RecordChanges<Integer,RelationshipTypeTokenRecord,Void> relationshipTypeTokenChanges=mock(RecordChanges.class);
  RecordChanges<Integer,PropertyKeyTokenRecord,Void> propertyKeyTokenChanges=mock(RecordChanges.class);
  RecordChanges<Long,NodeRecord,Void> nodeRecordChanges=mock(RecordChanges.class);
  RecordChanges<Long,RelationshipRecord,Void> relationshipRecordChanges=mock(RecordChanges.class);
  RecordChanges<Long,PropertyRecord,PrimitiveRecord> propertyRecordChanges=mock(RecordChanges.class);
  RecordChanges<Long,RelationshipGroupRecord,Integer> relationshipGroupChanges=mock(RecordChanges.class);
  RecordChanges<Long,Collection<DynamicRecord>,SchemaRule> schemaRuleChanges=mock(RecordChanges.class);
  when(context.getLabelTokenRecords()).thenReturn(labelTokenChanges);
  when(context.getRelationshipTypeTokenRecords()).thenReturn(relationshipTypeTokenChanges);
  when(context.getPropertyKeyTokenRecords()).thenReturn(propertyKeyTokenChanges);
  when(context.getNodeRecords()).thenReturn(nodeRecordChanges);
  when(context.getRelRecords()).thenReturn(relationshipRecordChanges);
  when(context.getPropertyRecords()).thenReturn(propertyRecordChanges);
  when(context.getRelGroupRecords()).thenReturn(relationshipGroupChanges);
  when(context.getSchemaRuleChanges()).thenReturn(schemaRuleChanges);
  List<RecordProxy<Long,NodeRecord,Void>> nodeChanges=new LinkedList<>();
  RecordChange<Long,NodeRecord,Void> deletedNode=mock(RecordChange.class);
  when(deletedNode.getBefore()).thenReturn(inUseNode());
  when(deletedNode.forReadingLinkage()).thenReturn(missingNode());
  nodeChanges.add(deletedNode);
  RecordChange<Long,NodeRecord,Void> createdNode=mock(RecordChange.class);
  when(createdNode.getBefore()).thenReturn(missingNode());
  when(createdNode.forReadingLinkage()).thenReturn(createdNode());
  nodeChanges.add(createdNode);
  RecordChange<Long,NodeRecord,Void> updatedNode=mock(RecordChange.class);
  when(updatedNode.getBefore()).thenReturn(inUseNode());
  when(updatedNode.forReadingLinkage()).thenReturn(inUseNode());
  nodeChanges.add(updatedNode);
  when(nodeRecordChanges.changes()).thenReturn(nodeChanges);
  when(nodeRecordChanges.changeSize()).thenReturn(3);
  when(labelTokenChanges.changes()).thenReturn(Collections.<RecordProxy<Integer,LabelTokenRecord,Void>>emptyList());
  when(relationshipTypeTokenChanges.changes()).thenReturn(Collections.<RecordProxy<Integer,RelationshipTypeTokenRecord,Void>>emptyList());
  when(propertyKeyTokenChanges.changes()).thenReturn(Collections.<RecordProxy<Integer,PropertyKeyTokenRecord,Void>>emptyList());
  when(relationshipRecordChanges.changes()).thenReturn(Collections.<RecordProxy<Long,RelationshipRecord,Void>>emptyList());
  when(propertyRecordChanges.changes()).thenReturn(Collections.<RecordProxy<Long,PropertyRecord,PrimitiveRecord>>emptyList());
  when(relationshipGroupChanges.changes()).thenReturn(Collections.<RecordProxy<Long,RelationshipGroupRecord,Integer>>emptyList());
  when(schemaRuleChanges.changes()).thenReturn(Collections.<RecordProxy<Long,Collection<DynamicRecord>,SchemaRule>>emptyList());
  return new TransactionRecordState(mock(NeoStores.class),mock(IntegrityValidator.class),context);
}
