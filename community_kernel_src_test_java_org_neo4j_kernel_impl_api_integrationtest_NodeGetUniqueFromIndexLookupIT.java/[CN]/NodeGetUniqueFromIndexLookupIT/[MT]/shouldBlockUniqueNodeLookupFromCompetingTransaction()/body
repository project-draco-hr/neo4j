{
  final DoubleLatch latch=new DoubleLatch();
  DependencyResolver resolver=db.getDependencyResolver();
  Locks manager=resolver.resolveDependency(Locks.class);
  final IndexDescriptor index=createUniquenessConstraint();
  final String value="value";
  DataWriteOperations dataStatement=dataWriteOperationsInNewTransaction();
  long nodeId=dataStatement.nodeCreate();
  dataStatement.nodeAddLabel(nodeId,labelId);
  dataStatement.nodeSetProperty(nodeId,Property.stringProperty(propertyKeyId,value));
  Runnable runnableForThread2=new Runnable(){
    @Override public void run(){
      latch.awaitStart();
      try (Transaction tx=db.beginTx()){
        try (Statement statement=statementContextSupplier.get()){
          statement.readOperations().nodeGetUniqueFromIndexLookup(index,value);
        }
         tx.success();
      }
 catch (      IndexNotFoundKernelException|IndexBrokenKernelException e) {
        throw new RuntimeException(e);
      }
 finally {
        latch.finish();
      }
    }
  }
;
  Thread thread2=new Thread(runnableForThread2,"Transaction Thread 2");
  thread2.start();
  latch.start();
  spinUntilBlocking:   for (; ; ) {
    if (thread2.getState() == Thread.State.TIMED_WAITING || thread2.getState() == Thread.State.WAITING) {
      break;
    }
    Thread.yield();
  }
  commit();
  latch.awaitFinish();
}
