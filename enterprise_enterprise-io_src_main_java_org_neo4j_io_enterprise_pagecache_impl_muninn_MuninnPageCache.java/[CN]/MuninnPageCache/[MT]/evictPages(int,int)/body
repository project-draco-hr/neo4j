{
  Thread currentThread=Thread.currentThread();
  while (pageCountToEvict > 0 && !currentThread.isInterrupted()) {
    if (clockArm == pages.length) {
      clockArm=0;
    }
    MuninnPage page=pages[clockArm];
    if (page == null) {
      currentThread.interrupt();
      return 0;
    }
    if (page.isLoaded() && page.decrementUsage()) {
      long stamp=page.tryWriteLock();
      if (stamp != 0) {
        PageSwapper swapper=page.getSwapper();
        long filePageId=page.getFilePageId();
        boolean pageEvicted=false;
        try {
          page.evict();
          pageCountToEvict--;
          evictorException=null;
          pageEvicted=true;
        }
 catch (        IOException ioException) {
          evictorException=ioException;
        }
catch (        OutOfMemoryError ignore) {
          evictorException=oomException;
        }
catch (        Throwable throwable) {
          evictorException=new IOException("Eviction thread encountered a problem",throwable);
        }
 finally {
          page.unlockWrite(stamp);
        }
        if (pageEvicted) {
          swapper.evicted(filePageId);
          monitor.evicted(filePageId,swapper);
          MuninnPage next;
          do {
            next=freelist.get();
            page.nextFree=next;
          }
 while (!freelist.compareAndSet(next,page));
        }
      }
    }
    clockArm++;
  }
  return clockArm;
}
