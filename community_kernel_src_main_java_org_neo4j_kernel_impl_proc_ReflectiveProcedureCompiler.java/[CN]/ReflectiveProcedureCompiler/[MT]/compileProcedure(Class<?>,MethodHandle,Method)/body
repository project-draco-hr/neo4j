{
  ProcedureName procName=extractName(procDefinition,method);
  List<FieldSignature> inputSignature=inputSignatureDeterminer.signatureFor(method);
  OutputMapper outputMapper=outputMappers.mapper(method);
  MethodHandle procedureMethod=lookup.unreflect(method);
  List<FieldInjections.FieldSetter> setters=fieldInjections.setters(procDefinition);
  ProcedureSignature.Mode mode=ProcedureSignature.Mode.READ_ONLY;
  Optional<String> description=description(method);
  Procedure procedure=method.getAnnotation(Procedure.class);
  if (procedure.mode().equals(Procedure.Mode.DBMS)) {
    mode=ProcedureSignature.Mode.DBMS;
  }
 else   if (procedure.mode().equals(Procedure.Mode.SCHEMA)) {
    mode=ProcedureSignature.Mode.SCHEMA_WRITE;
  }
 else   if (procedure.mode().equals(Procedure.Mode.WRITE)) {
    mode=ProcedureSignature.Mode.READ_WRITE;
  }
  if (method.isAnnotationPresent(PerformsWrites.class)) {
    if (!procedure.mode().equals(Procedure.Mode.DEFAULT)) {
      throw new ProcedureException(Status.Procedure.ProcedureRegistrationFailed,"Conflicting procedure annotation, cannot use PerformsWrites and mode");
    }
 else {
      mode=ProcedureSignature.Mode.READ_WRITE;
    }
  }
  String deprecatedBy=procedure.deprecatedBy().trim();
  Optional<String> deprecated=Optional.empty();
  if (method.isAnnotationPresent(Deprecated.class)) {
    deprecated=Optional.of(deprecatedBy);
  }
 else   if (!deprecatedBy.isEmpty()) {
    log.warn("Use of @Procedure(deprecatedBy) without @Deprecated in " + procName);
    deprecated=Optional.of(deprecatedBy);
  }
  ProcedureSignature signature=new ProcedureSignature(procName,inputSignature,outputMapper.signature(),mode,deprecated,procedure.allowed(),description);
  return new ReflectiveProcedure(signature,constructor,procedureMethod,outputMapper,setters);
}
