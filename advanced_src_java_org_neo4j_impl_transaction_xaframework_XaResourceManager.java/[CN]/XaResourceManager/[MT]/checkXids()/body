{
  Iterator<Xid> keyIterator=xidMap.keySet().iterator();
  LinkedList<Xid> xids=new LinkedList<Xid>();
  while (keyIterator.hasNext()) {
    xids.add(keyIterator.next());
  }
  Collections.sort(xids,new Comparator<Xid>(){
    public int compare(    Xid o1,    Xid o2){
      Integer id1=txOrderMap.get(o1);
      Integer id2=txOrderMap.get(o2);
      if (id1 == null && id2 == null) {
        return 0;
      }
      if (id1 == null) {
        return Integer.MAX_VALUE;
      }
      if (id2 == null) {
        return Integer.MIN_VALUE;
      }
      return id1 - id2;
    }
  }
);
  txOrderMap=null;
  Logger logger=Logger.getLogger(tf.getClass().getName());
  while (!xids.isEmpty()) {
    Xid xid=xids.removeFirst();
    XidStatus status=xidMap.get(xid);
    TransactionStatus txStatus=status.getTransactionStatus();
    XaTransaction xaTransaction=txStatus.getTransaction();
    int identifier=xaTransaction.getIdentifier();
    if (xaTransaction.isRecovered()) {
      if (txStatus.commitStarted()) {
        logger.fine("(Re-)committing tx " + identifier);
        try {
          xaTransaction.commit();
        }
 catch (        XAException e) {
          e.printStackTrace();
          throw new IOException("Unable to commit one-phase transaction " + identifier + ", "+ e);
        }
        log.doneInternal(identifier);
        xidMap.remove(xid);
        recoveredTxCount--;
      }
 else       if (!txStatus.prepared()) {
        logger.fine("Rolling back non prepared tx " + identifier);
        log.doneInternal(xaTransaction.getIdentifier());
        xidMap.remove(xid);
        recoveredTxCount--;
      }
    }
  }
  checkIfRecoveryComplete();
}
