{
  buffer.clear();
  buffer.limit(2);
  if (channel.read(buffer) != buffer.limit()) {
    return null;
  }
  buffer.flip();
  byte commandType=buffer.get();
  byte entityTypeByte=buffer.get();
  if (commandType == CREATE_INDEX_COMMAND) {
    buffer.clear();
    String name=PrimitiveUtils.readLengthAndString(channel,buffer);
    if (name == null) {
      return null;
    }
    int size=PrimitiveUtils.readInt(channel,buffer);
    Map<String,String> config=new HashMap<String,String>();
    for (int i=0; i < size; i++) {
      String key=PrimitiveUtils.readLengthAndString(channel,buffer);
      String value=PrimitiveUtils.readLengthAndString(channel,buffer);
      if (key == null || value == null) {
        return null;
      }
      config.put(key,value);
    }
    return new CreateIndexCommand(entityTypeByte,name,config);
  }
 else {
    buffer.clear();
    buffer.limit(17);
    if (channel.read(buffer) != buffer.limit()) {
      return null;
    }
    buffer.flip();
    EntityType entityType=null;
    if (entityTypeByte == NODE) {
      entityType=dataSource.nodeEntityType;
    }
 else     if (entityTypeByte == RELATIONSHIP) {
      entityType=dataSource.relationshipEntityType;
    }
 else {
      return null;
    }
    int indexNameLength=buffer.getInt();
    long entityId=buffer.getLong();
    int keyCharLength=buffer.getInt();
    byte valueType=buffer.get();
    String indexName=PrimitiveUtils.readString(channel,buffer,indexNameLength);
    if (indexName == null) {
      return null;
    }
    String key=null;
    if (keyCharLength != -1) {
      key=PrimitiveUtils.readString(channel,buffer,keyCharLength);
      if (key == null) {
        return null;
      }
    }
    Object value=null;
    if (valueType >= VALUE_TYPE_INT && valueType <= VALUE_TYPE_DOUBLE) {
switch (valueType) {
case VALUE_TYPE_INT:
        value=PrimitiveUtils.readInt(channel,buffer);
      break;
case VALUE_TYPE_LONG:
    value=PrimitiveUtils.readLong(channel,buffer);
  break;
case VALUE_TYPE_FLOAT:
value=PrimitiveUtils.readFloat(channel,buffer);
break;
case VALUE_TYPE_DOUBLE:
value=PrimitiveUtils.readDouble(channel,buffer);
break;
}
}
 else if (valueType == VALUE_TYPE_STRING) {
value=PrimitiveUtils.readLengthAndString(channel,buffer);
}
if (valueType != VALUE_TYPE_NULL && value == null) {
return null;
}
Long startNodeId=null;
Long endNodeId=null;
if (commandType == ADD_COMMAND && entityTypeByte == RELATIONSHIP) {
startNodeId=PrimitiveUtils.readLong(channel,buffer);
endNodeId=PrimitiveUtils.readLong(channel,buffer);
if (startNodeId == null || endNodeId == null) {
return null;
}
}
IndexIdentifier identifier=new IndexIdentifier(entityTypeByte,entityType,indexName,dataSource.indexStore.get(entityType.getType(),indexName));
switch (commandType) {
case ADD_COMMAND:
return entityTypeByte == NODE ? new AddCommand(identifier,entityTypeByte,entityId,key,value) : new AddRelationshipCommand(identifier,entityTypeByte,new RelationshipId(entityId,startNodeId,endNodeId),key,value);
case REMOVE_COMMAND:
return new RemoveCommand(identifier,entityTypeByte,entityId,key,value);
case DELETE_COMMAND:
return new DeleteCommand(identifier);
default :
throw new IOException("Unknown command type[" + commandType + "]");
}
}
}
