{
  final PropertyContainer endNode=mock(Node.class);
  final PropertyContainer alternativeEndNode=mock(Node.class);
  final Node startNode=mock(Node.class);
  Evaluator evaluator=mock(Evaluator.class);
  TraversalBranch branch=mock(TraversalBranch.class);
  TraversalBranch alternativeBranch=mock(TraversalBranch.class);
  when(branch.iterator()).thenAnswer(new IteratorAnswer(endNode));
  when(alternativeBranch.iterator()).thenAnswer(new IteratorAnswer(alternativeEndNode));
  when(alternativeBranch.startNode()).thenReturn(startNode);
  when(evaluator.evaluate(Mockito.any(Path.class))).thenReturn(Evaluation.INCLUDE_AND_CONTINUE);
  StandardBranchCollisionDetector collisionDetector=new StandardBranchCollisionDetector(evaluator,new Predicate<Path>(){
    @Override public boolean test(    Path path){
      return alternativeEndNode.equals(path.endNode()) && startNode.equals(path.startNode());
    }
  }
);
  Collection<Path> incoming=collisionDetector.evaluate(branch,Direction.INCOMING);
  Collection<Path> outgoing=collisionDetector.evaluate(branch,Direction.OUTGOING);
  Collection<Path> alternativeIncoming=collisionDetector.evaluate(alternativeBranch,Direction.INCOMING);
  Collection<Path> alternativeOutgoing=collisionDetector.evaluate(alternativeBranch,Direction.OUTGOING);
  assertThat(incoming,nullValue());
  assertThat(outgoing,nullValue());
  assertThat(alternativeIncoming,nullValue());
  assertThat(alternativeOutgoing,hasSize(1));
}
