{
  try {
    final long logIndex=source.getLong();
    final int sessionTrackerSize=source.getInt();
    final Map<MEMBER,LocalSessionTracker> sessionTrackers=new HashMap<>();
    for (int i=0; i < sessionTrackerSize; i++) {
      final MEMBER unmarshal=memberMarshal.unmarshal(source);
      if (unmarshal == null) {
        return null;
      }
      long mostSigBits=source.getLong();
      long leastSigBits=source.getLong();
      UUID globalSessionId=new UUID(mostSigBits,leastSigBits);
      final int localSessionTrackerSize=source.getInt();
      final Map<Long,Long> lastSequenceNumberPerSession=new HashMap<>();
      for (int j=0; j < localSessionTrackerSize; j++) {
        long localSessionId=source.getLong();
        long sequenceNumber=source.getLong();
        lastSequenceNumberPerSession.put(localSessionId,sequenceNumber);
      }
      final LocalSessionTracker localSessionTracker=new LocalSessionTracker(globalSessionId,lastSequenceNumberPerSession);
      sessionTrackers.put(unmarshal,localSessionTracker);
    }
    GlobalSessionTrackerState<MEMBER> result=new GlobalSessionTrackerState<>();
    result.sessionTrackers=sessionTrackers;
    result.logIndex=logIndex;
    return result;
  }
 catch (  ReadPastEndException notEnoughBytes) {
    return null;
  }
}
