{
  Comparator comparator=new Comparator(){
    @Override public boolean lt(    long left,    long pivot){
      long leftEId=dataCache.get(left);
      long pivotEId=dataCache.get(pivot);
      if (DEFAULT.lt(leftEId,pivotEId)) {
        return true;
      }
      if (leftEId == pivotEId) {
        return left < pivot;
      }
      return false;
    }
    @Override public boolean ge(    long right,    long pivot){
      long rightEId=dataCache.get(right);
      long pivotEId=dataCache.get(pivot);
      if (DEFAULT.ge(rightEId,pivotEId)) {
        return rightEId == pivotEId ? right > pivot : true;
      }
      return false;
    }
  }
;
  new ParallelSort(radix,collisionNodeIdCache,numberOfCollisions - 1,collisionTrackerCache,processorsForSorting,ProgressListener.NONE,comparator).run();
  long previousEid=0;
  int previousGroupId=0;
  SourceInformation source=new SourceInformation();
  SameInputIdDetector detector=new SameInputIdDetector();
  for (int i=0; i < numberOfCollisions; i++) {
    int collisionIndex=collisionTrackerCache.get(i);
    long dataIndex=collisionNodeIdCache.get(collisionIndex);
    long eid=dataCache.get(dataIndex);
    long sourceInformation=collisionSourceDataCache.get(collisionIndex);
    source.decode(sourceInformation);
    IdGroup group=groupOf(dataIndex);
    int groupId=group.id();
    if (i == 0 || (eid == previousEid && previousGroupId == groupId)) {
      Object inputId=collisionValues.get(collisionIndex);
      int detectorIndex=detector.add(inputId,sourceInformation);
      if (detectorIndex != -1) {
        String firstDataPoint=detector.sourceInformation(detectorIndex).describe(sourceDescriptions);
        String otherDataPoint=source.describe(sourceDescriptions);
        collector.collectDuplicateNode(inputId,dataIndex,group.name(),firstDataPoint,otherDataPoint);
      }
    }
 else {
      detector.clear();
    }
    previousEid=eid;
    previousGroupId=groupId;
  }
}
