{
  for (long gapId=highestSetIndex + 1; gapId < id; gapId++) {
    radix.registerRadixOf(GAP_VALUE);
  }
  int groupId=group.id();
  boolean newGroup=false;
  if (currentIdGroup == null) {
    newGroup=true;
  }
 else {
    if (groupId < currentIdGroup.id()) {
      throw new IllegalStateException("Nodes for any specific group must be added in sequence " + "before adding nodes for any other group");
    }
    newGroup=groupId != currentIdGroup.id();
  }
  if (newGroup) {
    endPreviousGroup();
  }
  long eId=encode(inputId);
  dataCache.set(id,eId);
  highestSetIndex=id;
  radix.registerRadixOf(eId);
  if (newGroup) {
    if (groupId >= idGroups.length) {
      idGroups=Arrays.copyOf(idGroups,max(groupId + 1,idGroups.length * 2));
    }
    idGroups[groupId]=currentIdGroup=new IdGroup(group,id);
  }
}
