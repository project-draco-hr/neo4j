{
  MessageTimeoutStrategy timeoutStrategy=new MessageTimeoutStrategy(new FixedTimeoutStrategy(5000)).timeout(HeartbeatMessage.sendHeartbeat,10000).timeout(AtomicBroadcastMessage.broadcastTimeout,3000).timeout(ElectionMessage.demote,5000).relativeTimeout(HeartbeatMessage.timed_out,HeartbeatMessage.sendHeartbeat,10000);
  MultiPaxosServerFactory protocolServerFactory=new MultiPaxosServerFactory(new ClusterConfiguration(config.get(ClusterSettings.cluster_name)),logging);
  InMemoryAcceptorInstanceStore acceptorInstanceStore=new InMemoryAcceptorInstanceStore();
  DefaultElectionCredentialsProvider electionCredentialsProvider=new DefaultElectionCredentialsProvider(config.get(HaSettings.server_id),new OnDiskLastTxIdGetter(new File(getStoreDir())));
  networkNodeTCP=new NetworkInstance(new NetworkInstance.Configuration(){
    @Override public int[] getPorts(){
      int[] port=HaSettings.cluster_server.getPorts(config.getParams());
      if (port != null) {
        return port;
      }
      return HaSettings.cluster_server.getPorts(MapUtil.stringMap(HaSettings.cluster_server.name(),ConfigurationDefaults.getDefault(HaSettings.cluster_server,HaSettings.class)));
    }
    @Override public String getAddress(){
      return HaSettings.cluster_server.getAddress(config.getParams());
    }
  }
,logging.getLogger(Loggers.CLUSTER));
  server=protocolServerFactory.newProtocolServer(timeoutStrategy,networkNodeTCP,networkNodeTCP,acceptorInstanceStore,electionCredentialsProvider);
  networkNodeTCP.addNetworkChannelsListener(new NetworkInstance.NetworkChannelsListener(){
    @Override public void listeningAt(    URI me){
      server.listeningAt(me);
      server.addStateTransitionListener(new StateTransitionLogger(logging));
    }
    @Override public void channelOpened(    URI to){
    }
    @Override public void channelClosed(    URI to){
    }
  }
);
  life.add(new Lifecycle(){
    private ScheduledExecutorService scheduler;
    @Override public void init() throws Throwable {
      server.getTimeouts().tick(System.currentTimeMillis());
    }
    @Override public void start() throws Throwable {
      scheduler=Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory("timeout"));
      scheduler.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          long now=System.currentTimeMillis();
          server.getTimeouts().tick(now);
        }
      }
,0,10,TimeUnit.MILLISECONDS);
    }
    @Override public void stop() throws Throwable {
      scheduler.shutdownNow();
    }
    @Override public void shutdown() throws Throwable {
    }
  }
);
  server.addBindingListener(new BindingListener(){
    @Override public void listeningAt(    URI me){
      loggerContext.putProperty("host",me.getHost() + ":" + me.getPort());
    }
  }
);
  clusterEvents=life.add(new PaxosClusterEvents(config,server,logging.getLogger(Loggers.CLUSTER)));
  serverContext=new ClusterMemberContext(server);
  life.add(serverContext);
  memberStateMachine=new ClusterMemberStateMachine(serverContext,accessGuard,clusterEvents,logging.getLogger(Loggers.CLUSTER));
  life.add(new ClusterMemberModeSwitcher(delegateInvocationHandler,clusterEvents,memberStateMachine,this,config,logging.getLogger(Loggers.CLUSTER)));
  DelegateInvocationHandler<TxHook> txHookDelegate=new DelegateInvocationHandler<TxHook>();
  TxHook txHook=(TxHook)Proxy.newProxyInstance(TxHook.class.getClassLoader(),new Class[]{TxHook.class},txHookDelegate);
  new TxHookModeSwitcher(memberStateMachine,txHookDelegate,master,new TxHookModeSwitcher.RequestContextFactoryResolver(){
    @Override public RequestContextFactory get(){
      return requestContextFactory;
    }
  }
,dependencyResolver);
  return txHook;
}
