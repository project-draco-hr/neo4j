{
  DependencyResolver dependencyResolver=mock(DependencyResolver.class);
  TransactionIdStore txIdStore=mock(TransactionIdStore.class);
  when(dependencyResolver.resolveDependency(TransactionIdStore.class)).thenReturn(txIdStore);
  TransactionAppender appender=mock(TransactionAppender.class);
  when(appender.append(any(CommittedTransactionRepresentation.class))).thenReturn(true);
  LogicalTransactionStore logicalTransactionStore=mock(LogicalTransactionStore.class);
  when(logicalTransactionStore.getAppender()).thenReturn(appender);
  when(dependencyResolver.resolveDependency(LogicalTransactionStore.class)).thenReturn(logicalTransactionStore);
  when(dependencyResolver.resolveDependency(TransactionRepresentationStoreApplier.class)).thenReturn(mock(TransactionRepresentationStoreApplier.class));
  StoppingTxHandler stoppingTxHandler=new StoppingTxHandler();
  TransactionCommittingResponseUnpacker unpacker=new TransactionCommittingResponseUnpacker(dependencyResolver,stoppingTxHandler);
  stoppingTxHandler.setUnpacker(unpacker);
  unpacker.start();
  int committingTransactionId=2;
  DummyResponse response=new DummyResponse(committingTransactionId);
  unpacker.unpackResponse(response);
  verify(txIdStore,times(1)).transactionCommitted(committingTransactionId);
  verify(txIdStore,times(1)).transactionClosed(committingTransactionId);
  verify(appender,times(1)).append(response.getTheTx());
  try {
    unpacker.unpackResponse(mock(Response.class));
    fail("A stopped transaction unpacker should not allow transactions to be applied");
  }
 catch (  IllegalStateException e) {
  }
  verifyNoMoreInteractions(txIdStore);
  verifyNoMoreInteractions(appender);
}
