{
  long committingTransactionId=BASE_TX_ID + 1;
  final TransactionIdStore txIdStore=mock(TransactionIdStore.class);
  final TransactionAppender appender=mockedTransactionAppender();
  final LogFile logFile=mock(LogFile.class);
  final LogRotation logRotation=mock(LogRotation.class);
  final BatchingTransactionRepresentationStoreApplier applier=mock(BatchingTransactionRepresentationStoreApplier.class);
  final IndexUpdatesValidator indexUpdatesValidator=setUpIndexUpdatesValidatorMocking();
  final KernelHealth kernelHealth=mock(KernelHealth.class);
  StoppingTxHandler stoppingTxHandler=new StoppingTxHandler();
  TransactionCommittingResponseUnpacker.Dependencies deps=buildDependencies(logFile,logRotation,indexUpdatesValidator,applier,appender,mock(TransactionObligationFulfiller.class),kernelHealth);
  when(appender.append(any(TransactionRepresentation.class),eq(committingTransactionId))).thenReturn(new FakeCommitment(committingTransactionId,txIdStore));
  int maxBatchSize=10;
  TransactionCommittingResponseUnpacker unpacker=new TransactionCommittingResponseUnpacker(deps,maxBatchSize);
  stoppingTxHandler.setUnpacker(unpacker);
  unpacker.start();
  DummyTransactionResponse response=new DummyTransactionResponse(committingTransactionId,1,appender,maxBatchSize);
  unpacker.unpackResponse(response,stoppingTxHandler);
  verify(txIdStore,times(1)).transactionCommitted(eq(committingTransactionId),anyLong());
  verify(txIdStore,times(1)).transactionClosed(eq(committingTransactionId),anyLong(),anyLong());
  verify(appender,times(1)).append(any(TransactionRepresentation.class),anyLong());
  verify(appender,times(1)).force();
  verify(logRotation,times(1)).rotateLogIfNeeded(logAppendEvent);
  try {
    unpacker.unpackResponse(mock(Response.class),stoppingTxHandler);
    fail("A stopped transaction unpacker should not allow transactions to be applied");
  }
 catch (  IllegalStateException e) {
  }
  verifyNoMoreInteractions(txIdStore);
  verifyNoMoreInteractions(appender);
}
