{
  TransactionIdStore txIdStore=mock(TransactionIdStore.class);
  TransactionAppender appender=mock(TransactionAppender.class);
  when(appender.append(any(TransactionRepresentation.class),anyLong())).thenReturn(new FakeCommitment(BASE_TX_ID + 1,txIdStore));
  TransactionObligationFulfiller obligationFulfiller=mock(TransactionObligationFulfiller.class);
  LogFile logFile=mock(LogFile.class);
  KernelHealth kernelHealth=mock(KernelHealth.class);
  when(kernelHealth.isHealthy()).thenReturn(true);
  LogRotation logRotation=mock(LogRotation.class);
  BatchingTransactionRepresentationStoreApplier applier=mock(BatchingTransactionRepresentationStoreApplier.class);
  final TransactionCommittingResponseUnpacker unpacker=new TransactionCommittingResponseUnpacker(buildDependencies(logFile,logRotation,mock(IndexUpdatesValidator.class),applier,appender,obligationFulfiller,kernelHealth));
  unpacker.start();
  UnderlyingStorageException failure=new UnderlyingStorageException("Expected failure");
  doThrow(failure).when(applier).apply(any(TransactionRepresentation.class),any(ValidatedIndexUpdates.class),any(LockGroup.class),anyLong(),any(TransactionApplicationMode.class));
  try {
    unpacker.unpackResponse(new DummyTransactionResponse(BASE_TX_ID + 1,1,appender,10),NO_OP_TX_HANDLER);
    fail("Should have failed");
  }
 catch (  UnderlyingStorageException e) {
    assertThat(e.getMessage(),containsString(failure.getMessage()));
  }
}
