{
  DependencyResolver resolver=mock(DependencyResolver.class);
  when(resolver.resolveDependency(LogFile.class)).thenReturn(mock(LogFile.class));
  when(resolver.resolveDependency(LogRotation.class)).thenReturn(mock(LogRotation.class));
  when(resolver.resolveDependency(TransactionIdStore.class)).thenReturn(mock(TransactionIdStore.class));
  KernelHealth kernelHealth=mock(KernelHealth.class);
  when(kernelHealth.isHealthy()).thenReturn(true);
  when(resolver.resolveDependency(KernelHealth.class)).thenReturn(kernelHealth);
  LogicalTransactionStore txStore=mock(LogicalTransactionStore.class);
  TransactionAppender appender=mockedTransactionAppender();
  when(txStore.getAppender()).thenReturn(appender);
  when(resolver.resolveDependency(LogicalTransactionStore.class)).thenReturn(txStore);
  BatchingTransactionRepresentationStoreApplier storeApplier=mock(BatchingTransactionRepresentationStoreApplier.class);
  when(resolver.resolveDependency(TransactionRepresentationStoreApplier.class)).thenReturn(storeApplier);
  when(resolver.resolveDependency(Logging.class)).thenReturn(logging);
  final IndexUpdatesValidator validator=mock(IndexUpdatesValidator.class);
  IOException error=new IOException("error");
  when(validator.validate(any(TransactionRepresentation.class))).thenThrow(error);
  addMockedNeoStore(resolver);
  TransactionCommittingResponseUnpacker unpacker=new TransactionCommittingResponseUnpacker(resolver,100,customValidator(validator),customApplier(storeApplier));
  unpacker.start();
  Response<?> response=new DummyTransactionResponse(BASE_TX_ID + 1,1,appender,10);
  try {
    unpacker.unpackResponse(response,NO_OP_TX_HANDLER);
    fail("Should have thrown " + IOException.class.getSimpleName());
  }
 catch (  IOException e) {
    assertSame(error,e);
  }
  verifyZeroInteractions(appender,storeApplier);
}
