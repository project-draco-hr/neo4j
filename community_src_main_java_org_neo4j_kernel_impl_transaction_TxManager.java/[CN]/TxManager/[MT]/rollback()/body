{
  if (!tmOk) {
    throw new SystemException("TM has encountered some problem, " + "please perform neccesary action (tx recovery/restart)");
  }
  Thread thread=Thread.currentThread();
  TransactionImpl tx=txThreadMap.get(thread);
  if (tx == null) {
    throw new IllegalStateException("Not in transaction");
  }
  try {
    if (tx.getStatus() == Status.STATUS_ACTIVE || tx.getStatus() == Status.STATUS_MARKED_ROLLBACK || tx.getStatus() == Status.STATUS_PREPARING) {
      tx.setStatus(Status.STATUS_MARKED_ROLLBACK);
      tx.doBeforeCompletion();
      try {
        rolledBackTxCount.incrementAndGet();
        rollbackHook.rollbackTransaction(getEventIdentifier());
        tx.doRollback();
      }
 catch (      XAException e) {
        e.printStackTrace();
        log.severe("Unable to rollback marked or active transaction. " + "Some resources may be commited others not. " + "Neo4j kernel should be SHUTDOWN for "+ "resource maintance and transaction recovery ---->");
        setTmNotOk();
        throw new SystemException("Unable to rollback " + " ---> error code for rollback: " + e.errorCode);
      }
      tx.doAfterCompletion();
      txThreadMap.remove(thread);
      try {
        if (tx.isGlobalStartRecordWritten()) {
          getTxLog().txDone(tx.getGlobalId());
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        log.severe("Error writing transaction log");
        setTmNotOk();
        throw new SystemException("TM encountered a problem, " + " error writing transaction log," + e);
      }
      tx.setStatus(Status.STATUS_NO_TRANSACTION);
    }
 else {
      throw new IllegalStateException("Tx status is: " + getTxStatusAsString(tx.getStatus()));
    }
  }
  finally {
    rollbackHook.doneCommitting(tx.getEventIdentifier());
  }
}
