{
  int logsFound=0;
  for (  String fileName : filenamesOf(filenameOrDirectory,logPrefix)) {
    logsFound++;
    out.println("=== " + fileName + " ===");
    StoreChannel fileChannel=fileSystem.open(new File(fileName),"r");
    ByteBuffer buffer=ByteBuffer.allocateDirect(LOG_HEADER_SIZE);
    LogHeader logHeader;
    try {
      logHeader=readLogHeader(buffer,fileChannel,false);
    }
 catch (    IOException ex) {
      out.println("Unable to read timestamp information, no records in logical log.");
      out.println(ex.getMessage());
      fileChannel.close();
      throw ex;
    }
    out.println("Logical log format: " + logHeader.logFormatVersion + " version: "+ logHeader.logVersion+ " with prev committed tx["+ logHeader.lastCommittedTxId+ "]");
    PhysicalLogVersionedStoreChannel channel=new PhysicalLogVersionedStoreChannel(fileChannel,logHeader.logVersion,logHeader.logFormatVersion);
    ReadableLogChannel logChannel=new ReadAheadLogChannel(channel,NO_MORE_CHANNELS);
    LogEntryReader<ReadableClosablePositionAwareChannel> entryReader=new VersionAwareLogEntryReader<>();
    IOCursor<LogEntry> entryCursor=new LogEntryCursor(entryReader,logChannel);
    TransactionLogEntryCursor transactionCursor=new TransactionLogEntryCursor(entryCursor);
    try (IOCursor<LogEntry[]> cursor=regex == null ? transactionCursor : new FilteringIOCursor<>(transactionCursor,new TransactionRegexCriteria(regex,timeZone))){
      while (cursor.next()) {
        for (        LogEntry entry : cursor.get()) {
          out.println(entry.toString(timeZone));
        }
      }
    }
   }
  return logsFound;
}
