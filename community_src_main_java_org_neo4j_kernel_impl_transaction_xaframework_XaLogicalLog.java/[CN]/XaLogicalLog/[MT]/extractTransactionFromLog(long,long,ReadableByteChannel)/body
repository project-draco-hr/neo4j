{
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  buffer.flip();
  long versionInLog=buffer.getLong();
  assertExpectedVersion(expectedVersion,versionInLog);
  long prevTxId=buffer.getLong();
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  buffer.limit(1);
  while (logEntryList == null && log.read(buffer) == buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    List<LogEntry> list=new LinkedList<LogEntry>();
  list.add(logEntry);
transactions.put(logEntry.getIdentifier(),list);
break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
if (((LogEntry.OnePhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
if (((LogEntry.TwoPhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
transactions.remove(logEntry.getIdentifier());
break;
default :
throw new IOException("Unable to locate transaction[" + txId + "]");
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException("Transaction[" + txId + "] not found in log ("+ expectedVersion+ ", "+ prevTxId+ ")");
}
return logEntryList;
}
