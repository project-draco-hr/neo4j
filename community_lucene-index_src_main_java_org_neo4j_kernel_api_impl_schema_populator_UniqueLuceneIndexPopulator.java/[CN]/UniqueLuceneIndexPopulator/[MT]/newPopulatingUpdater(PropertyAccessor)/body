{
  return new IndexUpdater(){
    List<Object> updatedPropertyValues=new ArrayList<>();
    @Override public void process(    NodePropertyUpdate update) throws IOException, IndexEntryConflictException {
      long nodeId=update.getNodeId();
switch (update.getUpdateMode()) {
case ADDED:
        sampler.increment(1);
      writer.updateDocument(LuceneDocumentStructure.newTermForChangeOrRemove(nodeId),LuceneDocumentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
    updatedPropertyValues.add(update.getValueAfter());
  break;
case CHANGED:
writer.updateDocument(LuceneDocumentStructure.newTermForChangeOrRemove(nodeId),LuceneDocumentStructure.documentRepresentingProperty(nodeId,update.getValueAfter()));
updatedPropertyValues.add(update.getValueAfter());
break;
case REMOVED:
sampler.increment(-1);
writer.deleteDocuments(LuceneDocumentStructure.newTermForChangeOrRemove(nodeId));
break;
default :
throw new IllegalStateException("Unknown update mode " + update.getUpdateMode());
}
}
@Override public void close() throws IOException, IndexEntryConflictException {
luceneIndex.verifyUniqueness(accessor,descriptor.getPropertyKeyId(),updatedPropertyValues);
}
@Override public void remove(PrimitiveLongSet nodeIds){
throw new UnsupportedOperationException("should not remove() from populating index");
}
}
;
}
