{
  this.graphDb=db;
  this.msgLog=((AbstractGraphDatabase)db).getMessageLog();
  this.unfinishedTransactionThreshold=HaConfig.getClientLockReadTimeoutFromConfig(config);
  this.unfinishedTransactionsExecutor=Executors.newSingleThreadScheduledExecutor();
  this.unfinishedTransactionsExecutor.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      try {
        Map<SlaveContext,Pair<Transaction,AtomicLong>> safeTransactions=null;
synchronized (transactions) {
          safeTransactions=new HashMap<SlaveContext,Pair<Transaction,AtomicLong>>(transactions);
        }
        for (        Map.Entry<SlaveContext,Pair<Transaction,AtomicLong>> entry : safeTransactions.entrySet()) {
          long time=entry.getValue().other().get();
          if (time != 0 && System.currentTimeMillis() - time >= unfinishedTransactionThreshold * 1000) {
            long displayableTime=(time == 0 ? 0 : (System.currentTimeMillis() - time));
            msgLog.logMessage("Found old tx " + entry.getKey() + ", "+ entry.getValue().first()+ ", "+ displayableTime);
            try {
              Transaction otherTx=suspendOtherAndResumeThis(entry.getKey(),false);
              finishThisAndResumeOther(otherTx,entry.getKey(),false);
              msgLog.logMessage("Rolled back old tx " + entry.getKey() + ", "+ entry.getValue().first()+ ", "+ displayableTime);
            }
 catch (            IllegalStateException e) {
            }
catch (            Throwable t) {
              msgLog.logMessage("Unable to roll back old tx " + entry.getKey() + ", "+ entry.getValue().first()+ ", "+ displayableTime);
            }
          }
        }
      }
 catch (      Throwable t) {
      }
    }
  }
,UNFINISHED_TRANSACTION_CLEANUP_DELAY,UNFINISHED_TRANSACTION_CLEANUP_DELAY,TimeUnit.SECONDS);
}
