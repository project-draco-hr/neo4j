{
  InstanceId me=new InstanceId(1);
  StoreId storeId=new StoreId();
  HighAvailabilityMemberContext context=mock(HighAvailabilityMemberContext.class);
  when(context.getMyId()).thenReturn(me);
  AvailabilityGuard guard=mock(AvailabilityGuard.class);
  ClusterMembers members=mock(ClusterMembers.class);
  ClusterMember masterMember=mock(ClusterMember.class);
  when(masterMember.getHARole()).thenReturn("master");
  when(masterMember.hasRole("master")).thenReturn(true);
  when(masterMember.getInstanceId()).thenReturn(new InstanceId(2));
  when(masterMember.getStoreId()).thenReturn(storeId);
  when(members.getMembers()).thenReturn(Arrays.asList(new ClusterMember(me),masterMember));
  DependencyResolver dependencyResolver=mock(DependencyResolver.class);
  FileSystemAbstraction fs=mock(FileSystemAbstraction.class);
  when(fs.fileExists(any(File.class))).thenReturn(true);
  when(dependencyResolver.resolveDependency(FileSystemAbstraction.class)).thenReturn(fs);
  when(dependencyResolver.resolveDependency(Monitors.class)).thenReturn(new Monitors());
  NeoStoreDataSource dataSource=mock(NeoStoreDataSource.class);
  when(dataSource.getDependencyResolver()).thenReturn(dependencyResolver);
  when(dataSource.getStoreId()).thenReturn(storeId);
  when(dependencyResolver.resolveDependency(NeoStoreDataSource.class)).thenReturn(dataSource);
  when(dependencyResolver.resolveDependency(TransactionIdStore.class)).thenReturn(new DeadSimpleTransactionIdStore());
  when(dependencyResolver.resolveDependency(ClusterMembers.class)).thenReturn(members);
  UpdatePuller updatePuller=mock(UpdatePuller.class);
  when(updatePuller.await(any(UpdatePuller.Condition.class),anyBoolean())).thenReturn(true);
  when(dependencyResolver.resolveDependency(UpdatePuller.class)).thenReturn(updatePuller);
  Logging logging=mock(Logging.class,RETURNS_MOCKS);
  ClusterMemberAvailability clusterMemberAvailability=mock(ClusterMemberAvailability.class);
  final TriggerableClusterMemberEvents events=new TriggerableClusterMemberEvents();
  Election election=mock(Election.class);
  StringLogger logger=mock(StringLogger.class);
  HighAvailabilityMemberStateMachine toTest=new HighAvailabilityMemberStateMachine(context,guard,members,events,election,logger);
  toTest.init();
  toTest.start();
  final DelegateInvocationHandler<Master> handler=new DelegateInvocationHandler<>(Master.class);
  MasterClientResolver masterClientResolver=mock(MasterClientResolver.class);
  MasterClient masterClient=mock(MasterClient.class);
  when(masterClient.getProtocolVersion()).thenReturn(MasterClient214.PROTOCOL_VERSION);
  when(masterClient.handshake(anyLong(),any(StoreId.class))).thenReturn(new Response<HandshakeResult>(new HandshakeResult(0,42),storeId,mock(ResourceReleaser.class)){
    @Override public void accept(    Handler handler) throws IOException {
    }
    @Override public boolean hasTransactionsToBeApplied(){
      return false;
    }
  }
);
  when(masterClient.toString()).thenReturn("TheExpectedMasterClient!");
  when(masterClientResolver.instantiate(anyString(),anyInt(),any(Monitors.class),any(StoreId.class),any(LifeSupport.class))).thenReturn(masterClient);
  final CountDownLatch latch=new CountDownLatch(2);
  final AtomicBoolean switchedSuccessfully=new AtomicBoolean();
  SwitchToSlave.Monitor monitor=new SwitchToSlave.Monitor(){
    @Override public void switchToSlaveStarted(){
    }
    @Override public void switchToSlaveCompleted(    boolean wasSuccessful){
      switchedSuccessfully.set(wasSuccessful);
      latch.countDown();
    }
    @Override public void storeCopyStarted(){
    }
    @Override public void storeCopyCompleted(    boolean wasSuccessful){
    }
    @Override public void catchupStarted(){
    }
    @Override public void catchupCompleted(){
    }
  }
;
  Config config=new Config(Collections.singletonMap(ClusterSettings.server_id.name(),me.toString()));
  SwitchToSlave switchToSlave=new SwitchToSlave(mock(ConsoleLogger.class),config,dependencyResolver,mock(HaIdGeneratorFactory.class),logging,handler,clusterMemberAvailability,mock(RequestContextFactory.class),Iterables.<KernelExtensionFactory<?>>empty(),masterClientResolver,mock(ByteCounterMonitor.class),mock(RequestMonitor.class),monitor,mock(StoreCopyClient.Monitor.class));
  HighAvailabilityModeSwitcher haModeSwitcher=new HighAvailabilityModeSwitcher(switchToSlave,mock(SwitchToMaster.class),election,clusterMemberAvailability,dependencyResolver,me,logging);
  haModeSwitcher.init();
  haModeSwitcher.start();
  haModeSwitcher.listeningAt(URI.create("http://localhost:12345"));
  toTest.addHighAvailabilityMemberListener(haModeSwitcher);
  final AtomicReference<Master> ref=new AtomicReference<>(null);
  AbstractModeSwitcher<Object> otherModeSwitcher=new AbstractModeSwitcher<Object>(haModeSwitcher,mock(DelegateInvocationHandler.class)){
    @Override protected Object getSlaveImpl(){
      Master master=handler.cement();
      ref.set(master);
      latch.countDown();
      return null;
    }
    @Override protected Object getMasterImpl(){
      return null;
    }
  }
;
  otherModeSwitcher.init();
  otherModeSwitcher.start();
  events.switchToSlave(me);
  latch.await();
  assertTrue("mode switch failed",switchedSuccessfully.get());
  Master expected=masterClient;
  Master actual=ref.get();
  assertEquals(expected.toString(),actual.toString());
  toTest.stop();
  toTest.shutdown();
  haModeSwitcher.stop();
  haModeSwitcher.shutdown();
  otherModeSwitcher.stop();
  otherModeSwitcher.shutdown();
}
