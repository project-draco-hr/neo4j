{
  InstanceId me=new InstanceId(1);
  StoreId storeId=new StoreId();
  HighAvailabilityMemberContext context=mock(HighAvailabilityMemberContext.class);
  when(context.getMyId()).thenReturn(me);
  AvailabilityGuard guard=mock(AvailabilityGuard.class);
  ObservedClusterMembers members=mock(ObservedClusterMembers.class);
  ClusterMember masterMember=mock(ClusterMember.class);
  when(masterMember.getHARole()).thenReturn("master");
  when(masterMember.hasRole("master")).thenReturn(true);
  when(masterMember.getInstanceId()).thenReturn(new InstanceId(2));
  when(masterMember.getStoreId()).thenReturn(storeId);
  ClusterMember self=new ClusterMember(me);
  when(members.getMembers()).thenReturn(Arrays.asList(self,masterMember));
  when(members.getCurrentMember()).thenReturn(self);
  DependencyResolver dependencyResolver=mock(DependencyResolver.class);
  FileSystemAbstraction fs=mock(FileSystemAbstraction.class);
  when(fs.fileExists(any(File.class))).thenReturn(true);
  when(dependencyResolver.resolveDependency(FileSystemAbstraction.class)).thenReturn(fs);
  when(dependencyResolver.resolveDependency(Monitors.class)).thenReturn(new Monitors());
  NeoStoreDataSource dataSource=mock(NeoStoreDataSource.class);
  when(dataSource.getDependencyResolver()).thenReturn(dependencyResolver);
  when(dataSource.getStoreId()).thenReturn(storeId);
  when(dependencyResolver.resolveDependency(NeoStoreDataSource.class)).thenReturn(dataSource);
  when(dependencyResolver.resolveDependency(TransactionIdStore.class)).thenReturn(new DeadSimpleTransactionIdStore());
  when(dependencyResolver.resolveDependency(ObservedClusterMembers.class)).thenReturn(members);
  UpdatePuller updatePuller=mock(UpdatePuller.class);
  when(updatePuller.tryPullUpdates()).thenReturn(true);
  when(dependencyResolver.resolveDependency(UpdatePuller.class)).thenReturn(updatePuller);
  ClusterMemberAvailability clusterMemberAvailability=mock(ClusterMemberAvailability.class);
  final TriggerableClusterMemberEvents events=new TriggerableClusterMemberEvents();
  Election election=mock(Election.class);
  HighAvailabilityMemberStateMachine stateMachine=new HighAvailabilityMemberStateMachine(context,guard,members,events,election,NullLogProvider.getInstance());
  ClusterMembers clusterMembers=new ClusterMembers(members,stateMachine);
  when(dependencyResolver.resolveDependency(ClusterMembers.class)).thenReturn(clusterMembers);
  stateMachine.init();
  stateMachine.start();
  final DelegateInvocationHandler<Master> handler=new DelegateInvocationHandler<>(Master.class);
  MasterClientResolver masterClientResolver=mock(MasterClientResolver.class);
  MasterClient masterClient=mock(MasterClient.class);
  when(masterClient.getProtocolVersion()).thenReturn(MasterClient214.PROTOCOL_VERSION);
  when(masterClient.handshake(anyLong(),any(StoreId.class))).thenReturn(new Response<HandshakeResult>(new HandshakeResult(0,42),storeId,mock(ResourceReleaser.class)){
    @Override public void accept(    Handler handler) throws IOException {
    }
    @Override public boolean hasTransactionsToBeApplied(){
      return false;
    }
  }
);
  when(masterClient.toString()).thenReturn("TheExpectedMasterClient!");
  when(masterClientResolver.instantiate(anyString(),anyInt(),any(Monitors.class),any(StoreId.class),any(LifeSupport.class))).thenReturn(masterClient);
  final CountDownLatch latch=new CountDownLatch(2);
  final AtomicBoolean switchedSuccessfully=new AtomicBoolean();
  SwitchToSlave.Monitor monitor=new SwitchToSlave.Monitor(){
    @Override public void switchToSlaveStarted(){
    }
    @Override public void switchToSlaveCompleted(    boolean wasSuccessful){
      switchedSuccessfully.set(wasSuccessful);
      latch.countDown();
    }
    @Override public void storeCopyStarted(){
    }
    @Override public void storeCopyCompleted(    boolean wasSuccessful){
    }
    @Override public void catchupStarted(){
    }
    @Override public void catchupCompleted(){
    }
  }
;
  Config config=new Config(Collections.singletonMap(ClusterSettings.server_id.name(),me.toString()));
  TransactionCounters transactionCounters=mock(TransactionCounters.class);
  when(transactionCounters.getNumberOfActiveTransactions()).thenReturn(0l);
  PageCache pageCacheMock=mock(PageCache.class);
  PagedFile pagedFileMock=mock(PagedFile.class);
  when(pagedFileMock.getLastPageId()).thenReturn(1l);
  when(pageCacheMock.map(any(File.class),anyInt())).thenReturn(pagedFileMock);
  TransactionIdStore transactionIdStoreMock=mock(TransactionIdStore.class);
  when(transactionIdStoreMock.getLastCommittedTransaction()).thenReturn(new TransactionId(0,0));
  SwitchToSlave switchToSlave=new SwitchToSlave(new File(""),NullLogService.getInstance(),mock(FileSystemAbstraction.class),config,dependencyResolver,mock(HaIdGeneratorFactory.class),handler,mock(ClusterMemberAvailability.class),mock(RequestContextFactory.class),mock(PullerFactory.class,RETURNS_MOCKS),Iterables.<KernelExtensionFactory<?>>empty(),masterClientResolver,monitor,new StoreCopyClient.Monitor.Adapter(),Suppliers.singleton(dataSource),Suppliers.singleton(transactionIdStoreMock),new Function<Slave,SlaveServer>(){
    @Override public SlaveServer apply(    Slave slave) throws RuntimeException {
      SlaveServer mock=mock(SlaveServer.class);
      when(mock.getSocketAddress()).thenReturn(new InetSocketAddress("localhost",123));
      return mock;
    }
  }
,updatePuller,pageCacheMock,mock(Monitors.class),transactionCounters);
  ComponentSwitcherContainer switcherContainer=new ComponentSwitcherContainer();
  HighAvailabilityModeSwitcher haModeSwitcher=new HighAvailabilityModeSwitcher(switchToSlave,mock(SwitchToMaster.class),election,clusterMemberAvailability,mock(ClusterClient.class),storeSupplierMock(),me,switcherContainer,NullLogService.getInstance());
  haModeSwitcher.init();
  haModeSwitcher.start();
  haModeSwitcher.listeningAt(URI.create("http://localhost:12345"));
  stateMachine.addHighAvailabilityMemberListener(haModeSwitcher);
  final AtomicReference<Master> ref=new AtomicReference<>(null);
  AbstractComponentSwitcher<Object> otherModeSwitcher=new AbstractComponentSwitcher<Object>(mock(DelegateInvocationHandler.class)){
    @Override protected Object getSlaveImpl(){
      Master master=handler.cement();
      ref.set(master);
      latch.countDown();
      return null;
    }
    @Override protected Object getMasterImpl(){
      return null;
    }
  }
;
  switcherContainer.add(otherModeSwitcher);
  events.switchToSlave(me);
  latch.await();
  assertTrue("mode switch failed",switchedSuccessfully.get());
  Master actual=ref.get();
  assertEquals(masterClient.toString(),actual.toString());
  stateMachine.stop();
  stateMachine.shutdown();
  haModeSwitcher.stop();
  haModeSwitcher.shutdown();
}
