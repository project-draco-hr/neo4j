{
  this.monitors=monitors;
  MessageTimeoutStrategy timeoutStrategy=new MessageTimeoutStrategy(new FixedTimeoutStrategy(config.defaultTimeout())).timeout(HeartbeatMessage.sendHeartbeat,config.heartbeatInterval()).timeout(HeartbeatMessage.timed_out,config.heartbeatTimeout()).timeout(AtomicBroadcastMessage.broadcastTimeout,config.broadcastTimeout()).timeout(LearnerMessage.learnTimedout,config.learnTimeout()).timeout(ProposerMessage.phase1Timeout,config.phase1Timeout()).timeout(ProposerMessage.phase2Timeout,config.phase2Timeout()).timeout(ClusterMessage.joiningTimeout,config.joinTimeout()).timeout(ClusterMessage.configurationTimeout,config.configurationTimeout()).timeout(ClusterMessage.leaveTimedout,config.leaveTimeout()).timeout(ElectionMessage.electionTimeout,config.electionTimeout());
  MultiPaxosServerFactory protocolServerFactory=new MultiPaxosServerFactory(monitors,new ClusterConfiguration(config.getClusterName(),logging.getMessagesLog(ClusterConfiguration.class)),logging);
  InMemoryAcceptorInstanceStore acceptorInstanceStore=new InMemoryAcceptorInstanceStore();
  InternalLoggerFactory.setDefaultFactory(new NettyLoggerFactory(logging));
  NetworkReceiver receiver=new NetworkReceiver(monitors.newMonitor(NetworkReceiver.Monitor.class),new NetworkReceiver.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.getAddress();
    }
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public String name(){
      return config.name();
    }
  }
,logging);
  NetworkSender sender=new NetworkSender(monitors.newMonitor(NetworkSender.Monitor.class),new NetworkSender.Configuration(){
    @Override public int defaultPort(){
      return 5001;
    }
    @Override public int port(){
      return config.getAddress().getPort();
    }
  }
,receiver,logging);
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine",monitors.newMonitor(NamedThreadFactory.Monitor.class)));
    }
  }
);
  server=protocolServerFactory.newProtocolServer(config.getServerId(),timeoutStrategy,receiver,sender,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor,objectInputStreamFactory,objectOutputStreamFactory);
  receiver.addNetworkChannelsListener(new NetworkReceiver.NetworkChannelsListener(){
    volatile private StateTransitionLogger logger=null;
    @Override public void listeningAt(    URI me){
      server.listeningAt(me);
      if (logger == null) {
        logger=new StateTransitionLogger(logging);
        server.addStateTransitionListener(logger);
      }
    }
    @Override public void channelOpened(    URI to){
      logging.getMessagesLog(NetworkReceiver.class).info(to + " connected to me at " + server.boundAt());
    }
    @Override public void channelClosed(    URI to){
      logging.getMessagesLog(NetworkReceiver.class).info(to + " disconnected from me at " + server.boundAt());
    }
  }
);
  life.add(sender);
  life.add(stateMachineExecutor);
  life.add(receiver);
  life.add(new TimeoutTrigger());
  life.add(new ClusterJoin(new ClusterJoin.Configuration(){
    @Override public List<HostnamePort> getInitialHosts(){
      return config.getInitialHosts();
    }
    @Override public String getClusterName(){
      return config.getClusterName();
    }
    @Override public boolean isAllowedToCreateCluster(){
      return config.isAllowedToCreateCluster();
    }
    @Override public long getClusterJoinTimeout(){
      return config.clusterJoinTimeout();
    }
  }
,server,logging));
  cluster=server.newClient(Cluster.class);
  broadcast=server.newClient(AtomicBroadcast.class);
  heartbeat=server.newClient(Heartbeat.class);
  snapshot=server.newClient(Snapshot.class);
  election=server.newClient(Election.class);
}
