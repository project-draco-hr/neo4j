{
  MessageTimeoutStrategy timeoutStrategy=new MessageTimeoutStrategy(new FixedTimeoutStrategy(config.defaultTimeout())).timeout(HeartbeatMessage.sendHeartbeat,config.heartbeatInterval()).timeout(HeartbeatMessage.timed_out,config.heartbeatTimeout()).timeout(AtomicBroadcastMessage.broadcastTimeout,config.broadcastTimeout()).timeout(LearnerMessage.learnTimedout,config.learnTimeout()).timeout(ProposerMessage.phase1Timeout,config.phase1Timeout()).timeout(ProposerMessage.phase2Timeout,config.phase2Timeout()).timeout(ClusterMessage.joiningTimeout,config.joinTimeout()).timeout(ClusterMessage.configurationTimeout,config.configurationTimeout()).timeout(ClusterMessage.leaveTimedout,config.leaveTimeout()).timeout(ElectionMessage.electionTimeout,config.electionTimeout());
  MultiPaxosServerFactory protocolServerFactory=new MultiPaxosServerFactory(new ClusterConfiguration(config.getClusterName()),logging);
  InMemoryAcceptorInstanceStore acceptorInstanceStore=new InMemoryAcceptorInstanceStore();
  NetworkInstance networkNodeTCP=new NetworkInstance(new NetworkInstance.Configuration(){
    @Override public HostnamePort clusterServer(){
      return config.getAddress();
    }
    @Override public int defaultPort(){
      return 5001;
    }
  }
,logging);
  ExecutorLifecycleAdapter stateMachineExecutor=new ExecutorLifecycleAdapter(new Factory<ExecutorService>(){
    @Override public ExecutorService newInstance(){
      return Executors.newSingleThreadExecutor(new NamedThreadFactory("State machine"));
    }
  }
);
  server=protocolServerFactory.newProtocolServer(new InstanceId(config.getServerId()),timeoutStrategy,networkNodeTCP,networkNodeTCP,acceptorInstanceStore,electionCredentialsProvider,stateMachineExecutor);
  networkNodeTCP.addNetworkChannelsListener(new NetworkInstance.NetworkChannelsListener(){
    @Override public void listeningAt(    URI me){
      server.listeningAt(me);
      server.addStateTransitionListener(new StateTransitionLogger(logging));
    }
    @Override public void channelOpened(    URI to){
    }
    @Override public void channelClosed(    URI to){
    }
  }
);
  life.add(stateMachineExecutor);
  life.add(networkNodeTCP);
  life.add(new Lifecycle(){
    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> tickFuture;
    @Override public void init() throws Throwable {
      server.getTimeouts().tick(System.currentTimeMillis());
    }
    @Override public void start() throws Throwable {
      scheduler=Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory("timeout-clusterClient"));
      tickFuture=scheduler.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          long now=System.currentTimeMillis();
          server.getTimeouts().tick(now);
        }
      }
,0,10,TimeUnit.MILLISECONDS);
    }
    @Override public void stop() throws Throwable {
      tickFuture.cancel(true);
      scheduler.shutdownNow();
    }
    @Override public void shutdown() throws Throwable {
    }
  }
);
  life.add(new ClusterJoin(new ClusterJoin.Configuration(){
    @Override public List<HostnamePort> getInitialHosts(){
      return config.getInitialHosts();
    }
    @Override public String getClusterName(){
      return config.getClusterName();
    }
    @Override public boolean isAllowedToCreateCluster(){
      return config.isAllowedToCreateCluster();
    }
  }
,server,logging));
  cluster=server.newClient(Cluster.class);
  broadcast=server.newClient(AtomicBroadcast.class);
  heartbeat=server.newClient(Heartbeat.class);
  snapshot=server.newClient(Snapshot.class);
  election=server.newClient(Election.class);
}
