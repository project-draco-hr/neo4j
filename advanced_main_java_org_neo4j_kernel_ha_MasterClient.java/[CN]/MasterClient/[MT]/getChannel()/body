{
  Thread thread=Thread.currentThread();
synchronized (channels) {
    Triplet<Channel,ChannelBuffer,ByteBuffer> channel=channels.get(thread);
    while (channel == null) {
      while (channel == null) {
        Triplet<Channel,ChannelBuffer,ByteBuffer> unusedChannel=unusedChannels.poll();
        if (unusedChannel == null) {
          break;
        }
 else         if (unusedChannel.first().isConnected()) {
          msgLog.logMessage("Found unused (and still connected) channel");
          channel=unusedChannel;
        }
 else {
          msgLog.logMessage("Found unused stale channel, discarding it");
          activeChannels--;
          channels.notify();
        }
      }
      if (channel == null) {
        if (activeChannels >= MAX_NUMBER_OF_CONCURRENT_REQUESTS_PER_CLIENT) {
          channels.wait();
          continue;
        }
        ChannelFuture channelFuture=bootstrap.connect(new InetSocketAddress(hostNameOrIp,port));
        channelFuture.awaitUninterruptibly(5,TimeUnit.SECONDS);
        if (channelFuture.isSuccess()) {
          channel=Triplet.of(channelFuture.getChannel(),ChannelBuffers.dynamicBuffer(),ByteBuffer.allocateDirect(1024 * 1024));
          msgLog.logMessage("Opened a new channel to " + hostNameOrIp + ":"+ port);
          activeChannels++;
        }
      }
      if (channel == null) {
        throw new IOException("Not able to connect to master");
      }
      channels.put(thread,channel);
      activeChannels++;
    }
    return channel;
  }
}
