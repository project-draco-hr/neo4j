{
  try {
    clear();
    int sizeIndex=buf.capacity() / SIZES[SIZES.length - 1];
    if (sizeIndex == 0) {
      for (; sizeIndex < SIZES.length; sizeIndex++) {
        if (buf.capacity() == SIZES[sizeIndex]) {
          break;
        }
      }
    }
 else {
      sizeIndex+=SIZES.length - 1;
    }
    AtomicReferenceArray<Queue<Reference<ByteBuffer>>> pools=POOLS;
    SoftReference<ByteBuffer> ref=new SoftReference<>(buf);
    (sizeIndex < pools.length() ? pools.get(sizeIndex) : getOrCreatePoolForSize(sizeIndex)).add(ref);
  }
  finally {
    buf=null;
  }
}
