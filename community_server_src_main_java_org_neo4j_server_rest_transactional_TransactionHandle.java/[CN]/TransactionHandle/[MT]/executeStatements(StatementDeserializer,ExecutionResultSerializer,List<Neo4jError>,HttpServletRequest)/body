{
  try {
    boolean hasPrevious=false;
    while (statements.hasNext()) {
      Statement statement=statements.next();
      try {
        boolean hasPeriodicCommit=engine.isPeriodicCommit(statement.statement());
        if ((statements.hasNext() || hasPrevious) && hasPeriodicCommit) {
          throw new QueryExecutionKernelException(new InvalidSemanticsException("Cannot execute another statement after executing " + "PERIODIC COMMIT statement in the same transaction"));
        }
        if (!hasPrevious && hasPeriodicCommit) {
          context.closeTransactionForPeriodicCommit();
        }
        hasPrevious=true;
        TransactionalContext tc=txManagerFacade.create(request,queryService,type,mode,statement.statement(),statement.parameters());
        Result result=safelyExecute(statement,hasPeriodicCommit,tc);
        output.statementResult(result,statement.includeStats(),statement.resultDataContents());
        output.notifications(result.getNotifications());
      }
 catch (      KernelException|CypherException|AuthorizationViolationException e) {
        errors.add(new Neo4jError(e.status(),e));
        break;
      }
catch (      DeadlockDetectedException e) {
        errors.add(new Neo4jError(Status.Transaction.DeadlockDetected,e));
      }
catch (      IOException e) {
        errors.add(new Neo4jError(Status.Network.CommunicationError,e));
        break;
      }
catch (      Exception e) {
        Throwable cause=e.getCause();
        if (cause instanceof Status.HasStatus) {
          errors.add(new Neo4jError(((Status.HasStatus)cause).status(),cause));
        }
 else {
          errors.add(new Neo4jError(Status.Statement.ExecutionFailed,e));
        }
        break;
      }
    }
    addToCollection(statements.errors(),errors);
  }
 catch (  Throwable e) {
    errors.add(new Neo4jError(Status.General.UnknownError,e));
  }
}
