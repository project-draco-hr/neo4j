{
  log.info("Non clean shutdown detected on log [" + logFileName + "]. Recovery started ...");
  long[] header=readLogHeader(buffer,fileChannel,false);
  if (header == null) {
    log.info("Unable to read timestamp information, " + "no records in logical log.");
    fileChannel.close();
    boolean success=FileUtils.renameFile(new File(logFileName),new File(logFileName + "_unknown_timestamp_" + System.currentTimeMillis()+ ".log"));
    assert success;
    fileChannel=new RandomAccessFile(logFileName,"rw").getChannel();
    return;
  }
  logVersion=header[0];
  long lastCommittedTx=header[1];
  previousLogLastCommittedTx=lastCommittedTx;
  log.fine("Logical log version: " + logVersion + " with committed tx["+ lastCommittedTx+ "]");
  long logEntriesFound=0;
  long lastEntryPos=fileChannel.position();
  LogEntry entry;
  while ((entry=readEntry()) != null) {
    applyEntry(entry);
    logEntriesFound++;
    lastEntryPos=fileChannel.position();
  }
  fileChannel.position(lastEntryPos);
  buffer.clear();
  while (buffer.hasRemaining()) {
    buffer.put((byte)0);
  }
  buffer.flip();
  long endPosition=fileChannel.size();
  do {
    long bytesLeft=fileChannel.size() - fileChannel.position();
    if (bytesLeft < buffer.capacity()) {
      buffer.limit((int)bytesLeft);
    }
    fileChannel.write(buffer);
    buffer.flip();
  }
 while (fileChannel.position() < endPosition);
  fileChannel.position(lastEntryPos);
  scanIsComplete=true;
  log.fine("Internal recovery completed, scanned " + logEntriesFound + " log entries.");
  xaRm.checkXids();
  if (xidIdentMap.size() == 0) {
    log.fine("Recovery completed.");
  }
 else {
    log.fine("[" + logFileName + "] Found "+ xidIdentMap.size()+ " prepared 2PC transactions.");
    for (    LogEntry.Start startEntry : xidIdentMap.values()) {
      log.fine("[" + logFileName + "] 2PC xid["+ startEntry.getXid()+ "]");
    }
  }
  recoveredTxMap.clear();
}
