{
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  buffer.limit(1);
  while (logEntryList == null && log.read(buffer) == buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    if (logEntry.getIdentifier() == identifier) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(logEntry);
      transactions.put(logEntry.getIdentifier(),list);
    }
  break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
if (logEntry.getIdentifier() == identifier) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
if (logEntry.getIdentifier() == identifier) {
transactions.get(logEntry.getIdentifier()).add(logEntry);
}
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
break;
default :
throw new IOException("Unknown log entry " + entry);
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException("Transaction for internal identifier[" + identifier + "] not found in current log");
}
return logEntryList;
}
