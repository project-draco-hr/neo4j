{
  validateRequestType(servletRequest);
  validateResponseType(servletResponse);
  final HttpServletRequest request=(HttpServletRequest)servletRequest;
  final HttpServletResponse response=(HttpServletResponse)servletResponse;
  final String path=request.getContextPath() + (request.getPathInfo() == null ? "" : request.getPathInfo());
  if (request.getMethod().equals("OPTIONS") || whitelisted(path)) {
    filterChain.doFilter(servletRequest,servletResponse);
    return;
  }
  final String header=request.getHeader(HttpHeaders.AUTHORIZATION);
  if (header == null) {
    requestAuthentication(request,noHeader).accept(response);
    return;
  }
  final String[] usernameAndPassword=extractCredential(header);
  if (usernameAndPassword == null) {
    badHeader.accept(response);
    return;
  }
  final String username=usernameAndPassword[0];
  final String password=usernameAndPassword[1];
switch (authManager.authenticate(username,password)) {
case PASSWORD_CHANGE_REQUIRED:
    if (!PASSWORD_CHANGE_WHITELIST.matcher(path).matches()) {
      passwordChangeRequired(username,baseURL(request)).accept(response);
      return;
    }
case SUCCESS:
  filterChain.doFilter(new AuthorizedRequestWrapper(BASIC_AUTH,username,request),servletResponse);
return;
case TOO_MANY_ATTEMPTS:
tooManyAttempts.accept(response);
return;
default :
log.warn("Failed authentication attempt for '%s' from %s",username,request.getRemoteAddr());
requestAuthentication(request,invalidCredential).accept(response);
return;
}
}
