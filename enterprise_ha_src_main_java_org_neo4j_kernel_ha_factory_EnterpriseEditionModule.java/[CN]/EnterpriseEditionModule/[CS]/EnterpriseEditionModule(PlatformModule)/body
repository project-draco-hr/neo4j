{
  final LifeSupport life=platformModule.life;
  final FileSystemAbstraction fs=platformModule.fileSystem;
  final File storeDir=platformModule.storeDir;
  final Config config=platformModule.config;
  final Dependencies dependencies=platformModule.dependencies;
  final LogService logging=platformModule.logging;
  final Monitors monitors=platformModule.monitors;
  InternalLoggerFactory.setDefaultFactory(new NettyLoggerFactory(logging.getInternalLogProvider()));
  life.add(new BranchedDataMigrator(platformModule.storeDir));
  DelegateInvocationHandler<Master> masterDelegateInvocationHandler=new DelegateInvocationHandler<>(Master.class);
  Master master=(Master)Proxy.newProxyInstance(Master.class.getClassLoader(),new Class[]{Master.class},masterDelegateInvocationHandler);
  InstanceId serverId=config.get(ClusterSettings.server_id);
  RequestContextFactory requestContextFactory=dependencies.satisfyDependency(new RequestContextFactory(serverId.toIntegerIndex(),dependencies));
  TransactionCommittingResponseUnpacker responseUnpacker=dependencies.satisfyDependency(new TransactionCommittingResponseUnpacker(dependencies));
  Supplier<KernelAPI> kernelProvider=dependencies.provideDependency(KernelAPI.class);
  transactionStartTimeout=config.get(HaSettings.state_switch_timeout);
  DelegateInvocationHandler<ClusterMemberEvents> clusterEventsDelegateInvocationHandler=new DelegateInvocationHandler<>(ClusterMemberEvents.class);
  DelegateInvocationHandler<HighAvailabilityMemberContext> memberContextDelegateInvocationHandler=new DelegateInvocationHandler<>(HighAvailabilityMemberContext.class);
  DelegateInvocationHandler<ClusterMemberAvailability> clusterMemberAvailabilityDelegateInvocationHandler=new DelegateInvocationHandler<>(ClusterMemberAvailability.class);
  ClusterMemberEvents clusterEvents=dependencies.satisfyDependency((ClusterMemberEvents)Proxy.newProxyInstance(ClusterMemberEvents.class.getClassLoader(),new Class[]{ClusterMemberEvents.class,Lifecycle.class},clusterEventsDelegateInvocationHandler));
  HighAvailabilityMemberContext memberContext=(HighAvailabilityMemberContext)Proxy.newProxyInstance(HighAvailabilityMemberContext.class.getClassLoader(),new Class[]{HighAvailabilityMemberContext.class},memberContextDelegateInvocationHandler);
  ClusterMemberAvailability clusterMemberAvailability=dependencies.satisfyDependency((ClusterMemberAvailability)Proxy.newProxyInstance(ClusterMemberAvailability.class.getClassLoader(),new Class[]{ClusterMemberAvailability.class},clusterMemberAvailabilityDelegateInvocationHandler));
  final AtomicReference<HighAvailabilityMemberStateMachine> electionProviderRef=new AtomicReference<>();
  ElectionCredentialsProvider electionCredentialsProvider=config.get(HaSettings.slave_only) ? new NotElectableElectionCredentialsProvider() : new DefaultElectionCredentialsProvider(config.get(ClusterSettings.server_id),new OnDiskLastTxIdGetter(platformModule.graphDatabaseFacade),new HighAvailabilityMemberInfoProvider(){
    @Override public HighAvailabilityMemberState getHighAvailabilityMemberState(){
      return electionProviderRef.get().getCurrentState();
    }
  }
);
  ObjectStreamFactory objectStreamFactory=new ObjectStreamFactory();
  final ClusterClient clusterClient=dependencies.satisfyDependency(new ClusterClient(platformModule.monitors,ClusterClient.adapt(config),logging,electionCredentialsProvider,objectStreamFactory,objectStreamFactory));
  PaxosClusterMemberEvents localClusterEvents=new PaxosClusterMemberEvents(clusterClient,clusterClient,clusterClient,clusterClient,logging.getInternalLogProvider(),new org.neo4j.function.Predicate<PaxosClusterMemberEvents.ClusterMembersSnapshot>(){
    @Override public boolean test(    PaxosClusterMemberEvents.ClusterMembersSnapshot item){
      for (      MemberIsAvailable member : item.getCurrentAvailableMembers()) {
        if (member.getRoleUri().getScheme().equals("ha")) {
          if (HighAvailabilityModeSwitcher.getServerId(member.getRoleUri()).equals(platformModule.config.get(ClusterSettings.server_id))) {
            logging.getInternalLog(PaxosClusterMemberEvents.class).error(String.format("Instance " + "%s has" + " the same serverId as ours (%s) - will not "+ "join this cluster",member.getRoleUri(),config.get(ClusterSettings.server_id).toIntegerIndex()));
            return true;
          }
        }
      }
      return true;
    }
  }
,new HANewSnapshotFunction(),objectStreamFactory,objectStreamFactory,platformModule.monitors.newMonitor(NamedThreadFactory.Monitor.class));
  clusterClient.addClusterListener(new ClusterListener.Adapter(){
    boolean hasRequestedElection=true;
    @Override public void enteredCluster(    ClusterConfiguration clusterConfiguration){
      clusterClient.performRoleElections();
    }
    @Override public void elected(    String role,    InstanceId instanceId,    URI electedMember){
      if (hasRequestedElection && role.equals(ClusterConfiguration.COORDINATOR)) {
        clusterClient.removeClusterListener(this);
      }
    }
  }
);
  HighAvailabilityMemberContext localMemberContext=new SimpleHighAvailabilityMemberContext(clusterClient.getServerId(),config.get(HaSettings.slave_only));
  PaxosClusterMemberAvailability localClusterMemberAvailability=new PaxosClusterMemberAvailability(clusterClient.getServerId(),clusterClient,clusterClient,logging.getInternalLogProvider(),objectStreamFactory,objectStreamFactory);
  memberContextDelegateInvocationHandler.setDelegate(localMemberContext);
  clusterEventsDelegateInvocationHandler.setDelegate(localClusterEvents);
  clusterMemberAvailabilityDelegateInvocationHandler.setDelegate(localClusterMemberAvailability);
  members=dependencies.satisfyDependency(new ClusterMembers(clusterClient,clusterClient,clusterEvents,config.get(ClusterSettings.server_id)));
  memberStateMachine=new HighAvailabilityMemberStateMachine(memberContext,platformModule.availabilityGuard,members,clusterEvents,clusterClient,logging.getInternalLogProvider());
  electionProviderRef.set(memberStateMachine);
  HighAvailabilityLogger highAvailabilityLogger=new HighAvailabilityLogger(logging.getUserLogProvider(),config.get(ClusterSettings.server_id));
  platformModule.availabilityGuard.addListener(highAvailabilityLogger);
  clusterEvents.addClusterMemberListener(highAvailabilityLogger);
  clusterClient.addClusterListener(highAvailabilityLogger);
  LifeSupport paxosLife=new LifeSupport();
  paxosLife.add(clusterClient);
  paxosLife.add(memberStateMachine);
  paxosLife.add(clusterEvents);
  paxosLife.add(localClusterMemberAvailability);
  idGeneratorFactory=dependencies.satisfyDependency(createIdGeneratorFactory(masterDelegateInvocationHandler,logging.getInternalLogProvider(),requestContextFactory));
  final AtomicReference<HighAvailabilityModeSwitcher> exceptionHandlerRef=new AtomicReference<>();
  InvalidEpochExceptionHandler invalidEpochHandler=new InvalidEpochExceptionHandler(){
    @Override public void handle(){
      exceptionHandlerRef.get().forceElections();
    }
  }
;
  MasterClientResolver masterClientResolver=new MasterClientResolver(logging.getInternalLogProvider(),responseUnpacker,invalidEpochHandler,config.get(HaSettings.read_timeout).intValue(),config.get(HaSettings.lock_read_timeout).intValue(),config.get(HaSettings.max_concurrent_channels_per_slave),config.get(HaSettings.com_chunk_size).intValue());
  SwitchToSlave switchToSlaveInstance=new SwitchToSlave(logging,fs,storeDir,config,dependencies,(HaIdGeneratorFactory)idGeneratorFactory,masterDelegateInvocationHandler,clusterMemberAvailability,requestContextFactory,platformModule.kernelExtensions.listFactories(),masterClientResolver,monitors.newMonitor(ByteCounterMonitor.class,SlaveServer.class),monitors.newMonitor(RequestMonitor.class,SlaveServer.class),monitors.newMonitor(SwitchToSlave.Monitor.class),monitors.newMonitor(StoreCopyClient.Monitor.class));
  SwitchToMaster switchToMasterInstance=new SwitchToMaster(logging,platformModule.graphDatabaseFacade,(HaIdGeneratorFactory)idGeneratorFactory,config,dependencies.provideDependency(SlaveFactory.class),masterDelegateInvocationHandler,clusterMemberAvailability,platformModule.dataSourceManager,monitors.newMonitor(ByteCounterMonitor.class,MasterServer.class),monitors.newMonitor(RequestMonitor.class,MasterServer.class),monitors.newMonitor(MasterImpl.Monitor.class,MasterImpl.class));
  final HighAvailabilityModeSwitcher highAvailabilityModeSwitcher=new HighAvailabilityModeSwitcher(switchToSlaveInstance,switchToMasterInstance,clusterClient,clusterMemberAvailability,clusterClient,new Supplier<StoreId>(){
    @Override public StoreId get(){
      return dependencies.resolveDependency(NeoStoreDataSource.class).getStoreId();
    }
  }
,config.get(ClusterSettings.server_id),logging);
  exceptionHandlerRef.set(highAvailabilityModeSwitcher);
  clusterClient.addBindingListener(highAvailabilityModeSwitcher);
  memberStateMachine.addHighAvailabilityMemberListener(highAvailabilityModeSwitcher);
  paxosLife.add(highAvailabilityModeSwitcher);
  life.add(requestContextFactory);
  life.add(responseUnpacker);
  LastUpdateTime lastUpdateTime=new LastUpdateTime();
  UpdatePuller updatePuller=dependencies.satisfyDependency(life.add(new UpdatePuller(memberStateMachine,requestContextFactory,master,lastUpdateTime,logging.getInternalLogProvider(),serverId,invalidEpochHandler)));
  dependencies.satisfyDependency(life.add(new UpdatePullerClient(config.get(HaSettings.pull_interval),platformModule.jobScheduler,logging.getInternalLogProvider(),updatePuller,platformModule.availabilityGuard)));
  dependencies.satisfyDependency(life.add(new UpdatePullingTransactionObligationFulfiller(updatePuller,memberStateMachine,serverId,dependencies)));
  life.add(paxosLife);
  platformModule.diagnosticsManager.appendProvider(new HighAvailabilityDiagnostics(memberStateMachine,clusterClient));
  lockManager=dependencies.satisfyDependency(createLockManager(memberStateMachine,config,masterDelegateInvocationHandler,requestContextFactory,platformModule.availabilityGuard,logging));
  propertyKeyTokenHolder=life.add(dependencies.satisfyDependency(new PropertyKeyTokenHolder(createPropertyKeyCreator(config,memberStateMachine,masterDelegateInvocationHandler,requestContextFactory,kernelProvider))));
  labelTokenHolder=life.add(dependencies.satisfyDependency(new LabelTokenHolder(createLabelIdCreator(config,memberStateMachine,masterDelegateInvocationHandler,requestContextFactory,kernelProvider))));
  relationshipTypeTokenHolder=life.add(dependencies.satisfyDependency(new RelationshipTypeTokenHolder(createRelationshipTypeCreator(config,memberStateMachine,masterDelegateInvocationHandler,requestContextFactory,kernelProvider))));
  life.add(dependencies.satisfyDependency(createKernelData(fs,storeDir,config,platformModule.graphDatabaseFacade,members,lastUpdateTime)));
  commitProcessFactory=createCommitProcessFactory(dependencies,logging,monitors,config,life,clusterClient,members,platformModule.jobScheduler,master,requestContextFactory,memberStateMachine);
  headerInformationFactory=createHeaderInformationFactory(memberContext);
  schemaWriteGuard=new SchemaWriteGuard(){
    @Override public void assertSchemaWritesAllowed() throws InvalidTransactionTypeKernelException {
      if (!memberStateMachine.isMaster()) {
        throw new InvalidTransactionTypeKernelException("Modifying the database schema can only be done on the master server, " + "this server is a slave. Please issue schema modification commands directly to " + "the master.");
      }
    }
  }
;
  upgradeConfiguration=new HAUpgradeConfiguration();
  registerRecovery(config.get(GraphDatabaseFacadeFactory.Configuration.editionName),dependencies,logging);
}
