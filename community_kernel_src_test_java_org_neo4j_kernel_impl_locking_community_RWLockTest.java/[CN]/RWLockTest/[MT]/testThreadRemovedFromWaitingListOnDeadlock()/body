{
  RagManager ragManager=Mockito.mock(RagManager.class);
  LockResource resource=new LockResource(ResourceTypes.NODE,1l);
  final RWLock lock=new RWLock(resource,ragManager);
  final LockTransaction lockTransaction=new LockTransaction();
  final LockTransaction anotherTransaction=new LockTransaction();
  final CountDownLatch exceptionLatch=new CountDownLatch(1);
  final CountDownLatch completionLatch=new CountDownLatch(1);
  Mockito.doNothing().doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      exceptionLatch.countDown();
      throw new DeadlockDetectedException("Deadlock");
    }
  }
).when(ragManager).checkWaitOn(lock,lockTransaction);
  lock.acquireReadLock(lockTransaction);
  lock.acquireReadLock(anotherTransaction);
  Runnable writer=new Runnable(){
    @Override public void run(){
      try {
        lock.acquireWriteLock(lockTransaction);
      }
 catch (      DeadlockDetectedException ignored) {
      }
      completionLatch.countDown();
    }
  }
;
  executor.execute(writer);
  waitWaitingThreads(lock,1);
  do {
synchronized (lock) {
      lock.notifyAll();
    }
  }
 while (exceptionLatch.getCount() == 1);
  completionLatch.await();
  assertEquals("In case of deadlock caused by spurious wake up " + "thread should be removed from waiting list",0,lock.getWaitingThreadsCount());
}
