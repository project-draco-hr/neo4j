{
  logger.info("Import starting");
  NodeRelationshipLink nodeRelationshipLink=null;
  NodeLabelsCache nodeLabelsCache=null;
  long startTime=currentTimeMillis();
  File badRelationshipsFile=new File(config.badFileName());
  boolean hasBadRelationships=false;
  try (BatchingNeoStore neoStore=new BatchingNeoStore(fileSystem,storeDir,config,writeMonitor,logging,monitors,writerFactory,additionalInitialIds);OutputStream badRelationshipsOutput=new BufferedOutputStream(fileSystem.openAsOutputStream(badRelationshipsFile,false));Collector<InputRelationship> badRelationships=input.badRelationshipsCollector(badRelationshipsOutput);CountsAccessor.Updater countsUpdater=neoStore.getCountsStore().reset()){
    IdMapper idMapper=input.idMapper();
    IdGenerator idGenerator=input.idGenerator();
    nodeRelationshipLink=new NodeRelationshipLinkImpl(AUTO,config.denseNodeThreshold());
    final InputIterable<InputNode> nodes=input.nodes();
    final InputIterable<InputRelationship> relationships=input.relationships();
    final NodeStage nodeStage=new NodeStage(nodes,idMapper,idGenerator,neoStore);
    final CalculateDenseNodesStage calculateDenseNodesStage=new CalculateDenseNodesStage(relationships,nodeRelationshipLink,idMapper,badRelationships);
    if (idMapper.needsPreparation()) {
      executeStages(nodeStage);
      executeStages(calculateDenseNodesStage);
    }
 else {
      executeStages(nodeStage,calculateDenseNodesStage);
    }
    final RelationshipStage relationshipStage=new RelationshipStage(relationships,idMapper,neoStore,nodeRelationshipLink,input.specificRelationshipIds());
    executeStages(relationshipStage);
    writerFactory.awaitEverythingWritten();
    neoStore.switchToUpdateMode();
    nodeLabelsCache=new NodeLabelsCache(AUTO,neoStore.getLabelRepository().getHighId());
    StoreProcessor<NodeRecord> nodeFirstRelationshipProcessor=new NodeFirstRelationshipProcessor(neoStore.getRelationshipGroupStore(),nodeRelationshipLink);
    StoreProcessor<NodeRecord> nodeCountsProcessor=new NodeCountsProcessor(neoStore.getNodeStore(),nodeLabelsCache,neoStore.getLabelRepository().getHighId(),countsUpdater);
    StoreProcessor<RelationshipRecord> relationshipLinkerProcessor=new RelationshipLinkbackProcessor(nodeRelationshipLink);
    RelationshipCountsProcessor relationshipCountsProcessor=new RelationshipCountsProcessor(nodeLabelsCache,neoStore.getLabelRepository().getHighId(),neoStore.getRelationshipTypeRepository().getHighId(),countsUpdater);
    if (disableParallelizationSinceItCausesWrongCountsComputations() && enoughAvailableMemoryForRemainingProcessors(nodeRelationshipLink)) {
      executeStages(new NodeStoreProcessorStage("Node --> Relationship + Node counts",config,neoStore.getNodeStore(),new StoreProcessor.Multiple<>(nodeFirstRelationshipProcessor,nodeCountsProcessor)));
      nodeRelationshipLink.clearRelationships();
      executeStages(new RelationshipStoreProcessorStage("Relationship --> Relationship + Relationship counts",config,neoStore.getRelationshipStore(),new StoreProcessor.Multiple<>(relationshipLinkerProcessor,relationshipCountsProcessor)));
    }
 else {
      executeStages(new NodeStoreProcessorStage("Node --> Relationship",config,neoStore.getNodeStore(),nodeFirstRelationshipProcessor));
      nodeRelationshipLink.clearRelationships();
      executeStages(new RelationshipStoreProcessorStage("Relationship --> Relationship",config,neoStore.getRelationshipStore(),relationshipLinkerProcessor));
      nodeRelationshipLink.close();
      nodeRelationshipLink=null;
      executeStages(new NodeStoreProcessorStage("Node --> Node counts",config,neoStore.getNodeStore(),nodeCountsProcessor));
      executeStages(new RelationshipCountsStage(config,nodeLabelsCache,neoStore.getRelationshipStore(),neoStore.getLabelRepository().getHighId(),neoStore.getRelationshipTypeRepository().getHighId(),countsUpdater));
    }
    long totalTimeMillis=currentTimeMillis() - startTime;
    executionMonitor.done(totalTimeMillis);
    logger.info("Import completed, took " + Format.duration(totalTimeMillis));
    hasBadRelationships=badRelationships.badEntries() > 0;
    if (hasBadRelationships) {
      logger.warn("There were " + badRelationships.badEntries() + " bad relationships which were skipped "+ "and logged into "+ badRelationshipsFile.getAbsolutePath());
    }
  }
 catch (  Throwable t) {
    logger.error("Error during import",t);
    throw Exceptions.launderedException(IOException.class,t);
  }
 finally {
    writerFactory.shutdown();
    if (nodeRelationshipLink != null) {
      nodeRelationshipLink.close();
    }
    if (nodeLabelsCache != null) {
      nodeLabelsCache.close();
    }
    if (!hasBadRelationships) {
      fileSystem.deleteFile(badRelationshipsFile);
    }
  }
}
