{
  LogFile logFile=mock(LogFile.class);
  when(logFile.getWriter()).thenReturn(channel);
  long nextTxId=15;
  TransactionIdStore transactionIdStore=mock(TransactionIdStore.class);
  when(transactionIdStore.nextCommittingTransactionId()).thenReturn(nextTxId);
  TransactionMetadataCache positionCache=new TransactionMetadataCache(10,100);
  TransactionAppender appender=new PhysicalTransactionAppender(logFile,positionCache,transactionIdStore,BYPASS);
  final byte[] additionalHeader=new byte[]{1,2,5};
  final int masterId=2, authorId=1;
  final long timeStarted=12345, latestCommittedTxWhenStarted=4545, timeCommitted=timeStarted + 10;
  PhysicalTransactionRepresentation transactionRepresentation=new PhysicalTransactionRepresentation(singleCreateNodeCommand());
  transactionRepresentation.setHeader(additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted);
  when(transactionIdStore.getLastCommittedTransactionId()).thenReturn(latestCommittedTxWhenStarted);
  LogEntryStart start=new LogEntryStart(0,0,0l,latestCommittedTxWhenStarted,null,LogPosition.UNSPECIFIED);
  LogEntryCommit commit=new OnePhaseCommit(latestCommittedTxWhenStarted + 1,0l);
  CommittedTransactionRepresentation transaction=new CommittedTransactionRepresentation(start,transactionRepresentation,commit);
  appender.append(transaction);
  LogEntryReader<ReadableVersionableLogChannel> logEntryReader=new LogEntryReaderFactory().versionable();
  PhysicalTransactionCursor<ReadableVersionableLogChannel> reader=new PhysicalTransactionCursor<>(channel,logEntryReader);
  reader.next();
  TransactionRepresentation result=reader.get().getTransactionRepresentation();
  assertArrayEquals(additionalHeader,result.additionalHeader());
  assertEquals(masterId,result.getMasterId());
  assertEquals(authorId,result.getAuthorId());
  assertEquals(timeStarted,result.getTimeStarted());
  assertEquals(timeCommitted,result.getTimeCommitted());
  assertEquals(latestCommittedTxWhenStarted,result.getLatestCommittedTxWhenStarted());
}
