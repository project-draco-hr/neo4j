{
  LogExtractor logExtractor=null;
  try {
    final long masterLastTx=dataSource.getLastCommittedTxId();
    if (masterLastTx < endTxId) {
      throw new RuntimeException("Was requested to extract transaction ids " + startTxId + " to "+ endTxId+ " from data source "+ dataSource.getName()+ " but largest transaction id in master is "+ masterLastTx);
    }
    try {
      logExtractor=dataSource.getLogExtractor(startTxId,endTxId);
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe);
    }
    final LogExtractor finalLogExtractor=logExtractor;
    for (long txId=startTxId; txId <= endTxId; txId++) {
      if (filter.accept(txId)) {
        final long finalTxId=txId;
        TxExtractor extractor=new TxExtractor(){
          @Override public ReadableByteChannel extract(){
            InMemoryLogBuffer buffer=new InMemoryLogBuffer();
            extract(buffer);
            return buffer;
          }
          @Override public void extract(          LogBuffer buffer){
            try {
              long extractedTxId=finalLogExtractor.extractNext(buffer);
              if (extractedTxId == -1) {
                throw new RuntimeException("Transaction " + finalTxId + " is missing and can't be extracted from "+ dataSource.getName()+ ". Was about to extract "+ startTxId+ " to "+ endTxId);
              }
              if (extractedTxId != finalTxId) {
                throw new RuntimeException("Expected txId " + finalTxId + ", but was "+ extractedTxId);
              }
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
;
        stream.add(Triplet.of(dataSource.getName(),txId,extractor));
      }
    }
    return logExtractor;
  }
 catch (  Throwable t) {
    logExtractor.close();
    throw Exceptions.launderedException(t);
  }
}
