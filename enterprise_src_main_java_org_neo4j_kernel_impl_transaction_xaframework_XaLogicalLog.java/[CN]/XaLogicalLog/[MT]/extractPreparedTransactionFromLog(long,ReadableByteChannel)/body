{
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  List<LogEntry> logEntryList=new ArrayList<LogEntry>();
  buffer.clear();
  buffer.limit(1);
  boolean done=false;
  while (!done && log.read(buffer) == buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    if (logEntry.getIdentifier() == identifier) {
      logEntryList.add(logEntry);
    }
  break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
if (logEntry.getIdentifier() == identifier) {
logEntryList.add(logEntry);
}
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
break;
case LogEntry.EMPTY:
done=true;
break;
default :
throw new IOException("Unknown log entry " + entry);
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList.isEmpty()) {
throw new IOException("Transaction for internal identifier[" + identifier + "] not found in current log");
}
return logEntryList;
}
